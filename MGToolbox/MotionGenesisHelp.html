<!DOCTYPE html><HTML LANG="en"><HEAD><TITLE>MotionGenesis Help</TITLE></HEAD>
<BODY bgcolor="#FFFFFF"  Style="font-family: Times New Roman, monospace, Courier New">
<DIV Style="Margin-Left:4px; Margin-Top:8px">
<PRE>
</PRE><nobr><a name="Help"><font color="darkBlue"><font size=+1><b>Help &nbsp; <font size=-1>Copyright (c) 2009-2021 Motion Genesis LLC.  All rights reserved.</font></b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Interface (type  Help Interface  for quick tips):
 <a href="#!"><b>!</b></a>  <a href="#Clear"><b>Clear</b></a>  <a href="#Echo"><b>Echo</b></a>  <a href="#Help"><b>Help</b></a>  <a href="#List"><b>List</b></a>  <a href="#GetMemory"><b>GetMemory</b></a>  <a href="#Pause"><b>Pause</b></a>  <a href="#Run"><b>Run</b></a>  <a href="#Quit"><b>Quit</b></a>  <a href="#Save"><b>Save</b></a>  <a href="#if"><b>if</b></a>
----------------------------------------------------------------------------
Pre-defined symbols (type  HELP SYNTAX  for syntax help):
 <a href="#pi"><b>pi</b></a> <a href="#ImaginaryNumber"><b>imaginary</b></a>  <a href="#TrueFalse"><b>true</b></a> <a href="#TrueFalse"><b>false</b></a>  <a href="#%"><b>%</b></a> <a href="#%"><b>%%</b></a>   <a href="#0>"><b>0></b></a>   <a href="#0>"><b>0>></b></a>   <a href="#1>>"><b>1>></b></a>   <a href="#>"><b>></b></a>   <a href="#>"><b>>></b></a>   <a href="#="><b>:=</b></a>   <a href="#&"><b>&</b></a>  <a href="#[]"><b>[]</b></a>
 <a href="#t"><b>t</b></a>  <a href="#absError"><b>tInitial</b></a>  <a href="#absError"><b>tFinal</b></a>  <a href="#absError"><b>tStep</b></a>  <a href="#absError"><b>absError</b></a>
----------------------------------------------------------------------------
Mathematical functions  (type  HELP MathFunctions  for more help):
 <a href="#abs"><b>abs</b></a>   <a href="#exp"><b>exp</b></a>    <a href="#log"><b>log</b></a>   <a href="#log"><b>log10</b></a>   <a href="#factorial"><b>factorial</b></a>  <a href="#Squared"><b>squared</b></a>  <a href="#sqrt"><b>sqrt</b></a>   <a href="#Spline"><b>Spline</b></a>
 <a href="#cos"><b>cos</b></a>   <a href="#sin"><b>sin</b></a>    <a href="#tan"><b>tan</b></a>   <a href="#cosh"><b>cosh</b></a>    <a href="#cosh"><b>sinh</b></a>       <a href="#cosh"><b>tanh</b></a>     <a href="#acos"><b>acos</b></a>   <a href="#asin"><b>asin</b></a>    <a href="#atan"><b>atan</b></a>   <a href="#atan2"><b>atan2</b></a>
 <a href="#ceil"><b>ceil</b></a>  <a href="#ceil"><b>floor</b></a>  <a href="#int"><b>int</b></a>   <a href="#round"><b>round</b></a>   <a href="#sign"><b>sign</b></a>       <a href="#min"><b>max</b></a>      <a href="#min"><b>min</b></a>            <a href="#RandomInteger"><b>RandomInteger</b></a>
 <a href="#cos"><b>cosDegrees</b></a>   <a href="#sin"><b>sinDegrees</b></a>    <a href="#tan"><b>tanDegrees</b></a> <a href="#acos"><b>acosDegrees</b></a>     ...     <a href="#atan2"><b>atan2Degrees</b></a>
----------------------------------------------------------------------------
Mathematical commands (work on scalars, vectors, and matrices):
 <a href="#D"><b>D</b></a> <a href="#Dt"><b>Dt</b></a> <a href="#Dt"><b>DtDt</b></a>  <a href="#Evaluate"><b>Evaluate</b></a>        <a href="#Evaluate"><b>EvaluateToNumber</b></a>  <a href="#Exclude"><b>Exclude</b></a>   <a href="#Include"><b>Include</b></a>  <a href="#RoundDigits"><b>RoundDigits</b></a>
 <a href="#Integrate"><b>Integrate</b></a>  <a href="#GetCoefficient"><b>GetCoefficient</b></a>  <a href="#GetRhs"><b>GetRhs</b></a>   <a href="#GetTaylorSeries"><b>GetTaylorSeries</b></a>  <a href="#Linearize"><b>Linearize</b></a>  <a href="#ReplaceString"><b>ReplaceString</b></a>
----------------------------------------------------------------------------
Mathematical simplification (work on scalars, vectors, and matrices):
 <a href="#Expand"><b>Expand</b></a>  <a href="#Epsilon"><b>Epsilon</b></a>   <a href="#Explicit"><b>Explicit</b></a>  <a href="#Factor"><b>Factor</b></a>  <a href="#FactorLinear"><b>FactorLinear</b></a>  <a href="#FactorLinear"><b>FactorQuadratic</b></a>  <a href="#Zee"><b>Zee</b></a>
----------------------------------------------------------------------------
Logical functions:
 <a href="#if"><b>if</b></a> <a href="#TrueFalse"><b>true</b></a> <a href="#TrueFalse"><b>false</b></a>  <a href="#IsContainSymbol"><b>IsContainSymbol</b></a>  <a href="#IsSimplifyEqual"><b>IsSimplifyEqual</b></a> <a href="#IsSimplifyZero"><b>IsSimplifyZero</b></a> <a href="#IsSimplifyTrue"><b>IsSimplifyTrue</b></a>
 <a href="#Strcmp"><b>Strcmp</b></a>  <a href="#Strcmp"><b>Strcmpi</b></a>  <a href="#IsPositive"><b>IsNegative</b></a>  <a href="#IsPositive"><b>IsNegativeOr0</b></a>  <a href="#IsPositive"><b>IsPositiveOr0</b></a>  <a href="#IsPositive"><b>IsPositive</b></a>
----------------------------------------------------------------------------
Roots, solving equations, and setting ordinary derivatives
 <a href="#GetPolynomialRoots"><b>GetCubicRoots</b></a>  <a href="#GetPolynomialRoots"><b>GetQuadraticRoots</b></a>  <a href="#GetPolynomialRoots"><b>GetPolynomialRoots</b></a>  ...
 <a href="#Solve"><b>Solve</b></a>          <a href="#SolveDt"><b>SolveDt</b></a>            <a href="#SolveSetInput"><b>SolveSetInput</b></a>       <a href="#SolveSetInputDt"><b>SolveSetInputDt</b></a>
 <a href="#SetDt"><b>SetDt</b></a>  <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRoot</b></a>  <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRootDt</b></a> ...
----------------------------------------------------------------------------
Mathematical declarations:
 <a href="#Constant"><b>Constant</b></a>   <a href="#Variable"><b>Variable</b></a>   <a href="#Specified"><b>Specified</b></a>   <a href="#pi"><b>pi</b></a>   <a href="#ImaginaryNumber"><b>ImaginaryNumber</b></a>   <a href="#IndependentVariable"><b>IndependentVariable</b></a>
 <a href="#SetGeneralizedSpeed"><b>SetGeneralizedSpeed</b></a>   <a href="#SetGeneralizedSpeed"><b>SetGeneralizedCoordinate</b></a>
----------------------------------------------------------------------------
Physical declarations:
 <a href="#NewtonianFrame"><b>NewtonianFrame</b></a>   <a href="#RigidBody"><b>RigidBody</b></a>   <a href="#RigidFrame"><b>RigidFrame</b></a>   <a href="#Point"><b>Point</b></a>   <a href="#Particle"><b>Particle</b></a>    <a href="#System"><b>System</b></a>
----------------------------------------------------------------------------
Mass, center of mass, inertia, and charge:
 <a href="#GetMass"><b>GetMass</b></a>              <a href="#SetMass"><b>SetMass</b></a>              <a href="#GetCharge"><b>GetCharge</b></a>           <a href="#SetCharge"><b>SetCharge</b></a>
 <a href="#GetCMPosition"><b>GetCmPosition</b></a>        <a href="#GetCMVelocity"><b>GetCmVelocity</b></a>        <a href="#GetCMAcceleration"><b>GetCmAcceleration</b></a>
 <a href="#GetInertiaDyadic"><b>GetInertiaDyadic</b></a>     <a href="#GetInertiaMatrix"><b>GetInertiaMatrix</b></a>     <a href="#GetMomentOfInertia"><b>GetMomentOfInertia</b></a>
 <a href="#GetProductOfInertia"><b>GetProductOfInertia</b></a>  <a href="#GetRadiusOfGyration"><b>GetRadiusOfGyration</b></a>  <a href="#GetInertiaVector"><b>GetInertiaVector</b></a>    <a href="#SetInertia"><b>SetInertia</b></a>
----------------------------------------------------------------------------
Vectors and dyadics:
 <a href="#Cross"><b>Cross</b></a>                   <a href="#Cross"><b>Dot</b></a>                          <a href="#Dyadic"><b>Dyadic</b></a>   <a href="#Express"><b>Express</b></a>
 <a href="#GetAngleBetweenVectors"><b>GetAngleBetweenVectors</b></a>  <a href="#GetAngleBetweenVectors"><b>GetAngleBetweenUnitVectors</b></a>   <a href="#GetBasisVector"><b>GetBasisVector</b></a>
 <a href="#GetMagnitude"><b>GetMagnitude</b></a>            <a href="#GetMagnitude"><b>GetMagnitudeSquared</b></a>
 <a href="#GetUnitVector"><b>GetUnitVector</b></a>           <a href="#Vector"><b>Vector</b></a>
----------------------------------------------------------------------------
Matrices:
 <a href="#GetColumns"><b>GetColumns</b></a>      <a href="#GetDeterminant"><b>GetDeterminant</b></a>      <a href="#GetDiagonalMatrix"><b>GetDiagonalMatrix</b></a>   <a href="#GetEigen"><b>GetEigen</b></a>   <a href="#GetNorm"><b>GetNorm</b></a>
 <a href="#GetElement"><b>GetElement</b></a> <a href="#[]"><b>[]</b></a>   <a href="#GetIdentityMatrix"><b>GetIdentityMatrix</b></a>   <a href="#GetInverse"><b>GetInverse</b></a>          <a href="#GetColumns"><b>GetRows</b></a>    <a href="#GetTrace"><b>GetTrace</b></a>
 <a href="#GetTranspose"><b>GetTranspose</b></a>    <a href="#GetIdentityMatrix"><b>GetZeroMatrix</b></a>       <a href="#Matrix"><b>Matrix</b></a>              <a href="#Convolve"><b>Convolve</b></a>   <a href="#SVD"><b>SVD</b></a>
----------------------------------------------------------------------------
Rotational kinematics (rotation matrices, angular velocity/acceleration):
 <a href="#Rotate"><b>Rotate</b></a>                  <a href="#RotateX"><b>RotateX</b></a>  <a href="#RotateY"><b>RotateY</b></a>  <a href="#RotateZ"><b>RotateZ</b></a>   <a href="#RotateX"><b>RotateNegativeX</b></a>  ...
 <a href="#GetRotationMatrix"><b>GetRotationMatrix</b></a>       <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>           <a href="#SetRotationMatrixODE"><b>SetRotationMatrixODE</b></a>
 <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>      <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>          <a href="#GetAngularSpeed"><b>GetAngularSpeed</b></a> ...
 <a href="#GetAngularAcceleration"><b>GetAngularAcceleration</b></a>  <a href="#SetAngularAcceleration"><b>SetAngularAcceleration</b></a> <a href="#SetAngularVelocityAcceleration"><b>SetAngularVelocityAcceleration</b></a>
----------------------------------------------------------------------------
Translational kinematics (position, velocity, acceleration)
 <a href="#Translate"><b>Translate</b></a>        <a href="#SetPositionVelocity"><b>SetPositionVelocity</b></a>        <a href="#SetVelocityAcceleration"><b>SetVelocityAcceleration</b></a>
 <a href="#SetPosition"><b>SetPosition</b></a>      <a href="#GetPosition"><b>GetPosition</b></a>   <a href="#GetDistance"><b>GetDistance</b></a>  <a href="#GetDistance"><b>GetDistanceSquared</b></a>
 <a href="#SetVelocity"><b>SetVelocity</b></a>      <a href="#GetVelocity"><b>GetVelocity</b></a>   <a href="#GetSpeed"><b>GetSpeed</b></a>     <a href="#GetElongation"><b>GetElongation</b></a>
 <a href="#SetAcceleration"><b>SetAcceleration</b></a>  <a href="#GetAcceleration"><b>GetAcceleration</b></a>            <a href="#GetJacobian"><b>GetVelocityJacobian</b></a> ...
----------------------------------------------------------------------------
Forces:
 <a href="#AddForce"><b>AddForce</b></a>              <a href="#AddForceDamper"><b>AddForceDamper</b></a> <a href="#AddForceElectrostatic"><b>AddForceElectrostatic</b></a>  <a href="#AddForceGravity"><b>AddForceGravity</b></a>
 <a href="#AddForceInverseSquare"><b>AddForceInverseSquare</b></a> <a href="#AddForceSpring"><b>AddForceSpring</b></a> <a href="#AddForceLinearActuator"><b>AddForceLinearActuator</b></a> <a href="#GetResultantForce"><b>GetResultantForce</b></a>
----------------------------------------------------------------------------
Torque and Moments:
 <a href="#AddTorque"><b>AddTorque</b></a>   <a href="#AddTorqueDamper"><b>AddTorqueDamper</b></a>   <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>   <a href="#GetResultantTorque"><b>GetResultantTorque</b></a>
----------------------------------------------------------------------------
Potential energy and dissipation functions
 <a href="#GetForceGravityPotentialEnergy"><b>GetForceGravityPotentialEnergy</b></a>         <a href="#GetForceSpringPotentialEnergy"><b>GetForceSpringPotentialEnergy</b></a>
 <a href="#GetForceElectrostaticPotentialEnergy"><b>GetForceElectrostaticPotentialEnergy</b></a>   <a href="#GetForceInverseSquarePotentialEnergy"><b>GetForceInverseSquarePotentialEnergy</b></a>
----------------------------------------------------------------------------
Kinetic energy and angular/translational (linear) momentum (also see Gyrostat):
 <a href="#GetKineticEnergy"><b>GetKineticEnergy</b></a> <a href="#GetAngularMomentum"><b>GetAngularMomentum</b></a> <a href="#GetTranslationalMomentum"><b>GetTranslationalMomentum</b></a> <a href="#GetGeneralizedMomentum"><b>GetGeneralizedMomentum</b></a>
----------------------------------------------------------------------------
Statics and dynamics commands:
 <a href="#GetStatics"><b>GetStatics</b></a>    <a href="#Kane"><b>GetStaticsKane</b></a>    <a href="#Lagrange"><b>GetStaticsLagrange</b></a>    <a href="#Constrain"><b>Constrain</b></a>
 <a href="#GetDynamics"><b>GetDynamics</b></a>   <a href="#Kane"><b>GetDynamicsKane</b></a>   <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>
----------------------------------------------------------------------------
Units and unit conversions:
 <a href="#ConvertUnits"><b>ConvertUnits</b></a>   <a href="#GetUnitSystem"><b>GetUnitSystem</b></a>   <a href="#SetUnitSystem"><b>SetUnitSystem</b></a>
----------------------------------------------------------------------------
Code languages and commands: .c,  .m,  .f,  .for,  ...
 <a href="#ODE"><b>ODE</b></a>   <a href="#Solve"><b>Solve</b></a>   <a href="#Input"><b>Input</b></a>   <a href="#Output"><b>Output</b></a>   <a href="#Output"><b>OutputPlot</b></a>   <a href="#Plot"><b>Plot</b></a>   <a href="#Animate"><b>Animate</b></a>
 <a href="#Code"><b>Code</b></a>  <a href="#Algebraic"><b>Algebraic</b></a>  <a href="#Nonlinear"><b>Nonlinear</b></a>
----------------------------------------------------------------------------
Old commands (for backward compatibility only).
 <a href="#Angvel"><b>Angvel</b></a>  <a href="#KinDiffs"><b>KinDiffs</b></a>  <a href="#Dircos"><b>Dircos</b></a>  <a href="#FrStar"><b>FrStar</b></a>  <a href="#Gyrostat"><b>Gyrostat</b></a>  <a href="#Simprot"><b>Simprot</b></a>  <a href="#V1PT"><b>V1PT</b></a> <a href="#V2PTS"><b>V2PTS</b></a> <a href="#V1PT"><b>A1PT</b></a> <a href="#V2PTS"><b>A2PTS</b></a>
----------------------------------------------------------------------------
Defaults  (type  DEFAULTS  for a list of defaults):
 <a href="#SetAutoDifferentiate"><b>SetAutoDifferentiate</b></a>  <a href="#SetAutoEpsilon"><b>SetAutoEpsilon</b></a>    <a href="#SetAutoExpress"><b>SetAutoExpress</b></a>     <a href="#SetAutoFactor"><b>SetAutoFactor</b></a>
 <a href="#SetAutoTaylorSeries"><b>SetAutoLinearize</b></a>      <a href="#SetAutoOverwrite"><b>SetAutoOverwrite</b></a>  <a href="#SetAutoRhs"><b>SetAutoRhs</b></a>         <a href="#SetAutoSimplify"><b>SetAutoSimplify</b></a>
 <a href="#SetAutoTaylorSeries"><b>SetAutoTaylorSeries</b></a>   <a href="#SetAutoZee"><b>SetAutoZee</b></a>        <a href="#SetBasisSubscripts"><b>SetBasisSubscripts</b></a> <a href="#SetCmSymbol"><b>SetCmSymbol</b></a>
 <a href="#SetComplex"><b>SetComplex</b></a>            <a href="#SetDigits"><b>SetDigits</b></a>         <a href="#GetDefaults"><b>SetDefaults</b></a>        <a href="#AUTOLEV"><b>AUTOLEV</b></a>
 <a href="#SetLineStepping"><b>SetLineStepping</b></a>       <a href="#SetLineWidth"><b>SetLineWidth</b></a>      <a href="#SetPauseOnWarning"><b>SetPauseOnWarning</b></a>  <a href="#SetUnitSystem"><b>SetUnitSystem</b></a>
 <a href="#SetWorkingDirectory"><b>SetWorkingDirectory</b></a>   <a href="#GetEnvironmentValue"><b>GetEnvironmentValue</b></a>
----------------------------------------------------------------------------
Type  HELP NAME  for help with NAME; e.g.,  HELP SYNTAX


</PRE><nobr><a name=">"><font color="darkBlue"><font size=+1><b>></b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
>    >>    >>>

 Purpose:  >    at the end of a name identifies the name as a vector.
           >>   at the end of a name identifies the name as a dyadic.
           >>>  at the end of a name identifies the name as a triadic.

Syntax 1:  nameA>    is treated as a vector.
Syntax 2:  nameB>>   is treated as a dyadic.
Syntax 3:  nameC>>   is treated as a triadic or higher-order polyadic.

 Related:  <a href="#0>"><b>0></b></a>  <a href="#0>"><b>0>></b></a>  <a href="#1>>"><b>1>></b></a>  <a href="#Vector"><b>Vector</b></a>  <a href="#Dyadic"><b>Dyadic</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example:  >   >>   >>>   0>   0>>   0>>>
   (3) %--------------------------------------------------------------------
   (4) RigidFrame  A
   (5) v> = 2*Ax> + 3*Ay> + 4*Az>                % >    denotes a vector
-> (6) v> = 2*Ax> + 3*Ay> + 4*Az>

   (7) d>> = 2*Ax>*Ax> + 3*Ay>*Az>               % >>   denotes a dyadic
-> (8) d>> = 2*Ax>*Ax> + 3*Ay>*Az>

   (9) t>>> = 2*Ax>*Ax>*Ax> + 3*Ax>*Ay>*Az>      % >>>  denotes a triadic
-> (10) t>>> = 2*Ax>*Ax>*Ax> + 3*Ax>*Ay>*Az>

   (11) v0> = Cross(  Ax>,  Ax> )                 % 0>   denotes the zero vector.
-> (12) v0> = 0>

   (13) d0>> = Cross(  Ax> * Ay>,   Ay> )         % 0>>  denotes the zero dyadic.
-> (14) d0>> = 0>>

   (15) t0>>> = Cross(  Ax> * Ay> * Az>,  Az> )   % 0>>> denotes the zero triadic.
-> (16) t0>>> = 0>>>



</PRE><nobr><a name="0>"><font color="darkBlue"><font size=+1><b>0></b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
0>    0>>    0>>>    0>>>>    ...  etc

 Purpose:  0>    is the zero vector  (0 magnitude and a direction).
           0>>   is the zero dyadic  (0 magnitude and two directions).
           0>>>  is the zero triadic (0 magnitude and three directions).

Syntax 1:  0>            Note:  0>    is a vector, NOT equal to scalar 0.
Syntax 2:  0>>           Note:  0>>   is equivalent to 0> * 0>
Syntax 3:  0>>>          Note:  0>>>  is equivalent to 0> * 0> * 0>
Syntax 4:  0>>>>         Note:  0>>>> is equivalent to 0> * 0> * 0> * 0>

 Related:  <a href="#>"><b>></b></a>  <a href="#>"><b>>></b></a>  <a href="#>"><b>>>></b></a>  <a href="#0>"><b>0></b></a>  <a href="#0>"><b>0>></b></a>  <a href="#1>>"><b>1>></b></a>  <a href="#Vector"><b>Vector</b></a> <a href="#Dyadic"><b>Dyadic</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example:  >   >>   >>>   0>   0>>   0>>>
   (3) %--------------------------------------------------------------------
   (4) RigidFrame  A
   (5) v> = 2*Ax> + 3*Ay> + 4*Az>                % >    denotes a vector
-> (6) v> = 2*Ax> + 3*Ay> + 4*Az>

   (7) d>> = 2*Ax>*Ax> + 3*Ay>*Az>               % >>   denotes a dyadic
-> (8) d>> = 2*Ax>*Ax> + 3*Ay>*Az>

   (9) t>>> = 2*Ax>*Ax>*Ax> + 3*Ax>*Ay>*Az>      % >>>  denotes a triadic
-> (10) t>>> = 2*Ax>*Ax>*Ax> + 3*Ax>*Ay>*Az>

   (11) v0> = Cross(  Ax>,  Ax> )                 % 0>   denotes the zero vector.
-> (12) v0> = 0>

   (13) d0>> = Cross(  Ax> * Ay>,   Ay> )         % 0>>  denotes the zero dyadic.
-> (14) d0>> = 0>>

   (15) t0>>> = Cross(  Ax> * Ay> * Az>,  Az> )   % 0>>> denotes the zero triadic.
-> (16) t0>>> = 0>>>



</PRE><nobr><a name="1>>"><font color="darkBlue"><font size=+1><b>1>></b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
1>>

 Purpose:  1>>  is the unit dyadic whose defining property is
           Dot( 1>>, anyVector> ) = anyVector>

  Syntax:  1>>

 Related:  <a href="#>"><b>></b></a>  <a href="#>"><b>>></b></a>  <a href="#>"><b>>>></b></a>  <a href="#0>"><b>0></b></a>  <a href="#0>"><b>0>></b></a>  <a href="#1>>"><b>1>></b></a>  <a href="#Vector"><b>Vector</b></a> <a href="#Dyadic"><b>Dyadic</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example:  1>>   Unit dyadic
   (3) %--------------------------------------------------------------------
   (4) RigidFrame A
   (5) v> = Dot(  1>>,   2*Ax> + 3*Ay> + 4*Az>  )
-> (6) v> = 2*Ax> + 3*Ay> + 4*Az>

   (7) d>> = Cross(  1>>,   Ax>  )
-> (8) d>> = -Ay>*Az> + Az>*Ay>



</PRE><nobr><a name="!"><font color="darkBlue"><font size=+1><b>!</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
!

 Purpose:  Opens an operating system command shell or
           issues an operating system command.

Syntax 1:  !
Syntax 2:  !OperatingSystemCommand

   Input:  OperatingSystemCommand -- a command that can be interpreted
           by the operating system (e.g., Windows, OSX, Unix, etc).
           For example, to display the time, type: !time
           To list the files in the current Windows directory, type: !dir
           To list the files in the current Unix directory, type: !ls

Output 1:  Opens an operating system command shell.
           Note:  Type EXIT at the operating system prompt to exit from
           the operating system shell and return to the program workspace.

Output 2:  Passes OperatingSystemCommand to the operating system.

  Remark:  Since OperatingSystemCommand may include the  ;  character
           it must appear on its own input line -- and not on a line
           that has multiple statements separated by a ;, e.g., not as
           !dir *.txt;  !dir *.tex

 Related:  <a href="#!"><b>!</b></a>  <a href="#%"><b>%</b></a>  <a href="#&"><b>&</b></a>  <a href="#Clear"><b>Clear</b></a>  <a href="#List"><b>List</b></a>  <a href="#Pause"><b>Pause</b></a>  <a href="#Quit"><b>Quit</b></a>  <a href="#Run"><b>Run</b></a>  <a href="#Save"><b>Save</b></a>  <a href="#GetDefaults"><b>GetDefaults</b></a>

--------------------------------------------------------------------
 Example:  !
--------------------------------------------------------------------
   (1) !dir


   (1) %--------------------------------------------------------------------
   (2) % Example: List the files ending with "txt" in the current working directory.
   (3) %--------------------------------------------------------------------


</PRE><nobr><a name="%"><font color="darkBlue"><font size=+1><b>%</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
 %  or  %%

 Purpose:  Marks the beginning of a comment.
           Marks the beginning of a comment that is to be incorporated
           in a C, Fortran, or MATLAB programs.

Syntax 1:  %  Put your comment here
Syntax 2:  %% Put a comment to be written to code here.

 Remark:   A regular comment is a sequence of characters beginning with  %
           Characters following  %  are otherwise ignored.
           A code comment is a sequence of characters beginning with  %%
           Characters after  %%  are written to C, Fortran, or MATLAB codes.

 Related:  <a href="#!"><b>!</b></a>  <a href="#%"><b>%</b></a>  <a href="#&"><b>&</b></a>  <a href="#Clear"><b>Clear</b></a>  <a href="#List"><b>List</b></a>  <a href="#Pause"><b>Pause</b></a>  <a href="#Quit"><b>Quit</b></a>  <a href="#Run"><b>Run</b></a>  <a href="#Save"><b>Save</b></a>  <a href="#GetDefaults"><b>GetDefaults</b></a>


   (1) %--------------------------------------------------------------------
   (2) % Example:  %   Marks a comment in a MotionGenesis script.
   (3) %--------------------------------------------------------------------
   (4) %    File: SomeFileName.txt
   (5) % Purpose: Biomechanic analysis of human motion in deep space.
   (6) %
   (7) %--------------------------------------------------------------------
   (8) % Example:  %%  Marks a comment to be written to C, Fortran, or MATLAB programs.
   (9) %--------------------------------------------------------------------
   (10) %%  if( x == 2 )
   (11) %%    y = sin(x+2);
   (12) %%  else
   (13) %%    y = cos(x+3);


</PRE><nobr><a name="&"><font color="darkBlue"><font size=+1><b>&</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
 &

 Purpose:  The ampersand  &  is the multi-line continuation symbol.
           It instructs the program to read the next line in a file.
           & is not useful for keyboard input.

 Related:  <a href="#!"><b>!</b></a>  <a href="#%"><b>%</b></a>  <a href="#&"><b>&</b></a>  <a href="#Clear"><b>Clear</b></a>  <a href="#List"><b>List</b></a>  <a href="#Pause"><b>Pause</b></a>  <a href="#Quit"><b>Quit</b></a>  <a href="#Run"><b>Run</b></a>  <a href="#Save"><b>Save</b></a>  <a href="#GetDefaults"><b>GetDefaults</b></a>


   (1) %--------------------------------------------------------------------
   (2) % Example 1:  Line continuation with a scalar expression.
   (3) %--------------------------------------------------------------------
   (4) a =  0 +  1 +  2 +  3 +  4 +  5 +  6 +  7 +  8   &
         + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18   &
         + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 
-> (5) a = 378

   (6) %--------------------------------------------------------------------
   (7) % Example 2:  Line continuation to beautify matrix input.
   (8) %--------------------------------------------------------------------
   (9) Fred = [ 1, 2, 3, 4;   &
                5, 6, 7, 8;   &
                9, 7, 5, 3]
-> (10) Fred = [1, 2, 3, 4;  5, 6, 7, 8;  9, 7, 5, 3]



</PRE><nobr><a name="+"><font color="darkBlue"><font size=+1><b>+</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
 +  or  -

 Purpose:  Adds or subtracts scalars, matrices, vectors, dyadics, etc.
           +  Declares a real scalar as inherently non-negative.
           -  Declares a real scalar as inherently non-positive.

Syntax 1:  a + b   returns the sum of a and b.
           a - b   returns a + (-b).
Syntax 2:  Constant  m+
Syntax 3:  Constant  n-

 Input 1:  a, b -- scalars or matrices or vectors or dyadics, etc.
 Input 2:  m:  an inherently non-negative (0 or positive) scalar.
 Input 3:  n:  an inherently non-positive (0 or negative) scalar.

  Remark:  Inherently non-negative or non-positive scalars affect
           simplification with abs, sqrt, etc.

 Related:  <a href="#+"><b>+</b></a>  <a href="#+"><b>-</b></a>  <a href="#*"><b>*</b></a>  <a href="#*"><b>/</b></a>  <a href="#^"><b>^</b></a>  <a href="#sign"><b>sign</b></a>  <a href="#Constant"><b>Constant</b></a>  <a href="#Variable"><b>Variable</b></a>  <a href="#Specified"><b>Specified</b></a>  <a href="#abs"><b>abs</b></a>  <a href="#sqrt"><b>sqrt</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  +  -  (scalars)
   (3) %--------------------------------------------------------------------
   (4) Constant  a,  b,  m+,  n-
   (5) s1 = 2 + 2 + a
-> (6) s1 = 4 + a

   (7) s2 = 9 - 2 - b
-> (8) s2 = 7 - b

   (9) y = abs(m) + abs(m) + sqrt(m^2)
-> (10) y = 3*m

   (11) z = abs(n) + abs(n) + sqrt(n^2)
-> (12) z = -3*n

   (13) %--------------------------------------------------------------------
   (14) % Example 2:  +  -  (matrices)
   (15) %--------------------------------------------------------------------
   (16) mat1 = [1, 2;  3, 4]  +  [a, b;  m, n] 
-> (17) mat1 = [1 + a, 2 + b;  3 + m, 4 + n]

   (18) mat2 = mat1 - mat1 
-> (19) mat2 = [0, 0;  0, 0]

   (20) %--------------------------------------------------------------------
   (21) % Example 3:  +  -  (vectors)
   (22) %--------------------------------------------------------------------
   (23) RigidFrame  F
   (24) v> = a*Fx> + b*Fy>
-> (25) v> = a*Fx> + b*Fy>

   (26) vSum> = v> + v>
-> (27) vSum> = 2*a*Fx> + 2*b*Fy>

   (28) vDiff> = v> - v>
-> (29) vDiff> = 0>



</PRE><nobr><a name="*"><font color="darkBlue"><font size=+1><b>*</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
 *  or  /

 Purpose:  Multiplies scalars, matrices, vectors, dyadics, etc., or
           divides these quantities by a scalar.

Syntax 1:  a * b   returns a multiplied by b.
Syntax 2:  a / s   returns a divided by the scalar s.

   Input:  a, b -- scalars or matrices or vectors or dyadics, etc.
           s    -- scalar.

 Related:  <a href="#+"><b>+</b></a>  <a href="#+"><b>-</b></a>  <a href="#*"><b>*</b></a>  <a href="#*"><b>/</b></a>  <a href="#^"><b>^</b></a>  <a href="#sqrt"><b>sqrt</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  *  /  (scalars)
   (3) %--------------------------------------------------------------------
   (4) Constant  a, b
   (5) s1 = 8 * 2 * a
-> (6) s1 = 16*a

   (7) s2 = 8 / 2 / b
-> (8) s2 = 4/b

   (9) %--------------------------------------------------------------------
   (10) % Example 2:  *  /  (matrices)
   (11) %--------------------------------------------------------------------
   (12) mat1 = [a, b;  t, cos(t)] * a
-> (13) mat1 = [a^2, a*b;  a*t, a*cos(t)]

   (14) mat2 = [a, b;  t, cos(t)] / a
-> (15) mat2 = [1, b/a;  t/a, cos(t)/a]

   (16) mat3 = mat1 * mat2
-> (17) mat3 = [a^2 + b*t, b*(a+cos(t));  t*(a+cos(t)), b*t + cos(t)^2]

   (18) %--------------------------------------------------------------------
   (19) % Example 3:  *  /  (vectors)
   (20) %--------------------------------------------------------------------
   (21) RigidFrame  F
   (22) v1> = (a*Fx> + b*Fy>) * t
-> (23) v1> = a*t*Fx> + b*t*Fy>

   (24) v2> = (a*Fx> + b*Fy>) / t
-> (25) v2> = a/t*Fx> + b/t*Fy>

   (26) dyadic>> = v1> * v2>
-> (27) dyadic>> = a^2*Fx>*Fx> + a*b*Fx>*Fy> + a*b*Fy>*Fx> + b^2*Fy>*Fy>



</PRE><nobr><a name="^"><font color="darkBlue"><font size=+1><b>^</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
 ^

 Purpose:  Exponentiation of a scalar.

  Syntax:  a ^ b    returns a raised to the power b.

  Remark:  a ^ 0.5  returns sqrt(a).
           sqrt(-1) returns the imaginary number.

   Input:  a, b -- scalars or scalar expressions.

 Related:  <a href="#+"><b>+</b></a>  <a href="#+"><b>-</b></a>  <a href="#*"><b>*</b></a>  <a href="#*"><b>/</b></a>  <a href="#^"><b>^</b></a>  <a href="#sqrt"><b>sqrt</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  ^  (scalars)
   (3) %--------------------------------------------------------------------
   (4) Constant  a, b
   (5) s1 = -8^2 * a^b
-> (6) s1 = -64*a^b

   (7) s2 = (-1)^(0.5) * a^(0.5)
-> (8) s2 = imaginary*sqrt(a)

   (9) %--------------------------------------------------------------------
   (10) % Example 2:  ^  (vectors)
   (11) %--------------------------------------------------------------------
   (12) RigidFrame  F
   (13) v1> = a*Fx> + b*Fy>
-> (14) v1> = a*Fx> + b*Fy>

   (15) v1Squared = MagnitudeSquared( v1> )
-> (16) v1Squared = a^2 + b^2



</PRE><nobr><a name="="><font color="darkBlue"><font size=+1><b>=</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
=   :=   +=   *=   /=   ^=    SetDt  SetNoDt

 Purpose:  Assignment operators.

Syntax 1:  A  = B
Syntax 2:  A := B
Syntax 3:  A += B
Syntax 4:  A *= B
Syntax 5:  A /= B
Syntax 6:  A ^= B
Syntax 7:  SetDt( A = B )
Syntax 8:  SetNoDt( A = B )

   Input:  A -- the name of a scalar, vector, dyadic, triadic, or matrix.
           B -- a scalar, vector, dyadic, triadic or matrix expression.

Output 1:  Assigns A = B.
Output 2:  Assigns A = B,          overwriting any previous assignment of A.
Output 3:  Assigns A = Rhs(A) + B, overwriting any previous assignment of A.
Output 4:  Assigns A = Rhs(A) * B, overwriting any previous assignment of A.
Output 5:  Assigns A = Rhs(A) / B, overwriting any previous assignment of A.
Output 6:  Assigns A = Rhs(A) ^ B, overwriting any previous assignment of A.
Output 7:  Assigns A = B  and tries to differentiate to assign A', A'', etc.
Output 8:  Assigns A = B  and does not differentiate to assign A', A'', etc.

 Related:  <a href="#SetAutoDifferentiate"><b>SetAutoDifferentiate</b></a>  <a href="#SetAutoOverwrite"><b>SetAutoOverwrite</b></a>
           <a href="#SetDt"><b>SetDt</b></a>  <a href="#Solve"><b>Solve</b></a>  <a href="#SolveDt"><b>SolveDt</b></a>  <a href="#SolveSetInput"><b>SolveSetInput</b></a>  <a href="#SolveSetInputDt"><b>SolveSetInputDt</b></a>  ...
           <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRoot</b></a>  <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRootDt</b></a>  ...
           <a href="#SetDt"><b>SetDt</b></a>  <a href="#SetDt"><b>SetNoDt</b></a>   <a href="#="><b>=</b></a>   <a href="#="><b>:=</b></a>   <a href="#="><b>+=</b></a>   <a href="#="><b>*=</b></a>   <a href="#="><b>/=</b></a>   <a href="#="><b>^=</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  :=  (assign overwrite operator)
   (3) %--------------------------------------------------------------------
   (4) x = sin(t)
-> (5) x = sin(t)

   (6) x := t^5
-> (7) x = t^5

   (8) %--------------------------------------------------------------------
   (9) % Example 2:  +=  (assign addition operator)
   (10) %--------------------------------------------------------------------
   (11) x += 2
-> (12) x = 2 + t^5

   (13) %--------------------------------------------------------------------
   (14) % Example 3:  *=  (assign multiply operator)
   (15) %--------------------------------------------------------------------
   (16) x *= 3
-> (17) x = 6 + 3*t^5

   (18) %--------------------------------------------------------------------
   (19) % Example 4:  /=  (assign divide operator)
   (20) %--------------------------------------------------------------------
   (21) x /= 10
-> (22) x = 0.6 + 0.3*t^5

   (23) %--------------------------------------------------------------------
   (24) % Example 5:  ^=  (assign power operator)
   (25) %--------------------------------------------------------------------
   (26) x ^= 0.5
-> (27) x = 0.5477226*sqrt(2+t^5)



</PRE><nobr><a name="AbsError"><font color="darkBlue"><font size=+1><b>AbsError</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
absError  relError  tInitial  tFinal  tStep  printIntScreen  printIntFile

absError:  Controls numerical integration error (for ODEs) and
           allowed error in solutions to nonlinear algebraic equations.
           absError is a small positive number compared to variables
           being numerically integrated (e.g. via the ODE command)
           or numerically solved (e.g., via the Solve command).

           For numerically integration, absError should be set to
           10^(-8) * xSmall,  where xSmall is the estimated smallest
           maximum absolute value of the variables being integrated.
           The default value of absError (e.g., absError = 1.0E-7) can
           be changed (with optional units) via the Input command, e.g.,
           Input  absError = 1.0E-5

relError:  To override the usually _adequate_ default value, set relError
           to  10^(-d),  where d is the desired number of accurate digits
           for numerical integration (e.g., ODE command).  For example:
           Input  relError = 1.0E-7

           relError is a small non-negative number (0 <= relError <= 0.01),
           has no units, and is generally less than  10^(-n)  where n is
           governed by the SetDigits command (i.e., the number of significant
           digits displayed by the program and the code it generates).

tInitial:  For numerical integration (e.g., ODE command), the default
           initial (start) value of the independent variable (time t) is
           tInitial = 0  and can be changed via the Input command, e.g.,
           Input  tInitial = -3.2 sec

tFinal:    For numerical integration (e.g., ODE command), the default
           final (stop) value of the independent variable (time t) is
           tFinal = 0  and can be changed via the Input command, e.g.,
           Input  tFinal = 5.4 sec

tStep:     For numerical integration (e.g., ODE command), the maximum
           numerical integration stepsize (time-step) is a positive or
           negative number (forward or backward integration) and its
           default value, e.g., 0.01*(tFinal-tInitial), can be changed via
           Input  tStep = 0.002 seconds

printIntScreen:  For numerical integration (e.g., ODE), this nonnegative
           integer (which has no units and a default value of 1) affects the
           interval = tStep * printIntScreen  for OUTPUT to the screen.
           To suppress screen Output, set printIntScreen = 0 via
           Input  printIntScreen = 0

printIntFile:   Similar to printIntScreen (no units and default value of 1)
           except  tStep * printIntFile  affects Output to Files.
           To suppress OUTPUT to files, set  printIntFile = 0  via
           Input  printIntFile = 0

  Remark:  For FORTRAN codes, printIntScreen also controls printIntFile and
           printIntScreen = 0  is identical to printIntScreen = 1.

  Remark:  Solutions are approximate.  Acccuracy tends to improve as the
           input value assigned to absError and/or relError gets smaller.

 Related:  <a href="#ODE"><b>ODE</b></a>  <a href="#Solve"><b>Solve</b></a>  <a href="#Input"><b>Input</b></a>  <a href="#Output"><b>Output</b></a>  <a href="#Output"><b>OutputPlot</b></a>  <a href="#Plot"><b>Plot</b></a>  <a href="#Animate"><b>Animate</b></a>
           <a href="#t"><b>t</b></a>  <a href="#absError"><b>tInitial</b></a>  <a href="#absError"><b>tFinal</b></a>  <a href="#absError"><b>tStep</b></a>  <a href="#absError"><b>absError</b></a>  <a href="#absError"><b>printIntScreen</b></a>  <a href="#absError"><b>printIntFile</b></a>
           <a href="#Solve"><b>Solve</b></a>  <a href="#SolveDt"><b>SolveDt</b></a>  <a href="#SolveSetInput"><b>SolveSetInput</b></a>  <a href="#SolveSetInputDt"><b>SolveSetInputDt</b></a>  ...

   (1) %--------------------------------------------------------------------
   (2) % Example: absError, relError, tInitial, tFinal, tStep, ...
   (3) %--------------------------------------------------------------------
   (4) Variable x'' = 2*sin(x) 
-> (5) x'' = 2*sin(x)

   (6) Input x = 1 m,  x' = 0 m/s
   (7) Input absError = 1E-5 cm,  relError = 1E-7
   (8) Input tInitial = -3 sec,  tFinal = 2 sec,  tStep = 0.02 sec
   (9) Input printIntScreen = 1,  printIntFile = 0
   (10) Output  t sec,  x m,  x' m/s,  x'' m/s^2
   (11) ODE() odePendulumExample



</PRE><nobr><a name="abs"><font color="darkBlue"><font size=+1><b>abs</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
abs

 Purpose:  Returns the absolute value of a real scalar expression
           or the modulus of a complex expression.

  Syntax:  abs( scalarExpression )

   Input:  scalarExpression -- a real or complex scalar expression.

  Output:  Returns the absolute value of scalarExpression

  Remark:  Use  abs           for absolute value of a real or complex scalar.
           Use  GetMagnitude  for the magnitude of a vector.
           Use  GetNorm       for the 2-norm of a real row or column matrix.

 Related:  <a href="#ImaginaryNumber"><b>ImaginaryNumber</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>
           <a href="#GetMagnitude"><b>GetMagnitude</b></a>     <a href="#GetMagnitude"><b>GetMagnitudeSquared</b></a>     <a href="#abs"><b>abs</b></a>     <a href="#GetNorm"><b>GetNorm</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: abs   (real scalar expressions)
   (3) %--------------------------------------------------------------------
   (4) A = abs( -3 )
-> (5) A = 3

   (6) B = abs(3+t)
-> (7) B = abs(3+t)

   (8) %--------------------------------------------------------------------
   (9) % Example 2: abs   (complex scalar expressions)
   (10) %--------------------------------------------------------------------
   (11) C = abs( 4 + 3*GetImaginaryNumber() )
-> (12) C = 5

   (13) D = abs( t - 3*GetImaginaryNumber() )
-> (14) D = abs(t-3*imaginary)



</PRE><nobr><a name="acos"><font color="darkBlue"><font size=+1><b>acos</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
acos

 Purpose:  Returns the inverse cosine of a scalar expression.

Syntax 1:  acos( scalarExpression )
Syntax 2:  acosDegrees( realNumber )

   Input:  scalarExpression -- a real or complex scalar expression.
           realNumber -- expression that resolves to a real number.

Output 1:  Radian measure of the inverse cosine of scalarExpression.
Output 2:  Degree measure of the inverse cosine of realNumber.

 Related:  <a href="#ConvertUnits"><b>ConvertUnits</b></a>  <a href="#ImaginaryNumber"><b>ImaginaryNumber</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>
           <a href="#cos"><b>cos</b></a>  <a href="#sin"><b>sin</b></a>  <a href="#tan"><b>tan</b></a>  <a href="#acos"><b>acos</b></a>  <a href="#asin"><b>asin</b></a>  <a href="#atan"><b>atan</b></a>  <a href="#atan2"><b>atan2</b></a>  <a href="#cos"><b>cosDegrees</b></a>  ...

   (1) %--------------------------------------------------------------------
   (2) % Example 1: acos   (real scalar expressions)
   (3) %--------------------------------------------------------------------
   (4) angleInRadians = acos( 0.5 ) 
-> (5) angleInRadians = 1.047198

   (6) angleInDegrees = acosDegrees( 0.5 )  
-> (7) angleInDegrees = 60

   (8) Arad = acos(0.5+2*t) 
-> (9) Arad = acos(0.5+2*t)

   (10) Adeg = acos(0.5+2*t) * ConvertUnits(rad,deg) 
-> (11) Adeg = 57.29578*acos(0.5+2*t)

   (12) %--------------------------------------------------------------------
   (13) % Example 2: acos   (complex scalar expressions)
   (14) %--------------------------------------------------------------------
   (15) B = acos( 3*GetImaginaryNumber() )
-> (16) B = 1.570796 - 1.818446*imaginary

   (17) C = acos( t - 3*GetImaginaryNumber() )
-> (18) C = acos(t-3*imaginary)



</PRE><nobr><a name="asin"><font color="darkBlue"><font size=+1><b>asin</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
asin

 Purpose:  Returns the inverse sine of a scalar expression.

Syntax 1:  asin( scalarExpression )
Syntax 2:  asinDegrees( realNumber )

   Input:  scalarExpression -- a real or complex scalar expression.
           realNumber -- expression that resolves to a real number.

Output 1:  Radian measure of the inverse sine of scalarExpression.
Output 2:  Degree measure of the inverse sine of realNumber.

 Related:  <a href="#ConvertUnits"><b>ConvertUnits</b></a>  <a href="#ImaginaryNumber"><b>ImaginaryNumber</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>
           <a href="#cos"><b>cos</b></a>  <a href="#sin"><b>sin</b></a>  <a href="#tan"><b>tan</b></a>  <a href="#acos"><b>acos</b></a>  <a href="#asin"><b>asin</b></a>  <a href="#atan"><b>atan</b></a>  <a href="#atan2"><b>atan2</b></a>  <a href="#cos"><b>cosDegrees</b></a>  ...

   (1) %--------------------------------------------------------------------
   (2) % Example 1: asin   (real scalar expressions)
   (3) %--------------------------------------------------------------------
   (4) angleInRadians = asin( 0.5 ) 
-> (5) angleInRadians = 0.5235988

   (6) angleInDegrees = asinDegrees( 0.5 ) 
-> (7) angleInDegrees = 30

   (8) Arad = asin(0.5+2*t)
-> (9) Arad = asin(0.5+2*t)

   (10) Adeg = asin(0.5+2*t) * ConvertUnits(rad,deg)
-> (11) Adeg = 57.29578*asin(0.5+2*t)

   (12) %--------------------------------------------------------------------
   (13) % Example 2: asin   (complex scalar expressions)
   (14) %--------------------------------------------------------------------
   (15) B = asin( 3*GetImaginaryNumber() )
-> (16) B = 1.818446*imaginary

   (17) C = asin( t - 3*GetImaginaryNumber() )
-> (18) C = asin(t-3*imaginary)



</PRE><nobr><a name="atan"><font color="darkBlue"><font size=+1><b>atan</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
atan

 Purpose:  Returns the inverse tangent of a scalar expression.

Syntax 1:  atan( scalarExpression )
Syntax 2:  atanDegrees( realNumber )

   Input:  scalarExpression -- a real or complex scalar expression.
           realNumber -- expression that resolves to a real number.

Output 1:  Radian measure of the inverse tangent of scalarExpression.
Output 2:  Degree measure of the inverse tangent of realNumber.

 Related:  <a href="#ConvertUnits"><b>ConvertUnits</b></a>  <a href="#ImaginaryNumber"><b>ImaginaryNumber</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>
           <a href="#cos"><b>cos</b></a>  <a href="#sin"><b>sin</b></a>  <a href="#tan"><b>tan</b></a>  <a href="#acos"><b>acos</b></a>  <a href="#asin"><b>asin</b></a>  <a href="#atan"><b>atan</b></a>  <a href="#atan2"><b>atan2</b></a>  <a href="#cos"><b>cosDegrees</b></a>  ...

   (1) %--------------------------------------------------------------------
   (2) % Example 1: atan   (real scalar expressions)
   (3) %--------------------------------------------------------------------
   (4) angleInRadians = atan( 1.0 ) 
-> (5) angleInRadians = 0.7853982

   (6) angleInDegrees = atanDegrees( 1.0 ) 
-> (7) angleInDegrees = 45

   (8) Arad = atan(0.5+2*t)
-> (9) Arad = atan(0.5+2*t)

   (10) Adeg = atan(0.5+2*t) * ConvertUnits(rad,deg)
-> (11) Adeg = 57.29578*atan(0.5+2*t)

   (12) %--------------------------------------------------------------------
   (13) % Example 2: atan   (complex scalar expressions)
   (14) %--------------------------------------------------------------------
   (15) B = atan( 3*GetImaginaryNumber() )
-> (16) B = 0.25*imaginary

   (17) C = atan( t - 3*GetImaginaryNumber() )
-> (18) C = atan(t-3*imaginary)



</PRE><nobr><a name="atan2"><font color="darkBlue"><font size=+1><b>atan2</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
atan2

 Purpose:  Returns the two-argument inverse tangent.

Syntax 1:  atan2( y, x )
Syntax 2:  atan2Degrees( y, x )

   Input:  y -- an expression that resolves to a real number
           x -- an expression that resolves to a real number

  Output:  Returns the angle theta that satisfies the equations

           sin(theta) = y/(x^2+y^2)
           cos(theta) = x/(x^2+y^2)

Output 1:  theta in radians in the range -pi  to pi.
Output 2:  theta in degrees in the range -180 to 180.

  Remark:  y and x cannot both be equal to zero.

 Related:  <a href="#ConvertUnits"><b>ConvertUnits</b></a>  <a href="#ImaginaryNumber"><b>ImaginaryNumber</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>
           <a href="#cos"><b>cos</b></a>  <a href="#sin"><b>sin</b></a>  <a href="#tan"><b>tan</b></a>  <a href="#acos"><b>acos</b></a>  <a href="#asin"><b>asin</b></a>  <a href="#atan"><b>atan</b></a>  <a href="#atan2"><b>atan2</b></a>  <a href="#cos"><b>cosDegrees</b></a>  ...

   (1) %--------------------------------------------------------------------
   (2) % Example: atan2   
   (3) %--------------------------------------------------------------------
   (4) angleInRadians = atan2(  3,  3 ) 
-> (5) angleInRadians = 0.7853982

   (6) angleInDegrees = atan2Degrees(  3,  3 ) 
-> (7) angleInDegrees = 45

   (8) angleQuadrant2 = atan2Degrees(  3, -3 )
-> (9) angleQuadrant2 = 135

   (10) angleQuadrant3 = atan2Degrees( -3, -3 ) 
-> (11) angleQuadrant3 = -135

   (12) angleQuadrant4 = atan2Degrees( -3,  3 ) 
-> (13) angleQuadrant4 = -45

   (14) angle4Degrees  = atan2( -3, 3 ) * ConvertUnits( rad, deg )
-> (15) angle4Degrees = -45



</PRE><nobr><a name="AddForce"><font color="darkBlue"><font size=+1><b>AddForce</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
AddForce   ResetForce

 Purpose:  Adds (or resets) force on a point or particle.

Syntax 1:  Q.AddForce(       forceVec )
Syntax 2:  Q.AddForce(   P,  forceVec )
Syntax 3:  Q.ResetForce(     forceVec )
Syntax 4:  Q.ResetForce( P,  forceVec )

   Input:  Q -- the name of a point or particle.
           P -- the name of a point or particle.
           forceVec -- a force vector.

Output 1:  Adds  forceVec  to  Force_Q>    (accumulates force on Q).
Output 2:  Adds  forceVec  to  Force_Q_P>  (accumulates force on Q from P).
Output 3:  Force_Q>    is reset to  forceVec.
Output 4:  Force_Q_P>  is reset to  forceVec.

  Remark:  Syntax 1 is for  "external"  forces applied to Q.
           Force_Q>  denotes the contact and distance forces on Q that are
           "external" to all objects in any system under consideration
           (and perhaps also external to the NewtonianFrame).
           Syntax 1 is frequently used for external forces such as Earth's
           gravity, air-resistance, contact forces with roads, etc.
    Note:  Q.GetResultantForce()  accounts for both  Force_Q>  and all
           action/reaction forces on Q such as Force_Q_P>, Force_Q_S>, etc.

  Remark:  Syntax 2 is for  "action/reaction"  forces applied to Q from P
           that fully obey Newton's 3rd law (action/reaction), meaning
           forceVec  MUST  be parallel to the line joining P and Q.
           Syntax 2 is frequently used for translational springs/dampers,
           ropes, rods, planetary gravity, charged particles, etc.
    Note:  Avoid Syntax 2 if forceVec is not parallel to line PQ.
           Instead use:   Q.AddForce( forceVec );   P.AddForce( -forceVec )
    Note:  Q.GetResultantForce(P)  returns  Force_Q_P> - Force_P_Q>.

  Remark:  When sensible, use Syntax 2 instead of Syntax 1 as it efficiently
           accounts for action/reaction forces by knowing whether P and Q
           are internal, external, or mixed for the system under consideration.

  Remark:  Alternate ways to apply a force  vec>  to point Q include:
           Force_Q>  = vec>      % Resets    Force_Q>  to    vec>
           Force_Q> += vec>      % Adds          vec>  to    Force_Q>
           Force_Q> -= vec>      % Subtracts     vec>  from  Force_Q>
           Force_Q_P>  = vec>    % Resets  Force_Q_P>  to    vec>
           Force_Q_P> += vec>    % Adds          vec>  to    Force_Q_P>
           Force_Q_P> -= vec>    % Subtracts     vec>  from  Force_Q_P>

  Remark:  If Q is a point of a RigidFrame or RigidBody B, declare it as
           Point Q(B).  This helps with subsequent velocity/acceleration
           and force/moment calculations.

 Related:  <a href="#AddForce"><b>AddForce</b></a>  <a href="#AddForceDamper"><b>AddForceDamper</b></a>  <a href="#AddForceElectrostatic"><b>AddForceElectrostatic</b></a>  <a href="#AddForceGravity"><b>AddForceGravity</b></a>
           <a href="#AddForceInverseSquare"><b>AddForceInverseSquare</b></a>  <a href="#AddForceLinearActuator"><b>AddForceLinearActuator</b></a>  <a href="#AddForceSpring"><b>AddForceSpring</b></a>
           <a href="#AddTorque"><b>AddTorque</b></a>  <a href="#AddTorqueDamper"><b>AddTorqueDamper</b></a>
           <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>  <a href="#GetResultantTorque"><b>GetResultantTorque</b></a>
           <a href="#GetForceGravityPotentialEnergy"><b>GetForceGravityPotentialEnergy</b></a>  <a href="#GetForceSpringPotentialEnergy"><b>GetForceSpringPotentialEnergy</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: AddForce  (add force to a point or particle)
   (3) %--------------------------------------------------------------------
   (4) RigidBody  A, B    
   (5) Ao.AddForce( Ax> + 2*Ay> )               
-> (6) Force_Ao> = Ax> + 2*Ay>

   (7) Ao.AddForce( 3*Az> )               
-> (8) Force_Ao> = Ax> + 2*Ay> + 3*Az>

   (9) Acm.AddForce( 4*Ax> + 5*Ay>  + 6*Az> )               
-> (10) Force_Acm> = 4*Ax> + 5*Ay> + 6*Az>

   (11) ResultantForceOnA> = A.GetResultantForce()
-> (12) ResultantForceOnA> = 5*Ax> + 7*Ay> + 9*Az>

   (13) %--------------------------------------------------------------------
   (14) % Example 2: AddForce (action/reaction with two points/particles)
   (15) %--------------------------------------------------------------------
   (16) Ao.AddForce( Bo,  3*Az> )   
-> (17) Force_Ao_Bo> = 3*Az>

   (18) ResultantForceBoFromAo> = Bo.GetResultantForce( Ao )
-> (19) ResultantForceBoFromAo> = -3*Az>

   (20) ResultantForceOnAo> = Ao.GetResultantForce()
-> (21) ResultantForceOnAo> = Ax> + 2*Ay> + 6*Az>

   (22) Acm.AddForce( Bcm,  6*Az> ) 
-> (23) Force_Acm_Bcm> = 6*Az>

   (24) ResultantForceOnA> := A.GetResultantForce()
-> (25) ResultantForceOnA> = 5*Ax> + 7*Ay> + 18*Az>

   (26) ResultantForceOnB> := B.GetResultantForce()
-> (27) ResultantForceOnB> = -9*Az>

   (28) ResultantForceOnS> := System.GetResultantForce()
-> (29) ResultantForceOnS> = 5*Ax> + 7*Ay> + 9*Az>

   (30) %--------------------------------------------------------------------
   (31) % Example 3+4: ResetForce (reset force on a point or particle)
   (32) %--------------------------------------------------------------------
   (33) Ao.ResetForce( sin(t)*Ax> )               
-> (34) Force_Ao> = sin(t)*Ax>

   (35) Ao.ResetForce( Bo,  cos(t)*Az> )   
-> (36) Force_Ao_Bo> = cos(t)*Az>



</PRE><nobr><a name="AddForceDamper"><font color="darkBlue"><font size=+1><b>AddForceDamper</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
AddForceDamper

 Purpose:  Applies damper forces between two points.

Syntax 1:  Q.AddForceDamper( P, b )
Syntax 2:  Q.AddForceDamper( P, b, elongationExponent )

   Input:  Q -- the name of a point.
           P -- the name of a point.
           b -- the damper constant (scalar)
           elongationExponent -- the exponent on the damper's elongation

Output 1:  Adds a damper force on Q from P whose magnitude is equal to
           b * elongation  where elongation is the time-derivative of
           the distance between Q and P.

Output 2:  Adds a damper force on Q from P whose magnitude is equal to
           b * elongation^elongationExponent.

  Remark:  Q's position vector from P must be available.

  Remark:  If Q is a point of a RigidFrame or RigidBody B, declare it as
           Point Q(B).  This helps with subsequent velocity/acceleration
           and force/moment calculations.

 Related:  <a href="#AddForce"><b>AddForce</b></a>  <a href="#AddForceDamper"><b>AddForceDamper</b></a>  <a href="#AddForceElectrostatic"><b>AddForceElectrostatic</b></a>  <a href="#AddForceGravity"><b>AddForceGravity</b></a>
           <a href="#AddForceInverseSquare"><b>AddForceInverseSquare</b></a>  <a href="#AddForceLinearActuator"><b>AddForceLinearActuator</b></a>  <a href="#AddForceSpring"><b>AddForceSpring</b></a>
           <a href="#AddTorque"><b>AddTorque</b></a>  <a href="#AddTorqueDamper"><b>AddTorqueDamper</b></a>
           <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>  <a href="#GetResultantTorque"><b>GetResultantTorque</b></a>
           <a href="#GetForceGravityPotentialEnergy"><b>GetForceGravityPotentialEnergy</b></a>  <a href="#GetForceSpringPotentialEnergy"><b>GetForceSpringPotentialEnergy</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: AddForceDamper 
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N
   (5) Particle  P1
   (6) Variable  x', y'
   (7) Constant  b
   (8) P1.SetPositionVelocity( No, x*Nx> )
-> (9) p_No_P1> = x*Nx>
-> (10) v_P1_N> = x'*Nx>

   (11) P1.AddForceDamper( No, b )
-> (12) Force_P1_No> = -b*x'*Nx>

   (13) %--------------------------------------------------------------------
   (14) % Example 2: AddForceDamper 
   (15) %--------------------------------------------------------------------
   (16) Particle  Q1
   (17) Q1.SetPositionVelocity( P1, y*Ny> )
-> (18) p_P1_Q1> = y*Ny>
-> (19) v_Q1_N> = x'*Nx> + y'*Ny>

   (20) Q1.AddForceDamper( P1, b )
-> (21) Force_Q1_P1> = -b*y'*Ny>

   (22) Q1.AddForceDamper( No, b )
-> (23) Force_Q1_No> = -b*x*(x*x'+y*y')/(x^2+y^2)*Nx> - b*y*(x*x'+y*y')/(x^2+y^2)*Ny>

   (24) %--------------------------------------------------------------------
   (25) % Example 3: AddForceDamper 
   (26) %--------------------------------------------------------------------
   (27) Particle  P2
   (28) P2.SetPositionVelocity( No, x*Nx> )
-> (29) p_No_P2> = x*Nx>
-> (30) v_P2_N> = x'*Nx>

   (31) P2.AddForceDamper( No, b, 3 )
-> (32) Force_P2_No> = -b*x'^3*Nx>

   (33) %--------------------------------------------------------------------
   (34) % Example 4: AddForceDamper 
   (35) %--------------------------------------------------------------------
   (36) Particle  Q2
   (37) Q2.SetPositionVelocity( P2, y*Ny> )
-> (38) p_P2_Q2> = y*Ny>
-> (39) v_Q2_N> = x'*Nx> + y'*Ny>

   (40) Q2.AddForceDamper( P2, b, 2 )
-> (41) Force_Q2_P2> = -b*y^3*y'^2/abs(y)^3*Ny>



</PRE><nobr><a name="AddForceElectrostatic"><font color="darkBlue"><font size=+1><b>AddForceElectrostatic</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
AddForceElectrostatic

 Purpose:  Applies an inverse-square electrostatic force on two points.

  Syntax:  Q.AddForceElectrostatic( P, k )

   Input:  Q -- the name of a point
           P -- the name of a point
           k -- scalar representing the electrostatic proportionality
                constant, approximately 8.9875518E+09 N*m^2/Coulomb^2.

  Output:  Adds an inverse-square-law electrostatic force to Q from P.

  Remark:  Ensure charges are assigned to Q and P with the commands:
           Q.SetCharge(...)  and  P.SetCharge(...).

  Remark:  The NIST approximation for k is 8.9875518E+09 N*m^2/Coulomb^2.

  Remark:  If Q is a point of a RigidFrame or RigidBody B, declare it as
           Point Q(B).  This helps with subsequent velocity/acceleration
           and force/moment calculations.

 Related:  <a href="#AddForce"><b>AddForce</b></a>  <a href="#AddForceDamper"><b>AddForceDamper</b></a>  <a href="#AddForceElectrostatic"><b>AddForceElectrostatic</b></a>  <a href="#AddForceGravity"><b>AddForceGravity</b></a>
           <a href="#AddForceInverseSquare"><b>AddForceInverseSquare</b></a>  <a href="#AddForceLinearActuator"><b>AddForceLinearActuator</b></a>  <a href="#AddForceSpring"><b>AddForceSpring</b></a>
           <a href="#AddTorque"><b>AddTorque</b></a>  <a href="#AddTorqueDamper"><b>AddTorqueDamper</b></a>
           <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>  <a href="#GetResultantTorque"><b>GetResultantTorque</b></a>
           <a href="#GetForceGravityPotentialEnergy"><b>GetForceGravityPotentialEnergy</b></a>  <a href="#GetForceSpringPotentialEnergy"><b>GetForceSpringPotentialEnergy</b></a>
           <a href="#GetForceElectrostaticPotentialEnergy"><b>GetForceElectrostaticPotentialEnergy</b></a>  <a href="#GetCharge"><b>GetCharge</b></a>  <a href="#SetCharge"><b>SetCharge</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: AddForceElectrostatic  (horizontal 1D)
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N
   (5) Particle  A
   (6) Variable  xA
   (7) Constant  k
   (8) No.SetCharge( chargeN )
   (9) A.SetCharge(  chargeA )
   (10) A.SetPosition( No, xA*Nx> )
-> (11) p_No_A> = xA*Nx>

   (12) A.AddForceElectrostatic( No, k )
-> (13) Force_A_No> = chargeA*chargeN*k*xA/abs(xA)^3*Nx>

   (14) %--------------------------------------------------------------------
   (15) % Example 2: AddForceElectrostatic  (planar 2D)
   (16) %--------------------------------------------------------------------
   (17) Particle  P, Q
   (18) Variable  x, y
   (19) P.SetCharge( 10 )
   (20) Q.SetCharge( 20 )
   (21) Q.SetPosition( P, x*Nx> + y*Ny> )
-> (22) p_P_Q> = x*Nx> + y*Ny>

   (23) Q.AddForceElectrostatic( P, k )
-> (24) Force_Q_P> = 200*k*x/(x^2+y^2)^1.5*Nx> + 200*k*y/(x^2+y^2)^1.5*Ny>



</PRE><nobr><a name="AddForceGravity"><font color="darkBlue"><font size=+1><b>AddForceGravity</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
AddForceGravity

 Purpose:  Applies a force associated with the resultant force produced
           by a uniform parallel gravitational field, to the mass center
           of a massive object (e.g., a Particle or RigidBody) or to all
           particles and/or mass centers of all rigid bodies in a System.

           Applies an inverse-square law gravitational force on a
           Particle from another Particle.

Syntax 1:  Object.AddForceGravity( gravityVector )
Syntax 2:  Q.AddForceGravity( P, G )

   Input:  Object -- the name of a Particle, RigidBody, or System

           gravityVector -- A vector whose magnitude is equal to the
                            local gravitational acceleration constant
                            and whose direction is locally downward.

           Q -- the name of a Particle
           P -- the name of a Particle
           G -- a scalar representing the universal gravitational constant.
                currently estimated by NIST as 6.6732E-11 N m^2 kg^(-2).

Output 1:  Adds a uniform local gravity force to Object (e.g, a Particle or
           the mass center of a RigidBody or all massive objects in a System),
           and returns the sum of all gravity forces added to Object.

Output 2:  Adds a universal gravitational force (inverse square law) to
           Particle Q from Particle P, and returns the force added to Q.
           Note: Q's position vector from P must be available.

  Remark:  Ensure mass is assigned to appropriate particles and bodies
           before issuing an AddForceGravity command.

           NIST defines Earth's gravity acceleration as 9.80665 m/sec^2.
           The NIST approximation for G is 6.6732E-11 N m^2 kg^(-2).
           The mass of the Earth is approximately 5.97E24 kg.
           The mass of the Moon  is approximately 7.34E22 kg.
           Earth's equatorial radius is approximately 6356 km (3949.4 miles).

  Remark:  If Q is a point of a RigidFrame or RigidBody B, declare it as
           Point Q(B).  This helps with subsequent velocity/acceleration
           and force/moment calculations.

 Related:  <a href="#AddForce"><b>AddForce</b></a>  <a href="#AddForceDamper"><b>AddForceDamper</b></a>  <a href="#AddForceElectrostatic"><b>AddForceElectrostatic</b></a>  <a href="#AddForceGravity"><b>AddForceGravity</b></a>
           <a href="#AddForceInverseSquare"><b>AddForceInverseSquare</b></a>  <a href="#AddForceLinearActuator"><b>AddForceLinearActuator</b></a>  <a href="#AddForceSpring"><b>AddForceSpring</b></a>
           <a href="#AddTorque"><b>AddTorque</b></a>  <a href="#AddTorqueDamper"><b>AddTorqueDamper</b></a>
           <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>  <a href="#GetResultantTorque"><b>GetResultantTorque</b></a>
           <a href="#GetForceGravityPotentialEnergy"><b>GetForceGravityPotentialEnergy</b></a>  <a href="#GetForceSpringPotentialEnergy"><b>GetForceSpringPotentialEnergy</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: AddForceGravity  (Uniform "local" gravity) 
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N
   (5) Particle  P, Q
   (6) RigidBody B
   (7) P.SetMass( mP )
   (8) Q.SetMass( mQ )
   (9) B.SetMass( mB )
   (10) System.AddForceGravity( -9.8*Ny> )
-> (11) Force_Bcm> = -9.8*mB*Ny>
-> (12) Force_P> = -9.8*mP*Ny>
-> (13) Force_Q> = -9.8*mQ*Ny>

   (14) ResultantGravityForce> = System.GetResultantForce()
-> (15) ResultantGravityForce> = (-9.8*mB-9.8*mP-9.8*mQ)*Ny>

   (16) %--------------------------------------------------------------------
   (17) % Example 2: AddForceGravity  (Inverse-square "universal" gravity) 
   (18) %--------------------------------------------------------------------
   (19) Constant  G
   (20) Variable  x, y
   (21) Q.SetPosition( P, x*Nx> + y*Ny> )
-> (22) p_P_Q> = x*Nx> + y*Ny>

   (23) Q.AddForceGravity( P, G )
-> (24) Force_Q_P> = -mP*mQ*G*x/(x^2+y^2)^1.5*Nx> - mP*mQ*G*y/(x^2+y^2)^1.5*Ny>



</PRE><nobr><a name="AddForceInverseSquare"><font color="darkBlue"><font size=+1><b>AddForceInverseSquare</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
AddForceInverseSquare

 Purpose:  Applies an inverse-square force on a point from another point.

  Syntax:  Q.AddForceInverseSquare( P, coef )

   Input:  Q -- the name of a point
           P -- the name of a point
           coef -- a scalar expression

  Output:  Adds an inverse square force to point Q from point P, and
           returns the force added to particle Q.
           Note: Q's position vector from P must be available.

  Remark:  The force is calculated as:
           coef / Q.GetDistanceSquared(P) * Q.GetUnitVector(P)

  Remark:  A positive coef corresponds to a repulsive force,
           i.e., a force that pushes Q away from P, whereas
           a negative coef corresponds to an attractive force,
           i.e., a force that pulls Q towards P.

  Remark:  If Q is a point of a RigidFrame or RigidBody B, declare it as
           Point Q(B).  This helps with subsequent velocity/acceleration
           and force/moment calculations.

 Related:  <a href="#AddForce"><b>AddForce</b></a>  <a href="#AddForceDamper"><b>AddForceDamper</b></a>  <a href="#AddForceElectrostatic"><b>AddForceElectrostatic</b></a>  <a href="#AddForceGravity"><b>AddForceGravity</b></a>
           <a href="#AddForceInverseSquare"><b>AddForceInverseSquare</b></a>  <a href="#AddForceLinearActuator"><b>AddForceLinearActuator</b></a>  <a href="#AddForceSpring"><b>AddForceSpring</b></a>
           <a href="#AddTorque"><b>AddTorque</b></a>  <a href="#AddTorqueDamper"><b>AddTorqueDamper</b></a>
           <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>  <a href="#GetResultantTorque"><b>GetResultantTorque</b></a>
           <a href="#GetForceGravityPotentialEnergy"><b>GetForceGravityPotentialEnergy</b></a>  <a href="#GetForceSpringPotentialEnergy"><b>GetForceSpringPotentialEnergy</b></a>
           <a href="#GetForceElectrostaticPotentialEnergy"><b>GetForceElectrostaticPotentialEnergy</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: AddForceInverseSquare
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N
   (5) Particle  P, Q
   (6) Variable  x, y
   (7) Q.SetPosition( P, x*Nx> + y*Ny> )
-> (8) p_P_Q> = x*Nx> + y*Ny>

   (9) Q.AddForceInverseSquare( P, 8 )
-> (10) Force_Q_P> = 8*x/(x^2+y^2)^1.5*Nx> + 8*y/(x^2+y^2)^1.5*Ny>



</PRE><nobr><a name="AddForceLinearActuator"><font color="darkBlue"><font size=+1><b>AddForceLinearActuator</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
AddForceLinearActuator

 Purpose:  Applies a linear actuator force between two points.

Syntax:    Q.AddForceLinearActuator( P, FActuator )

   Input:  Q -- the name of a point.
           P -- the name of a point.
           FActuator -- scalar measure of the force on Q from P.

  Output:  Adds a force on Q from P whose magnitude is FActuator.
           When FActuator is positive, the actuator pushes Q away from P,
           i.e., the actuator force is directed towards Q from P.

  Remark:  Q's position vector from P must be available.

  Remark:  If Q is a point of a RigidFrame or RigidBody B, declare it as
           Point Q(B).  This helps with subsequent velocity/acceleration
           and force/moment calculations.

 Related:  <a href="#AddForce"><b>AddForce</b></a>  <a href="#AddForceDamper"><b>AddForceDamper</b></a>  <a href="#AddForceElectrostatic"><b>AddForceElectrostatic</b></a>  <a href="#AddForceGravity"><b>AddForceGravity</b></a>
           <a href="#AddForceInverseSquare"><b>AddForceInverseSquare</b></a>  <a href="#AddForceLinearActuator"><b>AddForceLinearActuator</b></a>  <a href="#AddForceSpring"><b>AddForceSpring</b></a>
           <a href="#AddTorque"><b>AddTorque</b></a>  <a href="#AddTorqueDamper"><b>AddTorqueDamper</b></a>
           <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>  <a href="#GetResultantTorque"><b>GetResultantTorque</b></a>
           <a href="#GetForceGravityPotentialEnergy"><b>GetForceGravityPotentialEnergy</b></a>  <a href="#GetForceSpringPotentialEnergy"><b>GetForceSpringPotentialEnergy</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: AddForceLinearActuator  (on particle A from point No)
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N
   (5) Particle  A
   (6) Variable  xA
   (7) Specified Fx
   (8) A.SetPosition( No, xA*Nx> )
-> (9) p_No_A> = xA*Nx>

   (10) A.AddForceLinearActuator( No, Fx )
-> (11) Force_A_No> = Fx*xA/abs(xA)*Nx>

   (12) %--------------------------------------------------------------------
   (13) % Example 2: AddForceLinearActuator  (on particle Q from particle P)
   (14) %--------------------------------------------------------------------
   (15) Particle  P, Q
   (16) Variable  x, y
   (17) Specified F
   (18) Q.SetPosition( P, x*Nx> + y*Ny> )
-> (19) p_P_Q> = x*Nx> + y*Ny>

   (20) Q.AddForceLinearActuator( P, F )
-> (21) Force_Q_P> = F*x/sqrt(x^2+y^2)*Nx> + F*y/sqrt(x^2+y^2)*Ny>



</PRE><nobr><a name="AddForceSpring"><font color="darkBlue"><font size=+1><b>AddForceSpring</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
AddForceSpring

 Purpose:  Applies spring forces between two points.

Syntax 1:  Q.AddForceSpring( P, k, Ln )
Syntax 2:  Q.AddForceSpring( P, k, Ln, stretchExponent )

   Input:  Q -- the name of a point.
           P -- the name of a point.
           k -- the spring constant (scalar)
           Ln -- the spring's natural length (scalar)
           stretchExponent -- the exponent on the spring's stretch (scalar)

Output 1:  Adds a spring force on Q from P whose magnitude is k * stretch
           where stretch = L-Ln  and  L  is the distance between Q and P.
           The spring pulls Q towards P (spring force is directed from Q to P).

Output 2:  Adds a spring force on Q from P whose magnitude is equal to
           k * stretch^stretchExponent.

  Remark:  Q's position vector from P must be available.

  Remark:  If Q is a point of a RigidFrame or RigidBody B, declare it as
           Point Q(B).  This helps with subsequent velocity/acceleration
           and force/moment calculations.

 Related:  <a href="#AddForce"><b>AddForce</b></a>  <a href="#AddForceDamper"><b>AddForceDamper</b></a>  <a href="#AddForceElectrostatic"><b>AddForceElectrostatic</b></a>  <a href="#AddForceGravity"><b>AddForceGravity</b></a>
           <a href="#AddForceInverseSquare"><b>AddForceInverseSquare</b></a>  <a href="#AddForceLinearActuator"><b>AddForceLinearActuator</b></a>  <a href="#AddForceSpring"><b>AddForceSpring</b></a>
           <a href="#AddTorque"><b>AddTorque</b></a>  <a href="#AddTorqueDamper"><b>AddTorqueDamper</b></a>
           <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>  <a href="#GetResultantTorque"><b>GetResultantTorque</b></a>
           <a href="#GetForceGravityPotentialEnergy"><b>GetForceGravityPotentialEnergy</b></a>  <a href="#GetForceSpringPotentialEnergy"><b>GetForceSpringPotentialEnergy</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: AddForceSpring  (natural length is 0)
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N
   (5) Particle  P1, Q1
   (6) Variable  x, y
   (7) Constant  k, Ln
   (8) Q1.SetPosition( P1, x*Nx> )
-> (9) p_P1_Q1> = x*Nx>

   (10) Q1.AddForceSpring( P1, k, 0 )
-> (11) Force_Q1_P1> = -k*x*Nx>

   (12) %--------------------------------------------------------------------
   (13) % Example 2: AddForceSpring  (natural length Ln)
   (14) %--------------------------------------------------------------------
   (15) Particle  P2, Q2
   (16) Q2.SetPosition( P2, x*Nx> )
-> (17) p_P2_Q2> = x*Nx>

   (18) Q2.AddForceSpring( P2, k, Ln )
-> (19) Force_Q2_P2> = -k*x*(1-Ln/abs(x))*Nx>

   (20) %--------------------------------------------------------------------
   (21) % Example 3: AddForceSpring  (natural length Ln and exponent 3)
   (22) %--------------------------------------------------------------------
   (23) Particle  P3, Q3
   (24) Q3.SetPosition( P3, y*Ny> )
-> (25) p_P3_Q3> = y*Ny>

   (26) Q3.AddForceSpring( P3, k, Ln, 3 )
-> (27) Force_Q3_P3> = k*y*(Ln-abs(y))^3/abs(y)*Ny>

   (28) %--------------------------------------------------------------------
   (29) % Example 4: AddForceSpring  (position vector with two components)
   (30) %--------------------------------------------------------------------
   (31) Particle  P4, Q4
   (32) Q4.SetPosition( P4, x*Nx> + y*Ny> )
-> (33) p_P4_Q4> = x*Nx> + y*Ny>

   (34) Q4.AddForceSpring( P4, k, Ln )
-> (35) Force_Q4_P4> = -k*x*(1-Ln/sqrt(x^2+y^2))*Nx> - k*y*(1-Ln/sqrt(x^2+y^2))*Ny>



</PRE><nobr><a name="AddTorque"><font color="darkBlue"><font size=+1><b>AddTorque</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
AddTorque  ResetTorque

 Purpose:  Adds (or resets) torque to a RigidFrame or RigidBody.

Syntax 1:  B.AddTorque(       torqueVec )
Syntax 2:  B.AddTorque(   A,  torqueVec )
Syntax 3:  B.ResetTorque(     torqueVec )
Syntax 4:  B.ResetTorque( A,  torqueVec )

   Input:  B, A -- names of a RigidFrame or RigidBody.
           torqueVec -- a torque vector.

Output 1:  Adds  torqueVec  to  Torque_B>    (accumulates torque on B).
Output 2:  Adds  torqueVec  to  Torque_B_A>  (accumulates torque on B from A).
Output 3:  Torque_B>    is reset to  torqueVec.
Output 4:  Torque_B_A>  is reset to  torqueVec.

  Remark:  Syntax 1 is for  "external"  torques applied to B.
           Torque_B> denotes the torque associated with contact/distance forces
           on B that are "external" to any system under consideration
           (and perhaps also external to the NewtonianFrame).
    Note:  B.GetResultantTorque()  accounts for both  Torque_B>  and all
           action/reaction torques on B such as Torque_B_A>, Torque_B_C>, etc.

  Remark:  Syntax 2 is for "action/reaction" torques applied to B from A and is
           frequently used for torque motors, torsional springs/dampers, etc.
    Note:  B.GetResultantTorque(A)  returns  Torque_B_A> - Torque_A_B>.

  Remark:  When sensible, use Syntax 2 instead of Syntax 1 as it efficiently
           accounts for action/reaction torques by knowing whether B and A
           are internal, external, or mixed for the system under consideration.

  Remark:  Alternate ways to apply a torque  vec>  to B include:
           Torque_B>  = vec>      % Resets    Torque_B>  to    vec>
           Torque_B> += vec>      % Adds           vec>  to    Torque_B>
           Torque_B> -= vec>      % Subtracts      vec>  from  Torque_B>
           Torque_B_A>  = vec>    % Resets  Torque_B_A>  to    vec>
           Torque_B_A> += vec>    % Adds           vec>  to    Torque_B_A>
           Torque_B_A> -= vec>    % Subtracts      vec>  from  Torque_B_A>

 Related:  <a href="#AddForce"><b>AddForce</b></a>  <a href="#AddForceDamper"><b>AddForceDamper</b></a>  <a href="#AddForceElectrostatic"><b>AddForceElectrostatic</b></a>  <a href="#AddForceGravity"><b>AddForceGravity</b></a>
           <a href="#AddForceInverseSquare"><b>AddForceInverseSquare</b></a>  <a href="#AddForceLinearActuator"><b>AddForceLinearActuator</b></a>  <a href="#AddForceSpring"><b>AddForceSpring</b></a>
           <a href="#AddTorque"><b>AddTorque</b></a>  <a href="#AddTorqueDamper"><b>AddTorqueDamper</b></a>
           <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>  <a href="#GetResultantTorque"><b>GetResultantTorque</b></a>
           <a href="#GetForceGravityPotentialEnergy"><b>GetForceGravityPotentialEnergy</b></a>  <a href="#GetForceSpringPotentialEnergy"><b>GetForceSpringPotentialEnergy</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: AddTorque  (add torque to a RigidFrame or RigidBody)
   (3) %--------------------------------------------------------------------
   (4) RigidBody  B
   (5) B.AddTorque( Bx> + 2*By> )
-> (6) Torque_B> = Bx> + 2*By>

   (7) B.AddTorque( 3*Bz> )
-> (8) Torque_B> = Bx> + 2*By> + 3*Bz>

   (9) %--------------------------------------------------------------------
   (10) % Example 2: AddTorque (action/reaction with two rigid objects) 
   (11) %--------------------------------------------------------------------
   (12) RigidFrame A
   (13) B.AddTorque( A,  Ax> + 2*Ay> )
-> (14) Torque_B_A> = Ax> + 2*Ay>

   (15) ResultantTorqueOnA> := A.GetResultantTorque()
-> (16) ResultantTorqueOnA> = -Ax> - 2*Ay>

   (17) ResultantTorqueOnB> := B.GetResultantTorque()
-> (18) ResultantTorqueOnB> = Ax> + 2*Ay> + Bx> + 2*By> + 3*Bz>

   (19) %--------------------------------------------------------------------
   (20) % Example: ResetTorque (reset torque on a RigidFrame or RigidBody)
   (21) %--------------------------------------------------------------------
   (22) B.ResetTorque( sin(t)*Bx> )               
-> (23) Torque_B> = sin(t)*Bx>

   (24) B.ResetTorque( A,  cos(t)*Az> )   
-> (25) Torque_B_A> = cos(t)*Az>



</PRE><nobr><a name="AddTorqueDamper"><font color="darkBlue"><font size=+1><b>AddTorqueDamper</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
AddTorqueDamper

 Purpose:  Adds damper torque to a RigidFrame or RigidBody.

Syntax 1:  B.AddTorqueDamper( A, b )
Syntax 2:  B.AddTorqueDamper( A, b, angularRateExponent )

   Input:  B, A -- names of a RigidFrame or RigidBody.
           b -- the damper constant (scalar)
           angularRateExponent -- the exponent on the damper's angular rate

Output 1:  Adds a damper torque on B from A equal to -b * w_B_A>.

Output 2:  Adds a damper torque on B from A whose magnitude is equal to
           b * angularRate^angularRateExponent  where angularRate is the
           magnitude of B's angular velocity in A.  The direction of the
           damper torque is opposite B's angular velocity in A.

 Related:  <a href="#AddForce"><b>AddForce</b></a>  <a href="#AddForceDamper"><b>AddForceDamper</b></a>  <a href="#AddForceElectrostatic"><b>AddForceElectrostatic</b></a>  <a href="#AddForceGravity"><b>AddForceGravity</b></a>
           <a href="#AddForceInverseSquare"><b>AddForceInverseSquare</b></a>  <a href="#AddForceLinearActuator"><b>AddForceLinearActuator</b></a>  <a href="#AddForceSpring"><b>AddForceSpring</b></a>
           <a href="#AddTorque"><b>AddTorque</b></a>  <a href="#AddTorqueDamper"><b>AddTorqueDamper</b></a>
           <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>  <a href="#GetResultantTorque"><b>GetResultantTorque</b></a>
           <a href="#GetForceGravityPotentialEnergy"><b>GetForceGravityPotentialEnergy</b></a>  <a href="#GetForceSpringPotentialEnergy"><b>GetForceSpringPotentialEnergy</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: AddTorqueDamper  
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N
   (5) RigidBody A
   (6) Variable  qA'
   (7) Constant  b    % Damping constant
   (8) A.SetAngularVelocity( N, qA'*Az> )
-> (9) w_A_N> = qA'*Az>

   (10) A.AddTorqueDamper( N, b )
-> (11) Torque_A_N> = -b*qA'*Az>

   (12) %--------------------------------------------------------------------
   (13) % Example 2: AddTorqueDamper  (with angular-rate exponent) 
   (14) %--------------------------------------------------------------------
   (15) RigidBody B
   (16) Variable  qB'
   (17) B.SetAngularVelocity( A, qB'*By> )
-> (18) w_B_A> = qB'*By>

   (19) B.AddTorqueDamper( A, b, 3 )
-> (20) Torque_B_A> = -b*qB'^3*By>

   (21) %--------------------------------------------------------------------
   (22) % Example 3: AddTorqueDamper  (angular-velocity with three components) 
   (23) %--------------------------------------------------------------------
   (24) RigidBody  C
   (25) Variable   wx, wy, wz
   (26) C.SetAngularVelocity( N, wx*Cx> + wy*Cy> + wz*Cz> )
-> (27) w_C_N> = wx*Cx> + wy*Cy> + wz*Cz>

   (28) C.AddTorqueDamper( N, b, 2 )
-> (29) Torque_C_N> = -b*wx*sqrt(wx^2+wy^2+wz^2)*Cx> - b*wy*sqrt(wx^2+wy^2+wz^2)*Cy>
        - b*wz*sqrt(wx^2+wy^2+wz^2)*Cz>



</PRE><nobr><a name="Animate"><font color="darkBlue"><font size=+1><b>Animate</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Animate

 Purpose:  Creates output for objects to be animated by a computer graphic
           visualization program, e.g., MGView (Web) or ANIMAKE (Windows/PC).

Syntax 1:  Animate( N, O,  A,B,C, ... )
Syntax 2:  Animate( N, O )
Syntax 3:  Animate()

   Input:  N -- the name of a RigidFrame or RigidBody
           O -- the name of a Point or Particle
           A,B,C -- names of Point, Particle, RigidFrame, or RigidBody

Output 1:  If  A  is a RigidFrame or RigidBody, calculates rotation matrix N_A,
           position vector p_O_Ao>, and corresponding Output statements.

           If  A  is a Point or Particle, calculates position vector p_O_A> and
           creates corresponding Output statements.

Output 2:  Rotation matrices for all rigid frames/bodies Xi (i=1,2, ...) and
           position vectors from point O to points Xio (i=1,2, ...)
           and corresponding Output statements.

Output 3:  Same as Output 2 where N is the NewtonianFrame and O is
           the NewtonianFrame origin (e.g., No).

 Related:  <a href="#ODE"><b>ODE</b></a>  <a href="#Solve"><b>Solve</b></a>  <a href="#Input"><b>Input</b></a>  <a href="#Output"><b>Output</b></a>  <a href="#Output"><b>OutputPlot</b></a>  <a href="#Plot"><b>Plot</b></a>  <a href="#Animate"><b>Animate</b></a>
           <a href="#ConvertUnits"><b>ConvertUnits</b></a>  <a href="#GetUnitSystem"><b>GetUnitSystem</b></a>  <a href="#SetUnitSystem"><b>SetUnitSystem</b></a>  <a href="#SetDigits"><b>SetDigits</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: Animate  (double pendulum on a cart)
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N             
   (5) Particle       A        % Cart
   (6) RigidBody      B, C     % Two pendulums
   (7) Point          BC       % Pin-joint Point connecting B and C
   (8) Variable       xA'      % Differential equation governs xA
   (9) %--------------------------------
   (10) %   Rotational kinematics
   (11) B.SetRotationMatrixZ( N, t )
-> (12) B_N = [cos(t), sin(t), 0;  -sin(t), cos(t), 0;  0, 0, 1]

   (13) C.SetRotationMatrixZ( B, 2*t )
-> (14) C_B = [cos(2*t), sin(2*t), 0;  -sin(2*t), cos(2*t), 0;  0, 0, 1]

   (15) %--------------------------------
   (16) %   Translational kinematics
   (17) xA' = exp(sin(t));      % Actuator connects A to No
-> (18) xA' = exp(sin(t))

   (19) A.SetPosition( No, xA*Nx> )
-> (20) p_No_A> = xA*Nx>

   (21) Bo.SetPosition( A, -0.5*By> )
-> (22) p_A_Bo> = -0.5*By>

   (23) BC.SetPosition( A, -By> )
-> (24) p_A_BC> = -By>

   (25) Co.SetPosition( BC, -0.5*Cy> )
-> (26) p_BC_Co> = -0.5*Cy>

   (27) %--------------------------------
   (28) Animate( N, No, A,B,C )
-> (29) p_No_A = [xA;  0;  0]
-> (30) p_No_Bo = [0.5*sin(t) + xA;  -0.5*cos(t);  0]
-> (31) p_No_Co = [sin(t) + 0.5*sin(3*t) + xA;  -cos(t) - 0.5*cos(3*t);  0]
-> (32) N_C = [cos(3*t), -sin(3*t), 0;  sin(3*t), cos(3*t), 0;  0, 0, 1]

   (33) Input xA = 0.234, tFinal=0.2
   (34) ODE() DoublePendulumOnCart

   (35) %--------------------------------
   (36) %   In response to the ODE command, Output is listed on screen:
   (37) %   Note: Units of GetLengthUnit may be associated with P_No_A[i], ...
   (38) %
   (39) %Output 1: t, P_No_A[1],  P_No_A[2],  P_No_A[3]  
   (40) %Output 2: t, P_No_Bo[1], P_No_Bo[2], P_No_Bo[3],
   (41) %          N_B[1,1] NoUnits, N_B[1,2] NoUnits, N_B[1,3] NoUnits,
   (42) %          N_B[2,1] NoUnits, N_B[2,2] NoUnits, N_B[2,3] NoUnits,
   (43) %          N_B[3,1] NoUnits, N_B[3,2] NoUnits, N_B[3,3] NoUnits
   (44) %Output 3: t, P_No_Co[1], P_No_Co[2], P_No_Co[3],
   (45) %          N_C[1,1] NoUnits, N_C[1,2] NoUnits, N_C[1,3] NoUnits,
   (46) %          N_C[2,1] NoUnits, N_C[2,2] NoUnits, N_C[2,3] NoUnits,
   (47) %          N_C[3,1] NoUnits, N_C[3,2] NoUnits, N_C[3,3] NoUnits


</PRE><nobr><a name="ceil"><font color="darkBlue"><font size=+1><b>ceil</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
ceil   floor

 Purpose:  Returns the ceiling or floor of a real scalar expression.

Syntax 1:  ceil( realScalarExpression )
Syntax 2:  floor( realScalarExpression )

   Input:  realScalarExpression -- a real scalar expression.

Output 1:  Ceiling of realScalarExpression, i.e., the smallest
           integer greater than or equal to realScalarExpresion.

Output 2:  Floor of realScalarExpression, i.e., the largest
           integer less than or equal to realScalarExpresion.

  Remark:  The sign function can combine with ceil or floor for if statements:
           isPositive      = ceil(  sign(t)/2 )              % Returns 0 or  1.
           isPositiveOr0   = ceil(  sign(t)/2 + 0.1 )        % Returns 0 or  1.
           isNegative      = floor( sign(t)/2 )              % Returns 0 or -1.
           isTGreaterThan5 = ceil( sign(t-5) / 2 )           % Returns 0 or  1.
           isTLessThan9    = ceil( sign(9-t) / 2 )           % Returns 0 or  1.
           isTBetween5And9 = isTGreaterThan5 * isTLessThan9  % Returns 0 or  1.

 Related:  <a href="#ceil"><b>ceil</b></a>  <a href="#ceil"><b>floor</b></a>  <a href="#int"><b>int</b></a>  <a href="#min"><b>max</b></a>  <a href="#min"><b>min</b></a>  <a href="#round"><b>round</b></a>  <a href="#RoundDigits"><b>RoundDigits</b></a>  <a href="#sign"><b>sign</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>
           <a href="#IsPositive"><b>IsNegative</b></a>  <a href="#IsPositive"><b>IsNegativeOr0</b></a>  <a href="#IsPositive"><b>IsPositiveOr0</b></a>  <a href="#IsPositive"><b>IsPositive</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: ceil 
   (3) %--------------------------------------------------------------------
   (4) A = ceil(  2.9999 ) 
-> (5) A = 3

   (6) B = ceil(  3.0001 ) 
-> (7) B = 4

   (8) C = ceil( -2.9999 ) 
-> (9) C = -2

   (10) D = ceil( -3.0001 ) 
-> (11) D = -3

   (12) E = ceil( 2.9 + t ) 
-> (13) E = ceil(2.9+t)

   (14) isPositiveA = Evaluate( ceil( sign(t)/2 ),  t =  200   )
-> (15) isPositiveA = 1

   (16) isPositiveB = Evaluate( ceil( sign(t)/2 ),  t = -200   )
-> (17) isPositiveB = 0

   (18) isPositiveC = Evaluate( ceil( sign(t)/2 ),  t =  0     )
-> (19) isPositiveC = 0

   (20) isPositiveD = Evaluate( ceil( sign(t)/2 ),  t =  1E-21 )
-> (21) isPositiveD = 1

   (22) isPositiveE = Evaluate( ceil( sign(t)/2 ),  t = -1E-21 )
-> (23) isPositiveE = 0

   (24) isNonNegativeA = Evaluate( ceil( sign(t)/2 + 1E-200 ),  t =  0     )
-> (25) isNonNegativeA = 1

   (26) isNonNegativeB = Evaluate( ceil( sign(t)/2 + 1E-200 ),  t =  1E-21 )
-> (27) isNonNegativeB = 1

   (28) isNonNegativeC = Evaluate( ceil( sign(t)/2 + 1E-200 ),  t = -1E-21 )
-> (29) isNonNegativeC = 0

   (30) %--------------------------------------------------------------------
   (31) % Example: floor 
   (32) %--------------------------------------------------------------------
   (33) F = floor(  2.9999 ) 
-> (34) F = 2

   (35) G = floor(  3.0001 ) 
-> (36) G = 3

   (37) H = floor( -2.9999 ) 
-> (38) H = -3

   (39) I = floor( -3.0001 ) 
-> (40) I = -4

   (41) J = floor( 2.9 + t ) 
-> (42) J = floor(2.9+t)

   (43) isNegativeA = Evaluate( floor( sign(t)/2 ),  t =  200   )
-> (44) isNegativeA = 0

   (45) isNegativeB = Evaluate( floor( sign(t)/2 ),  t = -200   )
-> (46) isNegativeB = -1

   (47) isNegativeC = Evaluate( floor( sign(t)/2 ),  t =  0     )
-> (48) isNegativeC = 0

   (49) isNegativeD = Evaluate( floor( sign(t)/2 ),  t =  1E-21 )
-> (50) isNegativeD = 0

   (51) isNegativeE = Evaluate( floor( sign(t)/2 ),  t = -1E-21 )
-> (52) isNegativeE = -1

   (53) isNonPositiveA = Evaluate( floor( sign(t)/2 - 1E-200 ),  t =  0     )
-> (54) isNonPositiveA = -1

   (55) isNonPositiveB = Evaluate( floor( sign(t)/2 - 1E-200 ),  t =  1E-21 )
-> (56) isNonPositiveB = 0

   (57) isNonPositiveC = Evaluate( floor( sign(t)/2 - 1E-200 ),  t = -1E-21 )
-> (58) isNonPositiveC = -1

   (59) %--------------------------------------------------------------------
   (60) % Example: Combine the sign function with ceil or floor for if statements.
   (61) %--------------------------------------------------------------------
   (62) isTLessThan9 = ceil( sign(9-t) / 2 )
-> (63) isTLessThan9 = ceil(0.5*sign(9-t))

   (64) isTGreaterThan5 = ceil( sign(t-5) / 2 )  
-> (65) isTGreaterThan5 = ceil(0.5*sign(-5+t))

   (66) isTBetween5And9 = isTGreaterThan5 * isTLessThan9 
-> (67) isTBetween5And9 = isTGreaterThan5*isTLessThan9

   (68) forceA = isTLessThan9    * 88    % if t < 9, forceA = 88 else forceA = 0.
-> (69) forceA = 88*isTLessThan9

   (70) forceB = isTGreaterThan5 * 77    % if t > 5, forceB = 77 else forceB = 0.
-> (71) forceB = 77*isTGreaterThan5

   (72) forceC = isTBetween5And9 * 66    % if 5 < t < 9, forceC = 66 else forceC = 0.
-> (73) forceC = 66*isTBetween5And9



</PRE><nobr><a name="Clear"><font color="darkBlue"><font size=+1><b>Clear</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Clear

 Purpose:  Clears the workspace by restarting the program.
           Re-runs designated lines from the workspace.

Syntax 1:  Clear
Syntax 2:  Clear lineNumber

   Input:  lineNumber -- designates the first line number to be
           deleted after the program restarts.  lineNumber must
           be smaller than the current line number.

Output 1:  Clears the workspace and restarts the program.

Output 2:  Restarts the program and re-executes all input lines
           preceding line lineNumber.

  Remark:  The CLEAR command may not be available on all computers.

 Related:  <a href="#!"><b>!</b></a>  <a href="#%"><b>%</b></a>  <a href="#&"><b>&</b></a>  <a href="#Clear"><b>Clear</b></a>  <a href="#List"><b>List</b></a>  <a href="#Pause"><b>Pause</b></a>  <a href="#Quit"><b>Quit</b></a>  <a href="#Run"><b>Run</b></a>  <a href="#Save"><b>Save</b></a>  <a href="#GetDefaults"><b>GetDefaults</b></a>
           <a href="#Input"><b>ClearInput</b></a>  <a href="#Output"><b>ClearOutput</b></a>  <a href="#Output"><b>ClearOutputPlot</b></a>  <a href="#Output"><b>ClearOutputEncode</b></a>

--------------------------------------------------------------------
 Example:  Clear
--------------------------------------------------------------------
   (1) a = 2
-> (2) a = 2

   (3) b = 3
-> (4) b = 3

   (5) Clear



</PRE><nobr><a name="Constant"><font color="darkBlue"><font size=+1><b>Constant</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Constant  or  ConstantEncode

 Purpose:  Declares the names of constants.

Syntax 1:  Constant        a,  b,  c+,  d-
Syntax 2:  Constant        g = 9.8 m/s^2
Syntax 3:  Constant        I = m*L^2
Syntax 4:  ConstantEncode  switchLogic = 1 noUnits
Syntax 5:  Constant()

   Input:  a -- name that starts with a letter, followed by a reasonable
                number of alphanumeric characters (similarly for b, c, d).
           a, b  are regarded as REAL constants unless SetComplex is ON.
           c+    declares c as a real non-negative constant so  abs(c) =  c.
           d-    declares d as a real non-positive constant so  abs(d) = -d.

Output 2:  g = 9.8  m/s^2  -- declares g as a constant with INPUT 9.8 m/s^2.
Output 3:  I = m*L^2       -- declares I as a constant assigned to m*L^2.
                        (m*L^2 should be a number or a constant expression).

Output 4:  ConstantEncode forces MATLAB(R), C, and Fortran programs to include
           quantities that may not otherwise appear due to code-optimization.

Output 5:  Creates an array of all names declared as Constant.

   (1) %--------------------------------------------------------------------
   (2) % Example: Constant
   (3) %--------------------------------------------------------------------
   (4) Constant a, b, c+, d-
   (5) Constant e{0:3}           % Declares e0, e1, e2, e3
   (6) Constant f{1:2, 1:3}      % Declares f11, f12, f13, f21, f22, f23
   (7) Constant g = 9.8  m/s^2   % Same as  Constant g;  Input g = 9.8 m/s^2
   (8) Constant h = 5 noUnits    % Same as  Constant h;  Input h = 5 noUnits
   (9) Constant k = a * b * abs(c) * abs(d)
-> (10) k = -a*b*c*d

   (11) RigidBody  B
   (12) B.SetMass( m = 20 kg )    % Same as  B.SetMass(m);  Input m = 20 kg
   (13) B.SetInertia( Bcm,  Ixx, Iyy = 3 kg*m^2,  Izz = Ixx + Iyy )
-> (14) Izz = Ixx + Iyy

   (15) arrayOfConstants = Constant()
-> (16) arrayOfConstants = [a;  b;  c;  d;  e0;  e1;  e2;  e3;  f11;  f12;  f13;  
        f21;  f22;  f23;  g;  h;  Ixx;  Iyy;  Izz;  k;  m]



</PRE><nobr><a name="ConvertUnits"><font color="darkBlue"><font size=+1><b>ConvertUnits</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
ConvertUnits

 Purpose:  Calculates units conversion factors.

Syntax 1:  ConvertUnits(   Units1, Units2 )
           ConvertUnits( s Units1, Units2 )
Syntax 2:  ConvertUnits(   Units1, GetUnitSystem )
           ConvertUnits( s Units1, GetUnitSystem )
Syntax 3:  ConvertUnits(   GetUnitSystem, Units2 )
           ConvertUnits( s GetUnitSystem, Units2 )

   Input:  Units1, Units2 -- expressions consisting of names of units
                             together with the operators *, /, and ^

           s -- a scalar expression, e.g., a number, constant, variable, etc.

Output 1:  Conversion factor from Units1 to Units2 or
           s * ConvertUnits( Units1 * Units2)

Output 2:  Conversion factor from Units1 to the units of SetUnitSystem or
           s * ConvertUnits( Units1 * GetUnitSystem )

Output 3:  Conversion factor from the units of SetUnitSystem to Units2 or
           s * ConvertUnits( GetUnitSystem, Units2 )

  Remark:  Units expressions may include the following names:
           GetMassUnit, GetLengthUnit, GetTimeUnit, GetAngleUnit,
           which stand for, respectively, the current name assigned by
           SetUnitSystem to the units of mass, length, and time, and
           "radian" (which is always associated with GetAngleUnit).

 Related:  <a href="#ODE"><b>ODE</b></a>  <a href="#Solve"><b>Solve</b></a>  <a href="#Input"><b>Input</b></a>  <a href="#Output"><b>Output</b></a>  <a href="#Output"><b>OutputPlot</b></a>  <a href="#Plot"><b>Plot</b></a>  <a href="#Animate"><b>Animate</b></a>
           <a href="#ConvertUnits"><b>ConvertUnits</b></a>  <a href="#GetUnitSystem"><b>GetUnitSystem</b></a>  <a href="#SetUnitSystem"><b>SetUnitSystem</b></a>
           <a href="#GetMassUnit"><b>GetMassUnit</b></a>   <a href="#GetMassUnit"><b>GetLengthUnit</b></a>  <a href="#GetMassUnit"><b>GetTimeUnit</b></a>  <a href="#GetMassUnit"><b>GetAngleUnit</b></a>
           Constant,     SetMass,       <a href="#SetInertia"><b>SetInertia</b></a>

   (1) %--------------------------------------------------------------------
   (2) %Example: ConvertUnits 
   (3) %--------------------------------------------------------------------
   (4) inchToCentimeter = ConvertUnits( inch, cm )
-> (5) inchToCentimeter = 2.54

   (6) ounceMassToMilligram = ConvertUnits( ozm, mg )
-> (7) ounceMassToMilligram = 28349.52

   (8) poundForceToNewton = ConvertUnits( lbf, Newton )
-> (9) poundForceToNewton = 4.448222

   (10) sevenMPHToMeterPerSecond =  7 * ConvertUnits( MPH,  m/sec )
-> (11) sevenMPHToMeterPerSecond = 3.12928

   (12) sixtyMPHToMeterPerSecond = ConvertUnits( (30+30) MPH,  m/sec )
-> (13) sixtyMPHToMeterPerSecond = 26.8224

   (14) tMinuteToSecond = ConvertUnits( t minutes,  seconds )
-> (15) tMinuteToSecond = 60*t



</PRE><nobr><a name="Convolve"><font color="darkBlue"><font size=+1><b>Convolve</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Convolve

 Purpose:  Convolves two one-dimensional matrices

  Syntax:  Convolve( M, N )

   Input:  M -- one-dimensional matrix having m elements.
           N -- one-dimensional matrix having n element.

  Output:  One-dimensional matrix of m + n - 1 elements,  whose ith-element
           is the sum of the products of the jth element of M and the kth
           element of N such that j + k - 1 = i

  Remark:  If M and N are expressions (not matrices) returns the
           the product of M and N, i.e., returns M*N.

   (1) %--------------------------------------------------------------------
   (2) % Example: Convolve
   (3) %--------------------------------------------------------------------
   (4) Constant  m1,m2,m3, n1,n2
   (5) y = Convolve( [m1,m2,m3], [n1,n2] )
-> (6) y = [m1*n1, m1*n2 + m2*n1, m2*n2 + m3*n1, m3*n2]



</PRE><nobr><a name="cos"><font color="darkBlue"><font size=+1><b>cos</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
cos

 Purpose:  Returns the cosine of a scalar expression.

Syntax 1:  cos( scalarExpressionRad )
Syntax 2:  cosDegrees( realNumberDeg )

   Input:  scalarExpressionRad -- the radian measure of a real or
                                  complex scalar expression.
           realNumberDeg -- expression that resolves to a real number.

Output 1:  Cosine of scalarExpressionRad.
Output 2:  Cosine of realNumberDeg.

 Related:  <a href="#ConvertUnits"><b>ConvertUnits</b></a>  <a href="#ImaginaryNumber"><b>ImaginaryNumber</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>
           <a href="#cos"><b>cos</b></a>  <a href="#sin"><b>sin</b></a>  <a href="#tan"><b>tan</b></a>  <a href="#acos"><b>acos</b></a>  <a href="#asin"><b>asin</b></a>  <a href="#atan"><b>atan</b></a>  <a href="#atan2"><b>atan2</b></a>  <a href="#cos"><b>cosDegrees</b></a>  ...

   (1) %--------------------------------------------------------------------
   (2) % Example 1: cos   (real scalar expressions)
   (3) %--------------------------------------------------------------------
   (4) A = cos( pi/3 ) 
-> (5) A = 0.5

   (6) B = cosDegrees( 60 ) 
-> (7) B = 0.5

   (8) C = cos(t) + cos( t * ConvertUnits(deg,rad) )
-> (9) C = cos(t) + cos(0.01745329*t)

   (10) D = cos(0.5+2*t)
-> (11) D = sin(2.070796+2*t)

   (12) %--------------------------------------------------------------------
   (13) % Example 2: cos   (complex scalar expressions)
   (14) %--------------------------------------------------------------------
   (15) E = cos( 2 + 3*GetImaginaryNumber() )
-> (16) E = -4.189626 - 9.109228*imaginary

   (17) F = cos( 3*GetImaginaryNumber() + t )
-> (18) F = cos(3*imaginary+t)



</PRE><nobr><a name="cosh"><font color="darkBlue"><font size=+1><b>cosh</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
cosh,  sinh,  tanh

 Purpose:  Returns the hyperbolic cosine, sine, or tangent.

Syntax 1:  cosh( scalarExpression )
Syntax 2:  sinh( scalarExpression )
Syntax 3:  tanh( scalarExpression )

   Input:  scalarExpression -- a real or complex scalar expression.

Output 1:  Hyperbolic cosine  of scalarExpression.
Output 2:  Hyperbolic sine    of scalarExpression.
Output 3:  Hyperbolic tangent of scalarExpression.

 Remark:   cosh(x) = ( exp(x) + exp(-x) ) / 2
           sinh(x) = ( exp(x) - exp(-x) ) / 2
           tanh(x) = sinh(x) / cosh(x)
           cosh(x)^2 - sinh(x)^2 = 1
           D( cosh(x), x ) = sinh(x)
           D( sinh(x), x ) = cosh(x)
           D( tanh(x), x ) = 1 - tanh(x)^2 = 1 / cosh(x)^2

 Related:  <a href="#ImaginaryNumber"><b>ImaginaryNumber</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>
           <a href="#cos"><b>cos</b></a>  <a href="#sin"><b>sin</b></a>  <a href="#tan"><b>tan</b></a>  <a href="#acos"><b>acos</b></a>  <a href="#asin"><b>asin</b></a>  <a href="#atan"><b>atan</b></a>  <a href="#atan2"><b>atan2</b></a>  <a href="#cos"><b>cosDegrees</b></a>  ...

   (1) %--------------------------------------------------------------------
   (2) % Example 1: cosh, sinh, tanh   (real scalar expressions)
   (3) %--------------------------------------------------------------------
   (4) A = sinh(2) + cosh(3) + tanh(4)
-> (5) A = 14.69385

   (6) B = sinh(1+2*t) + cosh(3+4*t) + tanh(5+6*t)
-> (7) B = sinh(1+2*t) + cosh(3+4*t) + tanh(5+6*t)

   (8) %--------------------------------------------------------------------
   (9) % Example 2: cosh, sinh, tanh   (complex scalar expressions)
   (10) %--------------------------------------------------------------------
   (11) C = cosh( 2 + 3*GetImaginaryNumber() ) 
-> (12) C = -3.724546 + 0.5118226*imaginary

   (13) D = sinh( 2 + 3*GetImaginaryNumber() )
-> (14) D = -3.590565 + 0.5309211*imaginary

   (15) E = tanh( 2 + 3*GetImaginaryNumber() )
-> (16) E = 0.9653859 - 0.009884375*imaginary

   (17) F = sinh(3*imaginary+t) + cosh(3*imaginary+t)
-> (18) F = sinh(3*imaginary+t) + cosh(3*imaginary+t)



</PRE><nobr><a name="CROSS"><font color="darkBlue"><font size=+1><b>CROSS</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Cross   or    Dot

 Purpose:  Forms the cross-product or dot-product for vectors, dyadics, etc.

Syntax 1:  Cross( vA, vB )
Syntax 2:    Dot( vA, vB )

   Input:  vA -- a vector, dyadic, triadic, or a matrix of these.
           vB -- a vector, dyadic, triadic, or a matrix of these.

Output 1:  Cross-product of vA and vB.
Output 2:    Dot-product of vA and vB.

  Remark:  When vA and vB are matrices, perform operations in the order defined
           by matrix multiplication. For the 2x3 matrix vA and 3x5 matrix vB,
           Cross( vA, vB )  returns a 2x5 matrix (similarly for Dot).

 Related:  <a href="#GetMagnitude"><b>GetMagnitude</b></a>           <a href="#GetMagnitude"><b>GetMagnitudeSquared</b></a>
           <a href="#GetDistance"><b>GetDistance</b></a>            <a href="#GetDistance"><b>GetDistanceSquared</b></a>
           <a href="#GetSpeed"><b>GetSpeed</b></a>               <a href="#GetSpeed"><b>GetSpeedSquared</b></a>
           <a href="#GetAngularSpeed"><b>GetAngularSpeed</b></a>        <a href="#GetAngularSpeed"><b>GetAngularSpeedSquared</b></a>      <a href="#ConvertUnits"><b>ConvertUnits</b></a>
           <a href="#GetAngleBetweenVectors"><b>GetAngleBetweenVectors</b></a> <a href="#GetAngleBetweenVectors"><b>GetAngleBetweenUnitVectors</b></a>  <a href="#Rotate"><b>Rotate</b></a>
           <a href="#GetUnitVector"><b>GetUnitVector</b></a>          <a href="#Vector"><b>Vector</b></a>  <a href="#Dyadic"><b>Dyadic</b></a>  <a href="#Matrix"><b>Matrix</b></a>      <a href="#Cross"><b>Cross</b></a>  <a href="#Cross"><b>Dot</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: Cross( vector, vector )     Dot( vector, vector )
   (3) %--------------------------------------------------------------------
   (4) RigidFrame A
   (5) Constant   x, y, z
   (6) v> = x*Ax> + y*Ay> + z*Az>
-> (7) v> = x*Ax> + y*Ay> + z*Az>

   (8) w> =   Ax> + 2*Ay> + 3*Az>
-> (9) w> = Ax> + 2*Ay> + 3*Az>

   (10) vCrossw> = Cross( v>, w> )
-> (11) vCrossw> = (3*y-2*z)*Ax> + (z-3*x)*Ay> + (2*x-y)*Az>

   (12) vDotw = Dot( v>,  w> )
-> (13) vDotw = x + 2*y + 3*z

   (14) %--------------------------------------------------------------------
   (15) % Example 2: Cross( vector, dyadic )     Dot(  vector, dyadic )
   (16) %--------------------------------------------------------------------
   (17) d>> = Ay>*Ax> - 2*Az>*Az>
-> (18) d>> = Ay>*Ax> - 2*Az>*Az>

   (19) dCrossv>> = Cross( d>>, v> )
-> (20) dCrossv>> = -z*Ay>*Ay> + y*Ay>*Az> + 2*y*Az>*Ax> - 2*x*Az>*Ay>

   (21) dDotv> = Dot( d>>, v> )
-> (22) dDotv> = x*Ay> - 2*z*Az>

   (23) %--------------------------------------------------------------------
   (24) % Example 3: Cross( vector, matrixOfVectors )  Dot( vector, matrixOfVectors )
   (25) %--------------------------------------------------------------------
   (26) vCrossMatrix = Cross( v>,  [w>; t*Ax> + sin(t)*Ay>] )
-> (27) vCrossMatrix[1] = (3*y-2*z)*Ax> + (z-3*x)*Ay> + (2*x-y)*Az>
-> (28) vCrossMatrix[2] = -z*sin(t)*Ax> + z*t*Ay> + (x*sin(t)-y*t)*Az>

   (29) vDotMatrix   =   Dot( v>,  [w>; t*Ax> + sin(t)*Ay>] )
-> (30) vDotMatrix = [x + 2*y + 3*z;  x*t + y*sin(t)]

   (31) %--------------------------------------------------------------------
   (32) % Example 4: Cross( matrixOfVectors, vector )  Dot( matrixOfVectors, vector )
   (33) %--------------------------------------------------------------------
   (34) matrixCrossV = Cross( [w>; t*Ax> + sin(t)*Ay>],  v> )
-> (35) matrixCrossV[1] = (2*z-3*y)*Ax> + (3*x-z)*Ay> + (y-2*x)*Az>
-> (36) matrixCrossV[2] = z*sin(t)*Ax> - z*t*Ay> + (y*t-x*sin(t))*Az>

   (37) matrixDotV   =   Dot( [w>; t*Ax> + sin(t)*Ay>],  v> )
-> (38) matrixDotV = [x + 2*y + 3*z;  x*t + y*sin(t)]

   (39) %--------------------------------------------------------------------
   (40) % Example 5: Cross( MatrixOfVectors, MixedMatrixWithDyadicAndVector )
   (41) %--------------------------------------------------------------------
   (42) MCrossN = Cross( [Ax>; Ay>],  [Ax>, Ay>*Az>] )
-> (43) MCrossN = [0>, Az>*Az>;  -Az>, 0>>]

   (44) MDotN   =   Dot( [Ax>; Ay>],  [Ax>, Ay>*Az>] )
-> (45) MDotN = [1, 0>;  0, Az>]



</PRE><nobr><a name="Dt"><font color="darkBlue"><font size=+1><b>Dt</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Dt

 Purpose:  Forms the ordinary derivative of a scalar, vector, dyadic, etc., or
           matrix of scalars, vectors, etc., (possibly in a reference frame).

Syntax 1:  Dt(     scalarOrMatrixExpression )
Syntax 2:  Dt(     vectorOrMatrixExpression,  refFrame )
Syntax 3:  DtDt(   scalarOrMatrixExpression )
Syntax 4:  DtDt(   vectorOrMatrixExpression,  refFrame )
Syntax 5:  DtDtDt( scalarOrMatrixExpression )
Syntax 6:  DtDtDt( vectorOrMatrixExpression,  refFrame )

   Input:  scalarOrMatrixExpression -- a scalar expression or
                                       matrix of scalar expressions.
           tensorOrMatrixExpression -- a scalar, vector, dyadic, etc., or
                                       matrix of such expressions.
           refFrame -- a reference frame (e.g., RigidFrame or RigidBody)

Output 1:  1st-ordinary derivative of scalarOrMatrixExpression.
Output 2:  1st-ordinary derivative of tensorOrMatrixExpression in refFrame.
Output 3:  2nd-ordinary derivative of scalarOrMatrixExpression.
Output 4:  2nd-ordinary derivative of tensorOrMatrixExpression in refFrame.
Output 5:  3rd-ordinary derivative of scalarOrMatrixExpression.
Output 6:  3rd-ordinary derivative of tensorOrMatrixExpression in refFrame.

  Remark:  The prime symbol ' denotes implicit ordinary differentiation with
           respect to the independent variable (which is t by default).
           For example, x' denotes dx/dt (e.g., ordinary time-derivative of x).

  Remark:  DtDt is preferable to DDt.  DtDtDt is preferable to DDDt.

 Related:  <a href="#D"><b>D</b></a>  <a href="#Dt"><b>Dt</b></a>  <a href="#Dt"><b>DtDt</b></a>  <a href="#Dt"><b>DtDtDt</b></a>  <a href="#Integrate"><b>Integrate</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>
           <a href="#SetDt"><b>SetDt</b></a>  <a href="#Solve"><b>Solve</b></a>  <a href="#SolveDt"><b>SolveDt</b></a>  <a href="#SolveSetInput"><b>SolveSetInput</b></a>  <a href="#SolveSetInputDt"><b>SolveSetInputDt</b></a>  ...
           <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRoot</b></a>  <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRootDt</b></a>  ...

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  Dt( scalarExpression, name )
   (3) %--------------------------------------------------------------------
   (4) s = sin(t)
-> (5) s = sin(t)

   (6) s1stDerivative = Dt( s )
-> (7) s1stDerivative = cos(t)

   (8) s2ndDerivative = DtDt( s )
-> (9) s2ndDerivative = -sin(t)

   (10) s3rdDerivative = DtDtDt( s )
-> (11) s3rdDerivative = -cos(t)

   (12) %--------------------------------------------------------------------
   (13) % Example 2:  Dt( matrixExpression, name )
   (14) %--------------------------------------------------------------------
   (15) Variable  x'', y''
   (16) m = [1, 2*t;  3*x, 4*y^2]
-> (17) m = [1, 2*t;  3*x, 4*y^2]

   (18) m1stDerivative = Dt( m )
-> (19) m1stDerivative = [0, 2;  3*x', 8*y*y']

   (20) m2ndDerivative = DtDt( m )
-> (21) m2ndDerivative = [0, 0;  3*x'', 8*y'^2 + 8*y*y'']

   (22) %--------------------------------------------------------------------
   (23) % Example 3:  Dt( vectorExpression, refFrame )
   (24) %--------------------------------------------------------------------
   (25) RigidFrame A
   (26) v> = Vector( A, 3*x, y^2, 0 )
-> (27) v> = 3*x*Ax> + y^2*Ay>

   (28) v1stDerivativeInA> = Dt( v>, A )
-> (29) v1stDerivativeInA> = 3*x'*Ax> + 2*y*y'*Ay>

   (30) v2ndDerivativeInA> = DtDt( v>, A )
-> (31) v2ndDerivativeInA> = 3*x''*Ax> + (2*y'^2+2*y*y'')*Ay>

   (32) %--------------------------------------------------------------------
   (33) % Example 4:  Dt( tensorExpression, refFrame )
   (34) %--------------------------------------------------------------------
   (35) DtOfTensorInA = Dt( [s, v>], A )
-> (36) DtOfTensorInA = [cos(t), 3*x'*Ax> + 2*y*y'*Ay>]



</PRE><nobr><a name="D"><font color="darkBlue"><font size=+1><b>D</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
D

 Purpose:  Forms the partial derivative of a scalar expression (or matrix of
           scalar expressions) with respect to X (a scalar name or matrix of
           scalar names).  Forms partial derivatives of vectors or dyadics (or
           matrix of such expressions) with respect to X in a reference frame.

Syntax 1:  D( scalarOrMatrixOfScalars, X )
Syntax 2:  D( tensorOrMatrixOfTensors, X, refFrame )

   Input:  scalarOrMatrixOfScalars -- a scalar or matrix of scalar expressions
           tensorOrMatrixOfTensors -- a scalar, vector, or dyadic expression
                                      or a matrix of such expressions.
           X -- the name of a scalar or matrix of these -- e.g., a variable.
           refFrame -- a reference frame (e.g., a RigidFrame or RigidBody).

 Output 1: Partial derivative of scalarOrMatrixOfScalars with respect to X.
 Output 2: Partial derivative of tensorOrMatrixOfTensors with respect to X in
           refFrame.

 Related:  <a href="#D"><b>D</b></a>  <a href="#Dt"><b>Dt</b></a>  <a href="#Dt"><b>DtDt</b></a>  <a href="#Integrate"><b>Integrate</b></a>  <a href="#GetPartialVelocity"><b>GetPartials</b></a>  <a href="#GetJacobian"><b>GetJacobian</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  D( scalarExpression, name )
   (3) %--------------------------------------------------------------------
   (4) Variable x, y
   (5) s = sin(t) + 3*x + y^2 
-> (6) s = sin(t) + 3*x + y^2

   (7) DsDx = D( s, x )
-> (8) DsDx = 3

   (9) DsDt = D( s, t )
-> (10) DsDt = cos(t)

   (11) y = exp(t)
-> (12) y = exp(t)

   (13) DsDt := D( s, t )
-> (14) DsDt = cos(t) + 2*exp(t)*y

   (15) %--------------------------------------------------------------------
   (16) % Example 2:  D( matrixExpression, name )
   (17) %--------------------------------------------------------------------
   (18) matrix = [1, 2*t;  3*x, 4*y^2;  x*y, t^3]
-> (19) matrix = [1, 2*t;  3*x, 4*y^2;  x*y, t^3]

   (20) DmDx = D( matrix, x )
-> (21) DmDx = [0, 0;  3, 0;  y, 0]

   (22) DmDt = D( matrix, t )
-> (23) DmDt = [0, 2;  0, 8*exp(t)*y;  exp(t)*x, 3*t^2]

   (24) %--------------------------------------------------------------------
   (25) % Example 3:  D( scalarExpression, matrixOfNames )
   (26) %--------------------------------------------------------------------
   (27) DsDxyt = D( s,  [x, y, t] )
-> (28) DsDxyt = [3, 2*y, cos(t) + 2*exp(t)*y]

   (29) %--------------------------------------------------------------------
   (30) % Example 4:  D( matrixExpression, matrixOfNames )
   (31) %--------------------------------------------------------------------
   (32) DmDxyt = D( matrix, [x; y] )
-> (33) DmDxyt = [0;  3 + 8*y;  y]

   (34) %--------------------------------------------------------------------
   (35) % Example 5:  D( vectorExpression, name, refFrame )
   (36) %--------------------------------------------------------------------
   (37) RigidFrame A
   (38) v> = Vector( A, 3*x, y^2, 0 )
-> (39) v> = 3*x*Ax> + y^2*Ay>

   (40) DvDy_inA> = D( v>,  y,  A )
-> (41) DvDy_inA> = 2*y*Ay>



</PRE><nobr><a name="GetJacobian"><font color="darkBlue"><font size=+1><b>GetJacobian</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetJacobian   GetVelocityJacobian   GetAngularVelocityJacobian

 Purpose:  Forms a Jacobian whose elements are partial derivatives, e.g.,
           partial derivatives of velocity with respect to generalized speeds.

Syntax 1:  GetJacobian( scalarTensorMatrix1D, X )
Syntax 2:  GetJacobian( scalarTensorMatrix1D, X, refFrame )
Syntax 3:  Q.GetVelocityJacobian(         refFrame )
           B.GetAngularVelocityJacobian(  refFrame )
Syntax 4:  Q.GetVelocityJacobian(         refFrame, X )
           B.GetAngularVelocityJacobian(  refFrame, X )

   Input:  scalarTensorMatrix1D -- a scalar, vector, or dyadic expression or a
                               1D (one-dimensional) matrix of such expressions.
           X -- the name of a scalar or 1D matrix of these -- e.g., a variable.
           refFrame -- a reference frame (e.g., a RigidFrame or RigidBody).
           Q -- the name of a Point.
           B -- the name of a RigidFrame or RigidBody.

Output 1:  n x m matrix of partial derivatives of the scalar portions of
           scalarTensorMatrix1D with respect to X.
           Herein: n = dimension of scalarTensorMatrix1D,  m = dimension of X.

Output 2:  n x m matrix of partial derivatives of scalarTensorMatrix1D
           with respect to X in refFrame.

Output 3:  1 x m matrix of partial derivatives of Q's velocity in refFrame with
           respect to the m scalars named in the command SetGeneralizedSpeed.
           Similarly for B's angular velocity in refFrame.

Output 4:  1 x m matrix of partial derivatives of the scalar portions of
           Q's velocity in refFrame with respect to X.
           Similarly for B's angular velocity in refFrame.

 Related:  <a href="#GetVelocity"><b>GetVelocity</b></a>           <a href="#GetVelocity"><b>GetRelativeVelocity</b></a>
           <a href="#GetPartialVelocity"><b>GetPartialVelocity</b></a>    <a href="#GetPartialVelocity"><b>GetPartialAngularVelocity</b></a>
           <a href="#GetVelocityRemainder"><b>GetVelocityRemainder</b></a>  <a href="#GetVelocityRemainder"><b>GetAngularVelocityRemainder</b></a>
           <a href="#GetJacobian"><b>GetVelocityJacobian</b></a>   <a href="#GetJacobian"><b>GetAngularVelocityJacobian</b></a>    D, <a href="#Dt"><b>Dt</b></a>  ...


</PRE><nobr><a name="------------"><font color="darkBlue"><font size=+1><b>------------</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
           Bp -- the name of a point fixed on rigid body or rigid frame B.
           Bp.GetSpatialVelocityJacobian( refFrame )
           Bp.GetSpatialVelocityJacobian( refFrame, X )
Output ?:  Matrix whose first row is B.GetAngularVelocityJacobian(...) and
           whose second row is Bp.GetVelocityJacobian(...),  where
           B is the RigidFrame or RigidBody to which point Bp is fixed.
------------


</PRE><nobr><a name="GetPartialVelocity"><font color="darkBlue"><font size=+1><b>GetPartialVelocity</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetPartials  GetPartialVelocity  GetPartialAngularVelocity

 Purpose:  Forms partial velocities and partial angular velocities.

Syntax 1:  Q.GetPartialVelocity( refFrame )
           Q.GetPartialVelocity( refFrame, generalizedSpeedi )
Syntax 2:  B.GetPartialAngularVelocity( refFrame )
           B.GetPartialAngularVelocity( refFrame, generalizedSpeedi )
Syntax 3:  GetPartialVelocity( scalarOrTensorExpression )
           GetPartialVelocity( scalarOrTensorExpression, generalizedSpeedi )

   Input:  Q -- name of a Point.
           B -- name of a RigidFrame or RigidBody.
           refFrame -- name of a RigidFrame or RigidBody.
           scalarOrTensorExpression -- scalar, vector, or dyadic expression.
           generalizedSpeedi -- name of a generalized speed.

Output 1:  Column matrix of Q's partial velocities in refFrame or
           Q's partial velocity in refFrame for generalizedSpeedi.

Output 2:  Column matrix of B's partial angular velocities in refFrame or
           B's partial angular velocity in refFrame for generalizedSpeedi.

Output 3:  Column matrix of partial velocities for scalarOrTensorExpression or
           the partial velocity associated with generalizedSpeedi.

  Remark:  The returned quantity may depend on whether the command is
           issued before or after the CONSTRAIN command.

 Related:  <a href="#GetVelocity"><b>GetVelocity</b></a>           <a href="#GetVelocity"><b>GetRelativeVelocity</b></a>
           <a href="#GetPartialVelocity"><b>GetPartialVelocity</b></a>    <a href="#GetPartialVelocity"><b>GetPartialAngularVelocity</b></a>
           <a href="#GetVelocityRemainder"><b>GetVelocityRemainder</b></a>  <a href="#GetVelocityRemainder"><b>GetAngularVelocityRemainder</b></a>
           <a href="#GetJacobian"><b>GetVelocityJacobian</b></a>   <a href="#GetJacobian"><b>GetAngularVelocityJacobian</b></a>    D, <a href="#Dt"><b>Dt</b></a>  ...

   (1) %--------------------------------------------------------------------
   (2) % Example: GetPartialVelocity and GetPartialAngularVelocity
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N
   (5) RigidBody      B        % Sphere
   (6) Point          BN(B)    % Point of B in contact with N
   (7) %----------------------------------------------------------
   (8) Constant  R
   (9) Variable  x',  y'
   (10) Variable  wx,  wy,  wz
   (11) SetGeneralizedSpeed( x', y', wx, wy, wz )
   (12) %----------------------------------------------------------
   (13) B.SetAngularVelocity( N,  wx*Nx> + wy*Ny> + wz*Nz> )
-> (14) w_B_N> = wx*Nx> + wy*Ny> + wz*Nz>

   (15) Bcm.SetPositionVelocity( No,  x*Nx> + y*Ny> + R*Nz> )
-> (16) p_No_Bcm> = x*Nx> + y*Ny> + R*Nz>
-> (17) v_Bcm_N> = x'*Nx> + y'*Ny>

   (18) %----------------------------------------------------------
   (19) % Example: Partial angular velocities and velocities.
   (20) wBNPartials = B.GetPartialAngularVelocity( N ) 
-> (21) wBNPartials = [0>;  0>;  Nx>;  Ny>;  Nz>]

   (22) vBcmNPartials = Bcm.GetPartialVelocity( N )
-> (23) vBcmNPartials = [Nx>;  Ny>;  0>;  0>;  0>]

   (24) %----------------------------------------------------------
   (25) % Example: Generic partial velocities.
   (26) genericPartialA = GetPartialVelocity( cos(t)*x'*Nx> + sin(t)*y'*Ny> ) 
-> (27) genericPartialA = [cos(t)*Nx>;  sin(t)*Ny>;  0>;  0>;  0>]

   (28) genericPartialB = GetPartialVelocity( R*(wx + wy) + 3*x' + 4*y' ) 
-> (29) genericPartialB = [3;  4;  R;  R;  0]

   (30) genericPartialC = GetPartialVelocity( [w_B_N>;  v_Bcm_N>],  x' ) 
-> (31) genericPartialC = [0>;  Nx>]

   (32) genericPartialD = GetPartialVelocity(  w_B_N>,             [x'; y'; wx] ) 
-> (33) genericPartialD = [0>;  0>;  Nx>]

   (34) genericPartialE = GetPartialVelocity( [w_B_N>,  v_Bcm_N>], [x'; y'; wx] ) 
-> (35) genericPartialE = [0>, Nx>;  0>, Ny>;  Nx>, 0>]

   (36) genericPartialF = GetPartialVelocity( [w_B_N>;  v_Bcm_N>], [x'; y'; wx] ) 
-> (37) genericPartialF = [0>, 0>, Nx>;  Nx>, Ny>, 0>]



</PRE><nobr><a name="Dyadic"><font color="darkBlue"><font size=+1><b>Dyadic</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Dyadic

 Purpose:  Constructs a dyadic.

Syntax 1:  Dyadic( A,  xx, yy, zz )
Syntax 2:  Dyadic( A,  xx,xy,xz, yx,yy,yz, zx,zy,zz )
Syntax 3:  Dyadic( A,  threeElementMatrix )
Syntax 4:  Dyadic( A,  nineElementMatrix )
Syntax 5:  Dyadic( A,  dyadic>>   )

   Input:  A -- the name of a RigidFrame or RigidBody
           xx, xy, xz, ..., zz -- scalar expressions
           threeElementMatrix -- 3x1  or  1x3 matrix of scalars
           nineElementMatrix --  9x1  or  1x9  or  3x3 matrix

Output 1:   xx*Ax>*Ax> + yy*Ay>*Ay> + zz*Az>*Az>

Output 2:   xx*Ax>*Ax> + xy*Ax>*Ay> + xz*Ax>*Az>
          + yx*Ay>*Ax> + yy*Ay>*Ay> + yz*Ay>*Az>
          + zx*Az>*Ax> + zy*Az>*Ay> + zz*Az>*Az>

Output 3:  3x3  matrix whose elements are the Ai>*Aj>
           (i,j = x,y,z) measures of dyadic>>

Output 3:  Similar to Output 1.
Output 4:  Similar to Output 2.

 Related:  <a href="#>"><b>></b></a>  <a href="#>"><b>>></b></a>  <a href="#>"><b>>>></b></a>  <a href="#0>"><b>0></b></a> <a href="#0>"><b>0>></b></a> <a href="#1>>"><b>1>></b></a>  <a href="#Vector"><b>Vector</b></a>  <a href="#Dyadic"><b>Dyadic</b></a>  <a href="#Matrix"><b>Matrix</b></a>  <a href="#Express"><b>Express</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  Dyadic( A,  xx, yy, zz )
   (3) %--------------------------------------------------------------------
   (4) RigidFrame A, B
   (5) Constant   xx, yy, zz
   (6) dyadic1>> = Dyadic( A,  xx, yy, zz )
-> (7) dyadic1>> = xx*Ax>*Ax> + yy*Ay>*Ay> + zz*Az>*Az>

   (8) %--------------------------------------------------------------------
   (9) % Example 2:  Dyadic( A,  xx,xy,xz, yx,yy,yz,  zx,zy,zz )
   (10) %--------------------------------------------------------------------
   (11) Constant   xy, xz, yx, yz, zx, zy
   (12) dyadic2>> = Dyadic( A,  xx,xy,xz,  yx,yy,yz,  zx,zy,zz )
-> (13) dyadic2>> = xx*Ax>*Ax> + xy*Ax>*Ay> + xz*Ax>*Az> + yx*Ay>*Ax> + yy*Ay>*Ay>
        + yz*Ay>*Az> + zx*Az>*Ax> + zy*Az>*Ay> + zz*Az>*Az>

   (14) %--------------------------------------------------------------------
   (15) % Example 3:  Dyadic( A,  threeElementMatrix )
   (16) %--------------------------------------------------------------------
   (17) dyadic3>> = Dyadic( A,  [xx; yy; zz] )
-> (18) dyadic3>> = xx*Ax>*Ax> + yy*Ay>*Ay> + zz*Az>*Az>

   (19) %--------------------------------------------------------------------
   (20) % Example 4:  Dyadic( nineElementMatrix )
   (21) %--------------------------------------------------------------------
   (22) dyadic4>> = Dyadic( A,  [1, 2, 3;  4, 5, 6;  7, 8, 9] )
-> (23) dyadic4>> = Ax>*Ax> + 2*Ax>*Ay> + 3*Ax>*Az> + 4*Ay>*Ax> + 5*Ay>*Ay>
        + 6*Ay>*Az> + 7*Az>*Ax> + 8*Az>*Ay> + 9*Az>*Az>

   (24) %--------------------------------------------------------------------
   (25) % Example 5:  Dyadic( A,  dyadic>> )
   (26) %--------------------------------------------------------------------
   (27) B.SetRotationMatrixZ( A, t ) 
-> (28) B_A = [cos(t), sin(t), 0;  -sin(t), cos(t), 0;  0, 0, 1]

   (29) matrix1 = Dyadic( A,  2*Ax>*Ax> + 3*Ay>*Ay> + 4*Ax>*Ay> + 5*Ay>*Ax> )
-> (30) matrix1 = [2, 4, 0;  5, 3, 0;  0, 0, 0]

   (31) matrix2 = Dyadic( B,  Ax>*Bz> + 2*Ay>*Bz> + 3*Az>*Bx> + 4*Bz>*Bz> )
-> (32) matrix2 = [0, 0, cos(t) + 2*sin(t);  0, 0, 2*cos(t) - sin(t);  3, 0, 4]



</PRE><nobr><a name="Echo"><font color="darkBlue"><font size=+1><b>Echo</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Echo

 Purpose:  Display messages on the screen.

  Syntax:  ECHO( MSG )

   Input:  MSG -- A string of characters that may include special
           character sequences which have a special effect, i.e.,

           SEQUENCE         EFFECT
           ------------------------------------------------------
           \a               Audible beep
           \p               Pauses program using the SetPause setting
           \p=n             Pauses n milliseconds (n = 0, 200, 3000, ...)
           \k               Stop reading from file (switch to keyboard input)
           \0               Terminates printing of MSG
           \n               Prints a newline character
           \e               Puts a newline character, indents 7 spaces
           \w               Puts a newline character, indents 9 spaces
           \#               Prints the # character
           \"               Prints the " character
           \\               Prints the \ character
           #CMSymbol#       Prints the name assigned to CMSymbol.
           #NewtonianFrame# If  a  NewtonianFrame has been declared,
                            prints  the  name of that frame,
                            otherwise #NewtonianFrame# is printed.

  Output:  MSG is printed to the screen

  Remark:  To prevent the removal of extra spaces, put the message in
           quotes, e.g., Echo( "Hello World!" ).   The ECHO command is
           helpful when creating external commands (.a and .r files).

  Related: <a href="#SetBeepSoundOnError"><b>SetBeepSoundOnError</b></a>

 Example:

   (1) Echo( Renee says 1 + 1 = 2 )
Renee says 1+1=2

   (1) Echo("Renee says 1 + 1 = 2" )
Renee says 1 + 1 = 2

   (1) Echo(" Renee says \"Hello world!\" \n and also says 2 + 2 = 4" )
 Renee says "Hello world!"
 and also says 2 + 2 = 4

   (1) Echo(\k\a"Error: Wrong arguments to the myFunction command" )
Error: Wrong arguments to the myFunction command



</PRE><nobr><a name="Encode"><font color="darkBlue"><font size=+1><b>Encode</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
ConstantEncode  SpecifiedEncode  OutputEncode

 Purpose:  Instructs MATLAB(R), C, and Fortran programs to incorporate
           additional inputs, outputs, or calculations that may
           not otherwise appear because of code-optimization.

Syntax 1:  ConstantEncode  -- type  HELP CONSTANT   for information.
Syntax 2:  SpecifiedEncode -- type  HELP SPECIFIED  for information.
Syntax 3:  OutputEncode    -- type  HELP OUTPUT     for information.

  Remark:  Type  ConstantEncode to list the quantities previously
           named in a ConstantEncode declaration.
           Similarly type  SpecifiedEncode  or  OutputEncode.

 Related:  <a href="#ODE"><b>ODE</b></a>  <a href="#Solve"><b>Solve</b></a>  <a href="#Input"><b>Input</b></a>  <a href="#Output"><b>Output</b></a>  <a href="#Output"><b>OutputPlot</b></a>  <a href="#Plot"><b>Plot</b></a>  <a href="#Animate"><b>Animate</b></a>
           <a href="#ConvertUnits"><b>ConvertUnits</b></a>  <a href="#GetUnitSystem"><b>GetUnitSystem</b></a>  <a href="#SetUnitSystem"><b>SetUnitSystem</b></a>  <a href="#SetDigits"><b>SetDigits</b></a>
           <a href="#Constant"><b>Constant</b></a>  <a href="#Specified"><b>Specified</b></a>  <a href="#Output"><b>Output</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: ConstantEncode
   (3) %--------------------------------------------------------------------
   (4) % ConstantEncode  a, b, c
   (5) %
   (6) %--------------------------------------------------------------------
   (7) % Example 2: SpecifiedEncode
   (8) %--------------------------------------------------------------------
   (9) % SpecifiedEncode  slipStickTest, Fx, vx, theta''
   (10) %
   (11) %--------------------------------------------------------------------
   (12) % Example 3: OutputEncode  
   (13) %--------------------------------------------------------------------
   (14) Variables  x'' = cos(t)
-> (15) x'' = cos(t)

   (16) SetUnitSystem( kg, m, sec )
   (17) Input  x = 3 miles,  x' = 0 ft/sec,  tFinal = 10 sec
   (18) OutputEncode  t seconds, x inches, x ft,  2*x km,  sin(x) noUnits
   (19) ODE()  EncodeExample.m



</PRE><nobr><a name="Epsilon"><font color="darkBlue"><font size=+1><b>Epsilon</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Epsilon

 Purpose:  Rounds numbers that are suitably close to an integer.

Syntax 1:  Epsilon( mathExpression, absEpsilon )
Syntax 2:  Epsilon( mathExpression, absEpsilon, relEpsilon )

   Input:  mathExpression -- A scalar, vector, dyadic, or matrix expression.
           absEpsilon a real number r such that:   0  <=  r  < 0.5
           relEpsilon a real number r such that:   0  <=  r  < 0.5

Output 1:  In mathExpression, rounds any number that is within absEpsilon of
           an integer to that integer.  For a number of the form  x.y,  no
           rounding occurs if  absEpsilon <  abs(0.y)  < 1 - absEpsilon

Output 2:  Rounds any number d within abs( d * relEpsilon) of an integer
           to that integer.  Also does the rounding described by Output 1.

 Remark:   If  SetAutoEpsilon( d )  has also been employed,
           absEpsilon should be greater than or equal to d.

 Remark:   Also see RoundDigits.

 Related:  <a href="#Epsilon"><b>Epsilon</b></a>  <a href="#Evaluate"><b>Evaluate</b></a>  <a href="#Expand"><b>Expand</b></a>  <a href="#Explicit"><b>Explicit</b></a>
           <a href="#Factor"><b>Factor</b></a>  <a href="#FactorLinear"><b>FactorLinear</b></a>  <a href="#FactorLinear"><b>FactorQuadratic</b></a>  <a href="#ReplaceString"><b>ReplaceString</b></a>  <a href="#RoundDigits"><b>RoundDigits</b></a>
           <a href="#SetAutoEpsilon"><b>SetAutoEpsilon</b></a>  <a href="#SetDigits"><b>SetDigits</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  Epsilon  (scalar expression)
   (3) %--------------------------------------------------------------------
   (4) SetDigits 16
   (5) s = 2E-11 + 1.00007*t + (9876 + 5E-8)*sin(t)
-> (6) s = 2E-11 + 1.00007*t + 9876.00000005*sin(t)

   (7) s1 = Epsilon( s,  1.0E-10 )     % Absolute = 1.0E-10, Relative = 0
-> (8) s1 = 1.00007*t + 9876.00000005*sin(t)

   (9) s2 = Epsilon( s,  0.0001  )     % Absolute = 1.0E-4,  Relative = 0
-> (10) s2 = t + 9876*sin(t)

   (11) s3 = Epsilon( s,  0,   1E-7  )  % Absolute = 0,       Relative = 1E-7
-> (12) s3 = 2E-11 + 1.00007*t + 9876*sin(t)

   (13) s4 = Epsilon( s,  0,   0.0001)  % Absolute = 0,       Relative = 1E-4
-> (14) s4 = 2E-11 + t + 9876*sin(t)

   (15) %--------------------------------------------------------------------
   (16) % Example 2:  Epsilon  (vector expression)
   (17) %--------------------------------------------------------------------
   (18) RigidFrame  N
   (19) v> = Vector( N,  2E-11, 1.00007*t, (9876 + 5E-8)*sin(t) )
-> (20) v> = 2E-11*Nx> + 1.00007*t*Ny> + 9876.00000005*sin(t)*Nz>

   (21) v1> = Epsilon( v>,  1.0E-10  )   % Absolute = 1.0E-10, Relative = 0
-> (22) v1> = 1.00007*t*Ny> + 9876.00000005*sin(t)*Nz>

   (23) v2> = Epsilon( v>,  0,   1E-4 )  % Absolute = 0,       Relative = 1E-4
-> (24) v2> = 2E-11*Nx> + t*Ny> + 9876*sin(t)*Nz>

   (25) %--------------------------------------------------------------------
   (26) % Example 3:  Epsilon  (matrix expression) 
   (27) %--------------------------------------------------------------------
   (28) m = [s; v>]
-> (29) m = [s;  2E-11*Nx> + 1.00007*t*Ny> + 9876.00000005*sin(t)*Nz>]

   (30) m1 = Epsilon( m,  1.0E-10  )     % Absolute = 1.0E-10, Relative = 0
-> (31) m1 = [s;  1.00007*t*Ny> + 9876.00000005*sin(t)*Nz>]

   (32) m2 = Epsilon( m,  0,   1E-4 )    % Absolute = 0,       Relative = 1E-4
-> (33) m2 = [s;  2E-11*Nx> + t*Ny> + 9876*sin(t)*Nz>]



</PRE><nobr><a name="Evaluate"><font color="darkBlue"><font size=+1><b>Evaluate</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Evaluate,  EvaluateAtInput,  EvaluateToNumber

 Purpose:  Evaluates an expression by replacing designated symbols.

Syntax 1:  Evaluate( mathExpression, name1=rhs1, name2=rhs2, ... )
Syntax 2:  EvaluateAtInput( mathExpression )
           EvaluateAtInput( mathExpression, name1=rhs1, name2=rhs2, ... )
Syntax 3:  EvaluateToNumber( mathExpression )
           EvaluateToNumber( mathExpression, name1=rhs1, name2=rhs2, ... )

   Input:  mathExpression -- A scalar, vector, matrix, ... expression.
           namei -- The name of a symbol (e.g., a constant or variable).
           rhsi -- An expression to substitute for namei. (i=1,2,...),
                   with optional units (e.g., x = 3 deg).

Output 1:  Returns mathExpression evaluated with rhsi substituted
           for namei wherever namei appears in mathExpression.

Output 2:  In addition to making substitutions described in Output 1 (above),
           evaluates an expression using values assigned in Input statements.
           When a previous Input statement has been issued of the form:

           Input x=xValue, y=yValue deg, z=zValue km/hour

           returns mathExpression evaluated with xValue substituted for x,
           yValue * ConvertUnits(deg,rad)               substituted for y,
           zValue * ConvertUnits(km/hr, GetUnitSystem)  substituted for z.

Output 3:  In addition to evaluating as described in Output 1 and 2,
           uses any assignment in the workspace of the form
           x = someNumber    (e.g., x = 2.3).

 Remark:   The units conversion factor used for arguments of the form
           x = 3 km/hour   depends on the current UnitSystem.

 Related:  <a href="#Epsilon"><b>Epsilon</b></a>  <a href="#Evaluate"><b>Evaluate</b></a>  <a href="#Evaluate"><b>EvaluateAtInput</b></a>  <a href="#Explicit"><b>Explicit</b></a>  <a href="#GetRhs"><b>GetRhs</b></a>
           <a href="#Input"><b>Input</b></a>  <a href="#ReplaceString"><b>ReplaceString</b></a>  <a href="#RoundDigits"><b>RoundDigits</b></a>  <a href="#SetAutoRhs"><b>SetAutoRhs</b></a>  <a href="#SetUnitSystem"><b>SetUnitSystem</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: Evaluate   (scalar expression)
   (3) %--------------------------------------------------------------------
   (4) Variable  x, y
   (5) z = x^2*cos(y) - sin(t)
-> (6) z = x^2*cos(y) - sin(t)

   (7) zEvaluated1 = Evaluate( z,  x=2, y=60 deg, t=30 deg )
-> (8) zEvaluated1 = 1.5

   (9) zEvaluated2 = Evaluate( z,  x=t, y=t^3 )
-> (10) zEvaluated2 = t^2*cos(t^3) - sin(t)

   (11) %--------------------------------------------------------------------
   (12) % Example 2: Evaluate   (vector expression)
   (13) %--------------------------------------------------------------------
   (14) RigidBody   B
   (15) v> = Vector( B, x, y, z )
-> (16) v> = x*Bx> + y*By> + z*Bz>

   (17) vEvaluated1> = Evaluate( v>,  x=1 km, y=2 m, z=3 cm )
-> (18) vEvaluated1> = 1000*Bx> + 2*By> + 0.03*Bz>

   (19) vEvaluated2> = Evaluate( v>,  x=t km, y=t^3 m )
-> (20) vEvaluated2> = 1000*t*Bx> + t^3*By> + (1000000*t^2*cos(t^3)-sin(t))*Bz>

   (21) %--------------------------------------------------------------------
   (22) % Example 3: Evaluate   (matrix expression)
   (23) %--------------------------------------------------------------------
   (24) matrix[1] = v>
-> (25) matrix[1] = x*Bx> + y*By> + z*Bz>

   (26) matrix[2] = z
-> (27) matrix[2] = z

   (28) matrix[3] = x + y + z
-> (29) matrix[3] = x + y + z

   (30) matrixEvaluated1 = Evaluate( matrix,  x=1 km, y=2, z=3 cm )
-> (31) matrixEvaluated1 = [1000*Bx> + 2*By> + 0.03*Bz>;  0.03;  1002.03]

   (32) matrixEvaluated2 = Evaluate( matrix,  x=t, y=t^3 )
-> (33) matrixEvaluated2[1] = t*Bx> + t^3*By> + (t^2*cos(t^3)-sin(t))*Bz>
-> (34) matrixEvaluated2[2] = t^2*cos(t^3) - sin(t)
-> (35) matrixEvaluated2[3] = t + t^3 + t^2*cos(t^3) - sin(t)

   (36) %--------------------------------------------------------------------
   (37) % Example 4: EvaluateAtInput 
   (38) %--------------------------------------------------------------------
   (39) s = sin(y) + cos(t)*x^2
-> (40) s = sin(y) + cos(t)*x^2

   (41) Input x=4, y=150 deg
   (42) sEvaluated2 = EvaluateAtInput( s )
-> (43) sEvaluated2 = 0.5 + 16*cos(t)

   (44) sEvaluated3 = EvaluateAtInput( s,  x=t^2 )
-> (45) sEvaluated3 = 0.5 + t^4*cos(t)

   (46) sEvaluated4 = EvaluateAtInput( s,  x=t^2, y=t deg )
-> (47) sEvaluated4 = sin(0.01745329*t) + t^4*cos(t)

   (48) %--------------------------------------------------------------------
   (49) % Example 5: EvaluateToNumber 
   (50) %--------------------------------------------------------------------
   (51) t = 2
-> (52) t = 2

   (53) sEvaluatedToNumber = EvaluateToNumber( s,  y = log(2)*GetImaginaryNumber() )
-> (54) sEvaluatedToNumber = -6.658349 + 0.75*imaginary



</PRE><nobr><a name="exp"><font color="darkBlue"><font size=+1><b>exp</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
exp

 Purpose:  Returns the exponential function of a scalar expression.

  Syntax:  exp( scalarExpression )

   Input:  scalarExpression -- a real or complex scalar expression.

  Output:  Exponential function of scalarExpression, i.e., the number
           e (2.71828...) raised to the power scalarExpression.

 Related:  <a href="#ImaginaryNumber"><b>ImaginaryNumber</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: exp   (real scalar expressions)
   (3) %--------------------------------------------------------------------
   (4) A = exp( 2 ) 
-> (5) A = 7.389056

   (6) B = exp(2*t)
-> (7) B = exp(2*t)

   (8) C = exp(0.5+2*t)
-> (9) C = 1.648721*exp(2*t)

   (10) %--------------------------------------------------------------------
   (11) % Example 2: exp   (complex scalar expressions)
   (12) %--------------------------------------------------------------------
   (13) D = exp( 2 + 3*GetImaginaryNumber() )
-> (14) D = -7.31511 + 1.042744*imaginary

   (15) E = exp( 3*GetImaginaryNumber() + t )
-> (16) E = exp(3*imaginary+t)



</PRE><nobr><a name="Expand"><font color="darkBlue"><font size=+1><b>Expand</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Expand

 Purpose:  Produces an expression that is mathematically equivalent to the
           given expression but usually containing fewer parentheses.

Syntax 1:  Expand( mathExpression )
Syntax 2:  Expand( mathExpression,  n   )
Syntax 3:  Expand( mathExpression,  n:m )
Syntax 4:  Expand( mathExpression,  X   )
Syntax 5:  Expand( mathExpression,  n,   X )
Syntax 6:  Expand( mathExpression,  n:m, X )

   Input:  mathExpression -- A scalar, vector, matrix, ... expression.

           n -- a positive integer
           m -- a positive integer

           X -- The name of a scalar symbol (e.g., a constant or variable)
                or a comma-separated list of names of scalars
                or a matrix of scalar names.

Output 1:  Expands parentheses enclosing terms raised to the power 1.
Output 2:  Expands parentheses enclosing terms raised to the power n.
Output 3:  Expands parentheses enclosing terms raised to powers n:m.
Output 4:  Expands parentheses enclosing terms raised to the power 1
           that also enclose one or more names contained in X.
Output 5:  Expands parentheses enclosing terms raised to the power n
           that also enclose one or more names contained in X.
Output 6:  Expands parentheses enclosing terms raised to powers n:m
           that also enclose one or more names contained in X.

  Remark:  Expand is a dual function.
           Expand( expression )     does not re-factor the expression.
           y = Expand( expression )     may  re-factor the expression.

 Related:  <a href="#Epsilon"><b>Epsilon</b></a>  <a href="#Evaluate"><b>Evaluate</b></a>  <a href="#Expand"><b>Expand</b></a>  <a href="#Explicit"><b>Explicit</b></a>
           <a href="#Factor"><b>Factor</b></a>  <a href="#FactorLinear"><b>FactorLinear</b></a>  <a href="#FactorLinear"><b>FactorQuadratic</b></a>  <a href="#ReplaceString"><b>ReplaceString</b></a>  <a href="#RoundDigits"><b>RoundDigits</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: Expand  (scalar expressions with certain powers)
   (3) %--------------------------------------------------------------------
   (4) Constant  a, b, c, x
   (5) y = (a+b)^2 + a*(x+c^2) + b*(c+a*b)
-> (6) y = (a+b)^2 + a*(x+c^2) + b*(c+a*b)

   (7) y1 = Expand( y )
-> (8) y1 = a*x + b*c + a*b^2 + a*c^2 + (a+b)^2

   (9) y2 = Expand( y,  2 )
-> (10) y2 = a^2 + b^2 + 2*a*b + a*(x+c^2) + b*(c+a*b)

   (11) y3 = Expand( y,  1:2 )
-> (12) y3 = a*x + a^2 + b*c + b^2 + 2*a*b + a*b^2 + a*c^2

   (13) %--------------------------------------------------------------------
   (14) % Example 2: Expand  (scalar expressions containing certain symbols)
   (15) %--------------------------------------------------------------------
   (16) y4 = Expand( y,  a )
-> (17) y4 = b*c + a*b^2 + (a+b)^2 + a*(x+c^2)

   (18) y5 = Expand( y,  x )
-> (19) y5 = a*x + a*c^2 + (a+b)^2 + b*(c+a*b)

   (20) y6 = Expand( y,  [a,x] )
-> (21) y6 = a*x + b*c + a*b^2 + a*c^2 + (a+b)^2

   (22) %--------------------------------------------------------------------
   (23) % Example 3: Expand  (scalar expressions with certain powers/symbols)
   (24) %--------------------------------------------------------------------
   (25) y7 = Expand( y,  2,  a )
-> (26) y7 = a^2 + b^2 + 2*a*b + a*(x+c^2) + b*(c+a*b)

   (27) y8 = Expand( y,  2,  [a,x] )
-> (28) y8 = a^2 + b^2 + 2*a*b + a*(x+c^2) + b*(c+a*b)

   (29) %--------------------------------------------------------------------
   (30) % Example 4: Expand  (Expand is a dual command so it can overwrite y)
   (31) %--------------------------------------------------------------------
   (32) Expand( y,  1:2 )
-> (33) y = a*x + a^2 + b*c + b^2 + 2*a*b + a*b^2 + a*c^2

   (34) %--------------------------------------------------------------------
   (35) % Example 5: Expand  (vector expressions with certain powers)
   (36) %--------------------------------------------------------------------
   (37) RigidFrame  N
   (38) v> = Vector( N, (a+b)^2, (a+b)^3, (a+b)^4 )
-> (39) v> = (a+b)^2*Nx> + (a+b)^3*Ny> + (a+b)^4*Nz>

   (40) Expand( v>,  2:3 )
-> (41) v> = (a^2+b^2+2*a*b)*Nx> + (a^3+b^3+3*a*b^2+3*b*a^2)*Ny> + (a+b)^4*Nz>

   (42) %--------------------------------------------------------------------
   (43) % Example 6: Expand  (matrix expressions with certain power)
   (44) %--------------------------------------------------------------------
   (45) mat = [(a+b)^2;  Vector( N, (a+b)^2, (a+b)^3, (a+b)^4 )]
-> (46) mat = [(a+b)^2;  (a+b)^2*Nx> + (a+b)^3*Ny> + (a+b)^4*Nz>]

   (47) Expand( mat,  2 )
-> (48) mat[1] = a^2 + b^2 + 2*a*b
-> (49) mat[2] = (a^2+b^2+2*a*b)*Nx> + (a+b)^3*Ny> + (a+b)^4*Nz>



</PRE><nobr><a name="Explicit"><font color="darkBlue"><font size=+1><b>Explicit</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Explicit

 Purpose:  Substitutes the right-hand-side of all names in an expressions,
           repeating this process until no names that have a
           right-hand-side remain the expression.

Syntax 1:  Explicit( mathExpression )
Syntax 2:  Explicit( mathExpression, X )

   Input:  mathExpression -- A scalar, vector, matrix, ... expression.

           X -- The name of a scalar symbol (e.g., a constant or variable)
                or a comma-separated list of names of scalars
                or a matrix of scalar names.

Output 1:  Alternate representation of mathExpression that is explicit
           in names that do not have right-hand sides.

Output 2:  Alternate representation of mathExpression that is explicit in X.

  Remark:  Explicit is a dual function.

 Related:  <a href="#Evaluate"><b>Evaluate</b></a>  <a href="#Expand"><b>Expand</b></a>  <a href="#Explicit"><b>Explicit</b></a>
           <a href="#Factor"><b>Factor</b></a>  <a href="#FactorLinear"><b>FactorLinear</b></a>  <a href="#FactorLinear"><b>FactorQuadratic</b></a>  <a href="#ReplaceString"><b>ReplaceString</b></a>
           <a href="#GetRhs"><b>GetRhs</b></a>  <a href="#SetAutoRhs"><b>SetAutoRhs</b></a>  <a href="#SetNoZeeSymbol"><b>SetNoZeeSymbol</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: Explicit  (scalar expressions)
   (3) %--------------------------------------------------------------------
   (4) Constant  a, b, c
   (5) w = a + 2*b 
-> (6) w = a + 2*b

   (7) x = b + 5*c + w
-> (8) x = b + 5*c + w

   (9) y = sin(x) + cos(t)
-> (10) y = sin(x) + cos(t)

   (11) y1 = Explicit( y )
-> (12) y1 = sin(a+3*b+5*c) + cos(t)

   (13) %--------------------------------------------------------------------
   (14) % Example 2: Explicit  (scalar expressions containing certain symbols)
   (15) %--------------------------------------------------------------------
   (16) y2 = Explicit( y,  c )
-> (17) y2 = sin(b+5*c+w) + cos(t)

   (18) %--------------------------------------------------------------------
   (19) % Example 3: Explicit  (Explicit is a dual command so it can overwrite y)
   (20) %--------------------------------------------------------------------
   (21) Explicit( y )
-> (22) y = sin(a+3*b+5*c) + cos(t)

   (23) %--------------------------------------------------------------------
   (24) % Example 4: Explicit  (vector expressions with certain powers)
   (25) %--------------------------------------------------------------------
   (26) RigidFrame  N
   (27) v> = Vector( N, w, x, y )
-> (28) v> = w*Nx> + x*Ny> + y*Nz>

   (29) Explicit( v>,  [b,x] )
-> (30) v> = (a+2*b)*Nx> + x*Ny> + (sin(a+3*b+5*c)+cos(t))*Nz>

   (31) %--------------------------------------------------------------------
   (32) % Example 5: Explicit  (matrix expressions with certain power)
   (33) %--------------------------------------------------------------------
   (34) m = [ y, v> ]
-> (35) m = [y, (a+2*b)*Nx> + x*Ny> + (sin(a+3*b+5*c)+cos(t))*Nz>]

   (36) Explicit( m )
-> (37) m[1,1] = sin(a+3*b+5*c) + cos(t)
-> (38) m[1,2] = (a+2*b)*Nx> + (a+3*b+5*c)*Ny> + (sin(a+3*b+5*c)+cos(t))*Nz>



</PRE><nobr><a name="Express"><font color="darkBlue"><font size=+1><b>Express</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Express

 Purpose:  Expresses a vector, dyadic, or other tensor in terms of
           basis vectors fixed in RigidFrame or RigidBody.

  Syntax:  Express( v, RefFrame )

   Input:  v -- a vector, dyadic, triadic or tensor expression or
                a matrix of such expressions.

           RefFrame -- name of a RigidFrame or RigidBody.

  Output:  v expressed in terms of the right-handed orthogonal unit vectors
           fixed in RefFrame, e.g., RefFramex>, RefFramey>, RefFramez>.

  Remark:  Express is a dual function.

   (1) %--------------------------------------------------------------------
   (2) % Example 1: Express   (vector expression)
   (3) %--------------------------------------------------------------------
   (4) RigidBody  A, B
   (5) Variable   q
   (6) B.RotateZ( A, q )
-> (7) B_A = [cos(q), sin(q), 0;  -sin(q), cos(q), 0;  0, 0, 1]

   (8) vA> = Vector( A, 2, 3, 4 )
-> (9) vA> = 2*Ax> + 3*Ay> + 4*Az>

   (10) vB> = Express( vA>, B ) 
-> (11) vB> = (2*cos(q)+3*sin(q))*Bx> + (3*cos(q)-2*sin(q))*By> + 4*Bz>

   (12) %--------------------------------------------------------------------
   (13) % Example 2: Express   (dyadic expression)
   (14) %--------------------------------------------------------------------
   (15) dA>> = Dyadic( A, 2, 3, 4 )
-> (16) dA>> = 2*Ax>*Ax> + 3*Ay>*Ay> + 4*Az>*Az>

   (17) dB>> = Express( dA>>, B )
-> (18) dB>> = (2+sin(q)^2)*Bx>*Bx> + sin(q)*cos(q)*Bx>*By> + sin(q)*cos(q)*By>*Bx>
        + (3-sin(q)^2)*By>*By> + 4*Bz>*Bz>

   (19) %--------------------------------------------------------------------
   (20) % Example 3: Express   (matrix expression)
   (21) %--------------------------------------------------------------------
   (22) m[1] = vA>
-> (23) m[1] = 2*Ax> + 3*Ay> + 4*Az>

   (24) m[2] = Vector( A, t, t^2, t^3 )
-> (25) m[2] = t*Ax> + t^2*Ay> + t^3*Az>

   (26) Express( m, B )
-> (27) m[1] = (2*cos(q)+3*sin(q))*Bx> + (3*cos(q)-2*sin(q))*By> + 4*Bz>
-> (28) m[2] = t*(cos(q)+t*sin(q))*Bx> - t*(sin(q)-t*cos(q))*By> + t^3*Bz>



</PRE><nobr><a name="Factor"><font color="darkBlue"><font size=+1><b>Factor</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Factor     (see also FactorLinear and FactorQuadratic)

 Purpose:  Useful to simplify results or compare results with another analyst.
           Rearranges expression by regrouping on certain factors.

  Syntax:  Factor( mathExpression, X )

   Input:  mathExpression -- A scalar, vector, matrix, ... expression.

           X -- A factor (e.g., a constant, variable, x^2, x+2, sin(x+y), etc.)
                or a comma-separated list of names of factors
                or a matrix of factors.

  Output:  mathExpression factored on X.

  Remark:  Factor is a dual function.

 Related:  <a href="#Evaluate"><b>Evaluate</b></a>  <a href="#Expand"><b>Expand</b></a>  <a href="#Explicit"><b>Explicit</b></a>
           <a href="#Factor"><b>Factor</b></a>  <a href="#FactorLinear"><b>FactorLinear</b></a>  <a href="#FactorLinear"><b>FactorQuadratic</b></a>  <a href="#ReplaceString"><b>ReplaceString</b></a>
           <a href="#FactorLinear"><b>FactorLinearShallow</b></a>   <a href="#FactorLinear"><b>FactorQuadraticShallow</b></a>
           <a href="#SetAutoFactor"><b>SetAutoFactor</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: Factor  (scalar expressions factored on one factor)
   (3) %--------------------------------------------------------------------
   (4) Constant  a, b, c
   (5) Variable  x
   (6) y = a + a*x + a*b*x + c*x^2 + c*x^3 + a*x^(2+b) 
-> (7) y = a + a*x + a*b*x + c*x^2 + c*x^3 + a*x^(2+b)

   (8) y1 = Factor( y,  x )
-> (9) y1 = a + x*(a+a*b+c*x+c*x^2+a*x^(1+b))

   (10) y2 = Factor( y,  a )
-> (11) y2 = c*x^2 + c*x^3 + a*(1+x+b*x+x^(2+b))

   (12) %--------------------------------------------------------------------
   (13) % Example 2: Factor  (scalar expression factored on multiple factors)
   (14) %--------------------------------------------------------------------
   (15) y3 = Factor( y,  a, c )
-> (16) y3 = c*x^2*(1+x) + a*(1+x+b*x+x^(2+b))

   (17) %--------------------------------------------------------------------
   (18) % Example 3: Factor  (Factor is a dual command so it can overwrite y)
   (19) %--------------------------------------------------------------------
   (20) Factor( y,  x )
-> (21) y = a + x*(a+a*b+c*x+c*x^2+a*x^(1+b))

   (22) %--------------------------------------------------------------------
   (23) % Example 4: Factor  (matrix expressions factored on one factor)
   (24) %--------------------------------------------------------------------
   (25) m = [a + a*x + b*x; c + a*x^2 + a*x^(2+b)]
-> (26) m = [a + a*x + b*x;  c + a*x^2 + a*x^(2+b)]

   (27) Factor( m,  x )
-> (28) m = [a + (a+b)*x;  c + a*x^2*(1+x^b)]



</PRE><nobr><a name="FactorLinear"><font color="darkBlue"><font size=+1><b>FactorLinear</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
FactorLinear      FactorLinearShallow      (see also Factor)
FactorQuadratic   FactorQuadraticShallow

 Purpose:  Useful to simplify results or compare results with another analyst.
           Rearranges expression by regrouping terms in designated names.
           FactorLinear    rearranges terms in groups of degree 1.
           FactorQuadratic rearranges terms in groups of degree 1 and 2.

Syntax 1:  FactorLinear(           mathExpression, X )
           FactorQuadratic(        mathExpression, X )
Syntax 2:  FactorLinearShallow(    mathExpression, X )
           FactorQuadraticShallow( mathExpression, X )

   Input:  mathExpression -- A scalar, vector, matrix, ... expression.

           X -- The name of a scalar symbol (e.g., a constant or variable)
                or a comma-separated list of names of scalars
                or a matrix of scalar names.

Output 1:  Makes mathExpression explicit in X, then returns mathExpression:
           (a) grouped in terms of degree  1       in  X  for FactorLinear
           (b) grouped in terms of degree  1 or 2  in  X  for FactorQuadratic.

Output 2:  Does NOT  Explicit(mathExpression, X),  but returns mathExpression:
           (a) grouped in degree  1       in  X  for FactorLinearShallow
           (b) grouped in degree  1 or 2  in  X  for FactorQuadraticShallow.

  Remark:  With SetAutoZee(ON), mathExpression is returned with Zees for its:
           (a) coefficients of terms of degree 1       in X  (FactorLinear)
           (b) coefficients of terms of degree 1 and 2 in X  (FactorQuadratic).

  Remark:  All these functions are dual functions.

 Related:  <a href="#Evaluate"><b>Evaluate</b></a>  <a href="#Expand"><b>Expand</b></a>  <a href="#Explicit"><b>Explicit</b></a>
           <a href="#Factor"><b>Factor</b></a>  <a href="#FactorLinear"><b>FactorLinear</b></a>  <a href="#FactorLinear"><b>FactorQuadratic</b></a>  <a href="#ReplaceString"><b>ReplaceString</b></a>
           <a href="#GetPolynomialRoots"><b>GetQuadraticRoots</b></a>  <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRoot</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: FactorLinear  (scalar expressions)
   (3) %--------------------------------------------------------------------
   (4) Constant  a, b, c, x
   (5) y = 7 + a*c + a*x + b*(11+c+x*t)
-> (6) y = 7 + a*c + a*x + b*(11+c+x*t)

   (7) y1 = FactorLinear( y,  a )
-> (8) y1 = 7 + a*(c+x) + b*(11+c+x*t)

   (9) y2 = FactorLinear( y,  x, c )
-> (10) y2 = 7 + 11*b + c*(a+b) + x*(a+b*t)

   (11) %--------------------------------------------------------------------
   (12) % Example 2: FactorLinear  (is a dual command so it overwrites y)
   (13) %--------------------------------------------------------------------
   (14) FactorLinear( y,  [x,c] )
-> (15) y = 7 + 11*b + c*(a+b) + x*(a+b*t)

   (16) %--------------------------------------------------------------------
   (17) % Example 3: FactorQuadratic  (scalar expressions)
   (18) %--------------------------------------------------------------------
   (19) y3 = FactorQuadratic( y,  a )
-> (20) y3 = 7 + 11*b + b*c + a*(c+x) + b*x*t

   (21) y4 = FactorQuadratic( y,  b )
-> (22) y4 = 7 + a*c + a*x + b*(11+c+x*t)

   (23) y5 = FactorQuadratic( y,  b, c )
-> (24) y5 = 7 + a*c + a*x + b*c + b*(11+x*t)

   (25) %--------------------------------------------------------------------
   (26) % Example 4: FactorQuadratic  (is a dual command so it overwrites y)
   (27) %--------------------------------------------------------------------
   (28) FactorQuadratic( y,  [b, c] )
-> (29) y = 7 + a*c + a*x + b*c + b*(11+x*t)



</PRE><nobr><a name="factorial"><font color="darkBlue"><font size=+1><b>factorial</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
factorial

 Purpose:  Returns the factorial of a non-negative integer.

  Syntax:  factorial( intExpression )

   Input:  intExpression -- a non-negative integer expression, i.e.,
           non-negative integer or a scalar expression which,
           when evaluated, produces a non-negative integer.

  Output:  1 * 2 * 3 *  ...  *  (intExpression-1)  *  intExpression

 Related:  <a href="#ceil"><b>ceil</b></a>  <a href="#ceil"><b>floor</b></a>  <a href="#int"><b>int</b></a>  <a href="#min"><b>max</b></a>  <a href="#min"><b>min</b></a>  <a href="#round"><b>round</b></a>  <a href="#RoundDigits"><b>RoundDigits</b></a>  <a href="#sign"><b>sign</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: Factorial 
   (3) %--------------------------------------------------------------------
   (4) A = Factorial( 4 ) 
-> (5) A = 24

   (6) B = Factorial(2+t^2) 
-> (7) B = factorial(2+t^2)

   (8) C = Factorial( Evaluate(2+t^2,t=1) ) 
-> (9) C = 6



</PRE><nobr><a name="Exclude"><font color="darkBlue"><font size=+1><b>Exclude</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Exclude    ExcludeV    ExcludeA

 Purpose:  Forms the portion of an expression that remains when
           terms containing designated names are excluded.

Syntax 1:  Exclude(  ExpressionY, X )
Syntax 2:  ExcludeV( ExpressionY )
Syntax 3:  ExcludeA( ExpressionY )

   Input:  ExpressionY -- a scalar, vector, or dyadic expression or
           a matrix of scalars, vectors, and/or dyadics.

           X -- The name of a symbol (e.g., constant, variable, or unit vector)
                or a comma-separated list of names of symbols
                or a matrix of names of symbols.

Output 1:  All terms in ExpressionY that that do not contain X.

Output 2:  All terms in ExpressionY that do not contain independent generalized
           speeds (generalized speeds are named in the SetGeneralizedSpeed command).

Output 3:  All terms in ExpressionY that do not contain 1st-time-derivatives of
           independent generalized speeds.

  Remark:  To be Autolev compatible, use:
           ExcludeV( ExpressionY )  instead of  Exclude( ExpressionY, U  ),
           ExcludeA( ExpressionY )  instead of  Exclude( ExpressionY, U' ).

 Related:  <a href="#D"><b>D</b></a>  <a href="#Include"><b>Include</b></a>  <a href="#Exclude"><b>Exclude</b></a>  <a href="#GetCoefficient"><b>GetCoefficient</b></a>
           <a href="#Evaluate"><b>Evaluate</b></a>  <a href="#Expand"><b>Expand</b></a>  <a href="#Explicit"><b>Explicit</b></a>
           <a href="#Factor"><b>Factor</b></a>  <a href="#FactorLinear"><b>FactorLinear</b></a>  <a href="#FactorLinear"><b>FactorQuadratic</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: Exclude  (scalar expressions)
   (3) %--------------------------------------------------------------------
   (4) Constant  a, b, c, x
   (5) y = 7 + a*x + a*c^2 + b*(11+c+a*b)
-> (6) y = 7 + a*x + a*c^2 + b*(11+c+a*b)

   (7) y1 = Exclude( y,  a )
-> (8) y1 = 7 + b*(11+c)

   (9) y2 = Exclude( y,  b )
-> (10) y2 = 7 + a*x + a*c^2

   (11) y3 = Exclude( y,  c, x )
-> (12) y3 = 7 + b*(11+a*b)

   (13) %--------------------------------------------------------------------
   (14) % Example 2: Exclude  (vector expressions)
   (15) %--------------------------------------------------------------------
   (16) RigidFrame N
   (17) v> = Vector( N, a*sin(b), cos(b*c), x )
-> (18) v> = a*sin(b)*Nx> + cos(b*c)*Ny> + x*Nz>

   (19) v1> = Exclude( v>,  a )
-> (20) v1> = cos(b*c)*Ny> + x*Nz>

   (21) v2> = Exclude( v>,  b )
-> (22) v2> = x*Nz>

   (23) v3> = Exclude( v>,  [c,x] )
-> (24) v3> = a*sin(b)*Nx>

   (25) %--------------------------------------------------------------------
   (26) % Example 3: Exclude  (matrix expressions)
   (27) %--------------------------------------------------------------------
   (28) Constant  b1, b2, b3
   (29) Variable  x1, x2, x3
   (30) Zero[1] = 2*x1 + 3*x2 + 4*x3 - b1
-> (31) Zero[1] = 2*x1 + 3*x2 + 4*x3 - b1

   (32) Zero[2] = 3*x1 + 4*x2 + 5*x3 - b2
-> (33) Zero[2] = 3*x1 + 4*x2 + 5*x3 - b2

   (34) Zero[3] = 6*x1 + 7*x2 + 9*x3 - b3
-> (35) Zero[3] = 6*x1 + 7*x2 + 9*x3 - b3

   (36) CoefficientMatrix = D( Zero,  [x1, x2, x3] )     
-> (37) CoefficientMatrix = [2, 3, 4;  3, 4, 5;  6, 7, 9]

   (38) RemainderMatrix = Exclude( Zero,  [x1, x2, x3] ) 
-> (39) RemainderMatrix = [-b1;  -b2;  -b3]



</PRE><nobr><a name="Include"><font color="darkBlue"><font size=+1><b>Include</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Include    IncludeV    IncludeA

 Purpose:  Forms the portion of an expression that contains designated names

Syntax 1:  Include(  ExpressionY, X )
Syntax 2:  IncludeV( ExpressionY )
Syntax 3:  IncludeA( ExpressionY )

   Input:  ExpressionY -- a scalar, vector, or dyadic expression or
           a matrix of scalars, vectors, and/or dyadics.

           X -- The name of a symbol (e.g., constant, variable, or unit vector)
                or a comma-separated list of names of symbols,
                or a matrix of names of symbols,
                that appear linearly in ExpressionY.

Output 1:  All terms in ExpressionY that contain X.

Output 2:  All terms in ExpressionY that contain independent generalized
           speeds (generalized speeds are named in the SetGeneralizedSpeed command).

Output 3:  All terms in ExpressionY that contain 1st-time-derivatives of
           independent generalized speeds.

  Remark:  To be Autolev compatible, use:
           IncludeV( ExpressionY )  instead of  Include( ExpressionY, U  ),
           IncludeA( ExpressionY )  instead of  Include( ExpressionY, U' ).

 Related:  <a href="#D"><b>D</b></a>  <a href="#Include"><b>Include</b></a>  <a href="#Exclude"><b>Exclude</b></a>  <a href="#GetCoefficient"><b>GetCoefficient</b></a>
           <a href="#Evaluate"><b>Evaluate</b></a>  <a href="#Expand"><b>Expand</b></a>  <a href="#Explicit"><b>Explicit</b></a>
           <a href="#Factor"><b>Factor</b></a>  <a href="#FactorLinear"><b>FactorLinear</b></a>  <a href="#FactorLinear"><b>FactorQuadratic</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: Include  (scalar expressions)
   (3) %--------------------------------------------------------------------
   (4) Constant  a, b, c, x
   (5) y = 7 + a*x + a*c^2 + (11+c+b*c)*t
-> (6) y = 7 + a*x + a*c^2 + (11+c+b*c)*t

   (7) y1 = Include( y,  a )
-> (8) y1 = a*(x+c^2)

   (9) y2 = Include( y,  b )
-> (10) y2 = b*c*t

   (11) y3 = Include( y,  a, t )
-> (12) y3 = a*x + a*c^2 + (11+c+b*c)*t

   (13) y4 = Include( y,  [a, t] )
-> (14) y4 = a*x + a*c^2 + (11+c+b*c)*t

   (15) %--------------------------------------------------------------------
   (16) % Example 2: Include  (vector expressions)
   (17) %--------------------------------------------------------------------
   (18) RigidFrame N
   (19) v> = Vector( N, a*sin(b), cos(b)*(a+c), x )
-> (20) v> = a*sin(b)*Nx> + cos(b)*(a+c)*Ny> + x*Nz>

   (21) v1> = Include( v>,  a )
-> (22) v1> = a*sin(b)*Nx> + a*cos(b)*Ny>

   (23) v2> = Include( v>,  c )
-> (24) v2> = c*cos(b)*Ny>

   (25) v3> = Include( v>,  [c, x] )
-> (26) v3> = c*cos(b)*Ny> + x*Nz>

   (27) %--------------------------------------------------------------------
   (28) % Example 3: Include  (matrix expressions)
   (29) %--------------------------------------------------------------------
   (30) Constant  b1, b2, b3
   (31) Variable  x1, x2, x3
   (32) Zero[1] = 2*x1 + 3*x2 + 4*x3 - b1
-> (33) Zero[1] = 2*x1 + 3*x2 + 4*x3 - b1

   (34) Zero[2] = 3*x1 + 4*x2 + 5*x3 - b2
-> (35) Zero[2] = 3*x1 + 4*x2 + 5*x3 - b2

   (36) Zero[3] = 6*x1 + 7*x2 + 9*x3 - b3
-> (37) Zero[3] = 6*x1 + 7*x2 + 9*x3 - b3

   (38) x12PartOfMatrix = Include( Zero,  x1, x2 ) 
-> (39) x12PartOfMatrix = [2*x1 + 3*x2;  3*x1 + 4*x2;  6*x1 + 7*x2]



</PRE><nobr><a name="GetAcceleration"><font color="darkBlue"><font size=+1><b>GetAcceleration</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetAcceleration  or  GetRelativeAcceleration

 Purpose:  Gets a point's acceleration in a reference frame or gets a point's
           acceleration relative to another point in a reference frame.

Syntax 1:  Q.GetAcceleration( refFrame )
Syntax 2:  Q.GetAccelerationRelative( P, refFrame )
           Q.GetRelativeAcceleration( P, refFrame )

   Input:  Q, P -- names of points (e.g., Point or Particle).
           refFrame -- name of a RigidFrame or RigidBody..

Output 1:  Returns Q's acceleration in refFrame.
Output 2:  Returns Q's acceleration relative to P in refFrame, defined as
           Q.GetAcceleration(refFrame) - P.GetAcceleration(refFrame) or as
           DtDt( Q.GetPosition(P), refFrame ).

 Related:  <a href="#Translate"><b>Translate</b></a>        <a href="#SetPositionVelocity"><b>SetPositionVelocity</b></a>        <a href="#SetVelocityAcceleration"><b>SetVelocityAcceleration</b></a>
           <a href="#SetPosition"><b>SetPosition</b></a>      <a href="#GetPosition"><b>GetPosition</b></a>   <a href="#GetDistance"><b>GetDistance</b></a>  <a href="#GetElongation"><b>GetElongation</b></a>
           <a href="#SetVelocity"><b>SetVelocity</b></a>      <a href="#GetVelocity"><b>GetVelocity</b></a>   <a href="#GetSpeed"><b>GetSpeed</b></a>     <a href="#GetVelocity"><b>GetRelativeVelocity</b></a>
           <a href="#SetAcceleration"><b>SetAcceleration</b></a>  <a href="#GetAcceleration"><b>GetAcceleration</b></a>            <a href="#GetAcceleration"><b>GetRelativeAcceleration</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: GetAcceleration 
   (3) %--------------------------------------------------------------------
   (4) RigidFrame N
   (5) Point      Q            
   (6) Variable   vx', vy'
   (7) Q.SetAcceleration( N, vx'*Nx> + vy'*Ny> )
-> (8) a_Q_N> = vx'*Nx> + vy'*Ny>

   (9) QAccelerationInN> = Q.GetAcceleration( N )   
-> (10) QAccelerationInN> = vx'*Nx> + vy'*Ny>

   (11) %--------------------------------------------------------------------
   (12) % Example: GetRelativeAcceleration
   (13) %--------------------------------------------------------------------
   (14) Point       P            
   (15) Variable    x'', y''
   (16) P.SetAcceleration( N,  x''*Nx> + y''*Ny> )
-> (17) a_P_N> = x''*Nx> + y''*Ny>

   (18) aQRelativeToP> = Q.GetRelativeAcceleration( P, N )
-> (19) aQRelativeToP> = (vx'-x'')*Nx> + (vy'-y'')*Ny>

   (20) %--------------------------------------------------------------------
   (21) % Example: GetRelativeAcceleration  (via differentiation).
   (22) %--------------------------------------------------------------------
   (23) Point       S            
   (24) S.SetPosition( P,  t^2*Nx> + t^3*Ny> )
-> (25) p_P_S> = t^2*Nx> + t^3*Ny>

   (26) aSRelativeToP> = S.GetRelativeAcceleration( P, N )
-> (27) aSRelativeToP> = 2*Nx> + 6*t*Ny>



</PRE><nobr><a name="GetAngleBetweenVectors"><font color="darkBlue"><font size=+1><b>GetAngleBetweenVectors</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetAngleBetweenVectors   GetAngleBetweenUnitVectors

 Purpose:  Forms the angle between two vectors.

Syntax 1:  GetAngleBetweenVectors(        v>, w>  )
           GetAngleBetweenVectorsDegrees( v>, w>  )
Syntax 2:  GetAngleBetweenVectors(        v>, w>, senseVector>  )
           GetAngleBetweenVectorsDegrees( v>, w>, senseVector>  )
Syntax 3:  GetAngleBetweenUnitVectors(        uvec1>, uvec2>  )
           GetAngleBetweenUnitVectorsDegrees( uvec1>, uvec2>  )
Syntax 4:  GetAngleBetweenUnitVectors(        uvec1>, uvec2>, senseVector> )
           GetAngleBetweenUnitVectorsDegrees( uvec1>, uvec2>, senseVector> )

  Inputs:  v>,  w> -- vectors.
           uvec1>,  uvec2> -- unit vectors.
           senseVector>  -- a vector providing a positive sense.

Output 1:  Angle between  v>  and  w>          with range   0  <= Angle <= pi.
Output 2:  Angle from     v>  to   w>          with range  -pi <  Angle <= pi.
Output 3:  Angle between  uvec1>  and  uvec2>  with range   0  <= Angle <= pi.
Output 4:  Angle from     uvec1>  to   uvec2>  with range  -pi <  Angle <= pi.

  Remark:  "Degrees" variant of commands multiply return values by 180/pi.
           Use return value with caution as the default units for angles
           are in radians for this program and C, MATLAB, FORTRAN, ...

  Remark:  A negative angle can result if a senseVector> is provided and
           the cross-product of v> and w> has a negative projection onto
           senseVector>, otherwise it is 0 or positive.

 Related:  <a href="#GetMagnitude"><b>GetMagnitude</b></a>           <a href="#GetMagnitude"><b>GetMagnitudeSquared</b></a>
           <a href="#GetDistance"><b>GetDistance</b></a>            <a href="#GetDistance"><b>GetDistanceSquared</b></a>
           <a href="#GetSpeed"><b>GetSpeed</b></a>               <a href="#GetSpeed"><b>GetSpeedSquared</b></a>
           <a href="#GetAngularSpeed"><b>GetAngularSpeed</b></a>        <a href="#GetAngularSpeed"><b>GetAngularSpeedSquared</b></a>
           <a href="#GetAngleBetweenVectors"><b>GetAngleBetweenVectors</b></a> <a href="#GetAngleBetweenVectors"><b>GetAngleBetweenUnitVectors</b></a>   <a href="#ConvertUnits"><b>ConvertUnits</b></a>
           <a href="#GetUnitVector"><b>GetUnitVector</b></a>          <a href="#Vector"><b>Vector</b></a>   <a href="#Cross"><b>Dot</b></a>   <a href="#Rotate"><b>Rotate</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetAngleBetweenVectors 
   (3) %--------------------------------------------------------------------
   (4) RigidFrame A
   (5) v> = 2*Ax> + 3*Ay> + 4*Az>
-> (6) v> = 2*Ax> + 3*Ay> + 4*Az>

   (7) w> = 7*Ax> + 5*Ay> + 3*Az>
-> (8) w> = 7*Ax> + 5*Ay> + 3*Az>

   (9) thetaRadians = GetAngleBetweenVectors( v>, w> )
-> (10) thetaRadians = 0.5814062

   (11) thetaDegrees = GetAngleBetweenVectorsDegrees( v>, w> ) 
-> (12) thetaDegrees = 33.31212

   (13) thetaNegative = GetAngleBetweenVectors( v>, w>, Ax> )
-> (14) thetaNegative = -0.5814062

   (15) %--------------------------------------------------------------------
   (16) % Example 2: GetAngleBetweenVectors  (with sense)
   (17) %--------------------------------------------------------------------
   (18) f> = Ax> + 2*Ay>
-> (19) f> = Ax> + 2*Ay>

   (20) g> = Ax> + t*Ay>
-> (21) g> = Ax> + t*Ay>

   (22) theta = GetAngleBetweenVectors( f>, g> )
-> (23) theta = acos(0.4472136*(1+2*t)/sqrt(1+t^2))

   (24) thetaWithSense = GetAngleBetweenVectors( f>, g>, Az> )
-> (25) thetaWithSense = sign0IsPositive1(-2+t)*acos(0.4472136*(1+2*t)/sqrt(1+t^2))

   (26) %--------------------------------------------------------------------
   (27) % Example 3: GetAngleBetweenUnitVectors  
   (28) %--------------------------------------------------------------------
   (29) unitVector1> = Vector( A, 0.6, 0.8, 0 )
-> (30) unitVector1> = 0.6*Ax> + 0.8*Ay>

   (31) unitVector2> = Vector( A, 0,   0.6, 0.8 )
-> (32) unitVector2> = 0.6*Ay> + 0.8*Az>

   (33) angleRadians = GetAngleBetweenUnitVectors( unitVector1>, unitVector2> )
-> (34) angleRadians = 1.070142

   (35) angleDegrees = GetAngleBetweenUnitVectorsDegrees( unitVector1>, unitVector2> )
-> (36) angleDegrees = 61.3146

   (37) %--------------------------------------------------------------------
   (38) % Example 4: GetAngleBetweenUnitVectors  (with sense)
   (39) %--------------------------------------------------------------------
   (40) RigidFrame B
   (41) B.SetRotationMatrixZ( A, t )
-> (42) B_A = [cos(t), sin(t), 0;  -sin(t), cos(t), 0;  0, 0, 1]

   (43) angleWithSense = GetAngleBetweenUnitVectors( Bx>, unitVector2>, Az> )
-> (44) angleWithSense = sign0IsPositive1(0.6*cos(t))*acos(0.6*sin(t))



</PRE><nobr><a name="GetAngularAcceleration"><font color="darkBlue"><font size=+1><b>GetAngularAcceleration</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetAngularAcceleration

 Purpose:  Gets a rigid frame/body's angular acceleration in a reference frame.

  Syntax:  B.GetAngularAcceleration( A )

   Input:  B, A -- names of a RigidFrame or RigidBody.

  Output:  Returns B's angular acceleration in A.

 Related:  <a href="#GetAngularAcceleration"><b>GetAngularAcceleration</b></a>  <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>  <a href="#GetRotationMatrix"><b>GetRotationMatrix</b></a>
           <a href="#SetAngularAcceleration"><b>SetAngularAcceleration</b></a>  <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>  <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: GetAngularAcceleration 
   (3) %--------------------------------------------------------------------
   (4) RigidFrame N             
   (5) RigidBody  B
   (6) Variable   wx', wy', wz'
   (7) B.SetAngularAcceleration( N, wx'*Bx> + wy'*By> + wz'*Bz> )
-> (8) alf_B_N> = wx'*Bx> + wy'*By> + wz'*Bz>

   (9) BAngularAccelerationInN> = B.GetAngularAcceleration( N )
-> (10) BAngularAccelerationInN> = wx'*Bx> + wy'*By> + wz'*Bz>



</PRE><nobr><a name="GetAngularMomentum"><font color="darkBlue"><font size=+1><b>GetAngularMomentum</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetAngularMomentum

 Purpose:  Calculates an object's angular momentum about a point.

Syntax 1:  Object.GetAngularMomentum( aboutPoint )
Syntax 2:  Object.GetAngularMomentum( aboutPoint, refFrame )

   Input:  Object -- name of a Particle, RigidBody, or System.
           aboutPoint -- name of a point.
           refFrame -- name of a RigidFrame or RigidBody.

Output 1:  Object's angular momentum abointPoint in the NewtonianFrame.
Output 2:  Object's angular momentum abointPoint in refFrame.

  Remark:  A particle Q's angular momentum aboutPoint P in refFrame is defined
           Cross( Q.GetPosition(P), Q.GetTranslationalMomentum(refFrame) )

 Related:  <a href="#GetAngularMomentum"><b>GetAngularMomentum</b></a>  <a href="#GetTranslationalMomentum"><b>GetTranslationalMomentum</b></a>  <a href="#GetGeneralizedMomentum"><b>GetGeneralizedMomentum</b></a>
           <a href="#GetKineticEnergy"><b>GetKineticEnergy</b></a>    <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetAngularMomentum  (point moving in a plane)
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N             
   (5) Particle       Q   
   (6) Q.SetMass( mQ )
   (7) Variable       x'', y''
   (8) Q.Translate( No, x*Nx> + y*Ny> )
-> (9) p_No_Q> = x*Nx> + y*Ny>
-> (10) v_Q_N> = x'*Nx> + y'*Ny>
-> (11) a_Q_N> = x''*Nx> + y''*Ny>

   (12) QAngularMomentumAboutNo> = Q.GetAngularMomentum( No )
-> (13) QAngularMomentumAboutNo> = mQ*(x*y'-y*x')*Nz>

   (14) %--------------------------------------------------------------------
   (15) % Example 2: GetAngularMomentum  (rotating rigid body)
   (16) %--------------------------------------------------------------------
   (17) RigidBody  B  
   (18) B.SetMass( mB )
   (19) B.SetInertia( Bcm, Ixx, Iyy, Izz )
   (20) Variable   theta''
   (21) B.RotateZ( N, theta )
-> (22) B_N = [cos(theta), sin(theta), 0;  -sin(theta), cos(theta), 0;  0, 0, 1]
-> (23) w_B_N> = theta'*Bz>
-> (24) alf_B_N> = theta''*Bz>

   (25) BAngularMomentumAboutBcm> = B.GetAngularMomentum( Bcm )
-> (26) BAngularMomentumAboutBcm> = Izz*theta'*Bz>

   (27) %--------------------------------------------------------------------
   (28) % Example 3: GetAngularMomentum  (rotating/translating rigid body)
   (29) %--------------------------------------------------------------------
   (30) Bcm.Translate( No, x*Nx> + y*Ny> )
-> (31) p_No_Bcm> = x*Nx> + y*Ny>
-> (32) v_Bcm_N> = x'*Nx> + y'*Ny>
-> (33) a_Bcm_N> = x''*Nx> + y''*Ny>

   (34) BAngularMomentumAboutNo> = B.GetAngularMomentum( No )
-> (35) BAngularMomentumAboutNo> = (Izz*theta'+mB*(x*y'-y*x'))*Bz>



</PRE><nobr><a name="GetAngularSpeed"><font color="darkBlue"><font size=+1><b>GetAngularSpeed</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetAngularSpeed  and   GetAngularSpeedSquared

 Purpose:  Gets a rigid frame/body's angular speed in a reference frame.

Syntax 1:  B.GetAngularSpeed( A )
Syntax 2:  B.GetAngularSpeedSquared( A )

   Input:  B, A -- names of a RigidFrame or RigidBody.

Output 1:  Magnitude of B's angular velocity in A.
Output 2:  Square of the magnitude of B's angular velocity in A.

 Related:  <a href="#GetMagnitude"><b>GetMagnitude</b></a>           <a href="#GetMagnitude"><b>GetMagnitudeSquared</b></a>
           <a href="#GetDistance"><b>GetDistance</b></a>            <a href="#GetDistance"><b>GetDistanceSquared</b></a>
           <a href="#GetSpeed"><b>GetSpeed</b></a>               <a href="#GetSpeed"><b>GetSpeedSquared</b></a>
           <a href="#GetAngularSpeed"><b>GetAngularSpeed</b></a>        <a href="#GetAngularSpeed"><b>GetAngularSpeedSquared</b></a>
           <a href="#GetAngleBetweenVectors"><b>GetAngleBetweenVectors</b></a> <a href="#GetAngleBetweenVectors"><b>GetAngleBetweenUnitVectors</b></a>
           <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>     <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>       <a href="#Rotate"><b>Rotate</b></a>
           <a href="#GetUnitVector"><b>GetUnitVector</b></a>          <a href="#Vector"><b>Vector</b></a>   <a href="#Cross"><b>Dot</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: GetAngularSpeed  and  GetAngularSpeedSquared
   (3) %--------------------------------------------------------------------
   (4) RigidFrame A, B
   (5) Variable   wx, wy
   (6) B.SetAngularVelocity( A, wx*Ax> + wy*Ay> )
-> (7) w_B_A> = wx*Ax> + wy*Ay>

   (8) angularSpeed = B.GetAngularSpeed( A ) 
-> (9) angularSpeed = sqrt(wx^2+wy^2)

   (10) angularSpeedSquared = B.GetAngularSpeedSquared( A )  
-> (11) angularSpeedSquared = wx^2 + wy^2



</PRE><nobr><a name="GetAngularVelocity"><font color="darkBlue"><font size=+1><b>GetAngularVelocity</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetAngularVelocity

 Purpose:  Gets a rigid frame/body's angular velocity in a reference frame.

  Syntax:  B.GetAngularVelocity( A )

   Input:  B, A -- names of a RigidFrame or RigidBody.

  Output:  Returns B's angular velocity in A.

 Related:  <a href="#GetAngularAcceleration"><b>GetAngularAcceleration</b></a>  <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>  <a href="#GetRotationMatrix"><b>GetRotationMatrix</b></a>
           <a href="#SetAngularAcceleration"><b>SetAngularAcceleration</b></a>  <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>  <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: GetAngularVelocity 
   (3) %--------------------------------------------------------------------
   (4) RigidFrame N             
   (5) RigidBody  A, B
   (6) Variable   wx, wy, wz,  w1, w2, w3
   (7) A.SetAngularVelocity( N, wx*Ax> + wy*Ay> + wz*Az> )
-> (8) w_A_N> = wx*Ax> + wy*Ay> + wz*Az>

   (9) B.SetAngularVelocity( A, w1*Ax> + w2*Ay> + w3*Az> )
-> (10) w_B_A> = w1*Ax> + w2*Ay> + w3*Az>

   (11) BAngularVelocityInN> = B.GetAngularVelocity( N )
-> (12) BAngularVelocityInN> = (w1+wx)*Ax> + (w2+wy)*Ay> + (w3+wz)*Az>

   (13) %--------------------------------------------------------------------
   (14) % Example: GetAngularVelocity (via RigidFrame C fixed to RigidBody B).
   (15) %--------------------------------------------------------------------
   (16) RigidFrame C( B )
   (17) CAngularVelocityInB> = C.GetAngularVelocity( B )
-> (18) CAngularVelocityInB> = 0>

   (19) CAngularVelocityInA> = C.GetAngularVelocity( A )
-> (20) CAngularVelocityInA> = w1*Ax> + w2*Ay> + w3*Az>

   (21) CAngularVelocityInN> = C.GetAngularVelocity( N )
-> (22) CAngularVelocityInN> = (w1+wx)*Ax> + (w2+wy)*Ay> + (w3+wz)*Az>



</PRE><nobr><a name="GetBasisVector"><font color="darkBlue"><font size=+1><b>GetBasisVector</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetBasisVector

 Purpose:  Returns a unit vector that was created when a RigidBody
           RigidFrame, or NewtonianFrame declaration was issued

  Syntax:  GetBasisVector( frameName, int123 )

   Input:  frameName -- name of a RigidFrame or RigidBody.
           int123 -- the number 1 or 2 or 3.

  Remark:  GetBasisVector is mostly used in .r and .a files.

 Related:  <a href="#GetBasisVector"><b>GetBasisVector</b></a>  <a href="#GetDefaults"><b>GetDefaults</b></a>  <a href="#SetBasisSubscripts"><b>SetBasisSubscripts</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  GetBasisVector (default basis subscripts)
   (3) %--------------------------------------------------------------------
   (4) RigidBody A
   (5) AfirstBasisVector> := GetBasisVector( A, 1 )
-> (6) AfirstBasisVector> = Ax>

   (7) AthirdBasisVector> := GetBasisVector( A, 3 )
-> (8) AthirdBasisVector> = Az>

   (9) %--------------------------------------------------------------------
   (10) % Example 2:  GetBasisVector (vary basis subscripts)
   (11) %--------------------------------------------------------------------
   (12) SetBasisSubscripts( 1,2,3 )
   (13) AfirstBasisVector> := GetBasisVector( A, 1 )
-> (14) AfirstBasisVector> = A1>

   (15) AthirdBasisVector> := GetBasisVector( A, 3 )
-> (16) AthirdBasisVector> = A3>

   (17) %--------------------------------------------------------------------
   (18) % Example 3:  GetBasisVector (vary basis subscripts again)
   (19) %--------------------------------------------------------------------
   (20) SetBasisSubscripts( i,j,k )
   (21) AfirstBasisVector> := GetBasisVector( A, 1 )
-> (22) AfirstBasisVector> = Ai>

   (23) AthirdBasisVector> := GetBasisVector( A, 3 )
-> (24) AthirdBasisVector> = Ak>



</PRE><nobr><a name="GetCharge"><font color="darkBlue"><font size=+1><b>GetCharge</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetCharge

 Purpose:  Gets the charge on an object.

  Syntax:  Object.GetCharge()

   Input:  Object -- The name of a point or particle.

  Output:  Returns the charge on Object.

 Related:  <a href="#GetCharge"><b>GetCharge</b></a>  <a href="#GetMass"><b>GetMass</b></a>  <a href="#SetCharge"><b>SetCharge</b></a>  <a href="#SetMass"><b>SetMass</b></a>
           <a href="#AddForceElectrostatic"><b>AddForceElectrostatic</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: GetCharge
   (3) %--------------------------------------------------------------------
   (4) Point   P, Q             
   (5) P.SetCharge( 17 )   
   (6) Q.SetCharge( cQ ) 
   (7) chargeOnPAndQ = P.GetCharge() + Q.GetCharge()
-> (8) chargeOnPAndQ = 17 + cQ



</PRE><nobr><a name="GetCmAcceleration"><font color="darkBlue"><font size=+1><b>GetCmAcceleration</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetCmAcceleration

 Purpose:  Gets a system's center of mass acceleration in a reference frame.

  Syntax:  S.GetCmVelocity( refFrame )

   Input:  S -- the name of a System (which may be a RigidBody or Particle).
           refFrame -- the name of a RigidFrame or RigidBody.
           If the refFrame argument is missing, the NewtonianFrame is assumed.

  Output:  The acceleration of S's center of mass in refFrame.

 Related:  <a href="#SetMass"><b>SetMass</b></a>          <a href="#GetMass"><b>GetMass</b></a>         <a href="#SetInertia"><b>SetInertia</b></a>
           <a href="#GetCMPosition"><b>GetCMPosition</b></a>    <a href="#GetCMVelocity"><b>GetCmVelocity</b></a>   <a href="#GetCMAcceleration"><b>GetCmAcceleration</b></a>
           <a href="#Translate"><b>Translate</b></a>        <a href="#SetPositionVelocity"><b>SetPositionVelocity</b></a>   <a href="#SetVelocityAcceleration"><b>SetVelocityAcceleration</b></a>
           <a href="#SetPosition"><b>SetPosition</b></a>      <a href="#GetPosition"><b>GetPosition</b></a>     <a href="#GetDistance"><b>GetDistance</b></a>
           <a href="#SetVelocity"><b>SetVelocity</b></a>      <a href="#GetVelocity"><b>GetVelocity</b></a>     <a href="#GetSpeed"><b>GetSpeed</b></a>   <a href="#GetElongation"><b>GetElongation</b></a>
           <a href="#SetAcceleration"><b>SetAcceleration</b></a>  <a href="#GetAcceleration"><b>GetAcceleration</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetCmAcceleration  (center of mass of rigid body)
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N   
   (5) RigidBody  B 
   (6) B.SetMass( mB )
   (7) Variable   xB'', yB''
   (8) Bcm.Translate( No, xB*Nx> + yB*Ny> )
-> (9) p_No_Bcm> = xB*Nx> + yB*Ny>
-> (10) v_Bcm_N> = xB'*Nx> + yB'*Ny>
-> (11) a_Bcm_N> = xB''*Nx> + yB''*Ny>

   (12) BCmAccelerationInN> = B.GetCmAcceleration( N )
-> (13) BCmAccelerationInN> = xB''*Nx> + yB''*Ny>

   (14) %--------------------------------------------------------------------
   (15) % Example 2: GetCmAcceleration  (center of mass of system)
   (16) %--------------------------------------------------------------------
   (17) Particle   P
   (18) P.SetMass( mP )
   (19) Variable   xP'', yP''
   (20) P.Translate( No, xP*Nx> + yP*Ny> )
-> (21) p_No_P> = xP*Nx> + yP*Ny>
-> (22) v_P_N> = xP'*Nx> + yP'*Ny>
-> (23) a_P_N> = xP''*Nx> + yP''*Ny>

   (24) SystemCmAccelerationInN> = System.GetCmAcceleration( N )
-> (25) SystemCmAccelerationInN> = (mB*xB''+mP*xP'')/(mB+mP)*Nx> + (mB*yB''+mP*
        yP'')/(mB+mP)*Ny>



</PRE><nobr><a name="GetCmPosition"><font color="darkBlue"><font size=+1><b>GetCmPosition</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetCmPosition

 Purpose:  Gets a system's center of mass position from another point.

  Syntax:  S.GetCmPosition( fromPoint )

   Input:  S -- the name of a System (which may be a RigidBody or Particle).
           fromPoint -- name of a point.

  Output:  The position vector of S's center of mass from fromPoint.

 Remark:   The following are used for the GetCMPosition command:
           (a) the mass of each relevant particle and/or body
           (b) the position vector fromPoint to each particle
           (c) the position vector fromPoint to the mass center of each body.

 Related:  <a href="#SetMass"><b>SetMass</b></a>          <a href="#GetMass"><b>GetMass</b></a>         <a href="#SetInertia"><b>SetInertia</b></a>
           <a href="#GetCMPosition"><b>GetCMPosition</b></a>    <a href="#GetCMVelocity"><b>GetCmVelocity</b></a>   <a href="#GetCMAcceleration"><b>GetCmAcceleration</b></a>
           <a href="#Translate"><b>Translate</b></a>        <a href="#SetPositionVelocity"><b>SetPositionVelocity</b></a>   <a href="#SetVelocityAcceleration"><b>SetVelocityAcceleration</b></a>
           <a href="#SetPosition"><b>SetPosition</b></a>      <a href="#GetPosition"><b>GetPosition</b></a>   <a href="#GetDistance"><b>GetDistance</b></a>
           <a href="#SetVelocity"><b>SetVelocity</b></a>      <a href="#GetVelocity"><b>GetVelocity</b></a>   <a href="#GetSpeed"><b>GetSpeed</b></a>   <a href="#GetElongation"><b>GetElongation</b></a>
           <a href="#SetAcceleration"><b>SetAcceleration</b></a>  <a href="#GetAcceleration"><b>GetAcceleration</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetCmPosition  (center of mass of rigid body)
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N   
   (5) RigidBody  B 
   (6) B.SetMass( mB )
   (7) Variable   xB, yB
   (8) Bcm.SetPosition( No, xB*Nx> + yB*Ny> )
-> (9) p_No_Bcm> = xB*Nx> + yB*Ny>

   (10) BCmPositionFromNo> = B.GetCmPosition( No )
-> (11) BCmPositionFromNo> = xB*Nx> + yB*Ny>

   (12) %--------------------------------------------------------------------
   (13) % Example 2: GetCmPosition  (center of mass of system)
   (14) %--------------------------------------------------------------------
   (15) Particle   P
   (16) P.SetMass( mP )
   (17) Variable   xP, yP
   (18) P.SetPosition( No, xP*Nx> + yP*Ny> )
-> (19) p_No_P> = xP*Nx> + yP*Ny>

   (20) SystemCmPositionFromNo> = System.GetCmPosition( No )
-> (21) SystemCmPositionFromNo> = (mB*xB+mP*xP)/(mB+mP)*Nx> + (mB*yB+mP*yP)/(
        mB+mP)*Ny>



</PRE><nobr><a name="GetCmVelocity"><font color="darkBlue"><font size=+1><b>GetCmVelocity</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetCmVelocity

 Purpose:  Gets a system's center of mass velocity in a reference frame.

  Syntax:  S.GetCmVelocity( refFrame )

   Input:  S -- the name of a System (which may be a RigidBody or Particle).
           refFrame -- the name of a RigidFrame or RigidBody.
           If the refFrame argument is missing, the NewtonianFrame is assumed.

  Output:  The velocity of S's center of mass in refFrame.

 Related:  <a href="#SetMass"><b>SetMass</b></a>          <a href="#GetMass"><b>GetMass</b></a>         <a href="#SetInertia"><b>SetInertia</b></a>
           <a href="#GetCMPosition"><b>GetCMPosition</b></a>    <a href="#GetCMVelocity"><b>GetCmVelocity</b></a>   <a href="#GetCMAcceleration"><b>GetCmAcceleration</b></a>
           <a href="#Translate"><b>Translate</b></a>        <a href="#SetPositionVelocity"><b>SetPositionVelocity</b></a>   <a href="#SetVelocityAcceleration"><b>SetVelocityAcceleration</b></a>
           <a href="#SetPosition"><b>SetPosition</b></a>      <a href="#GetPosition"><b>GetPosition</b></a>   <a href="#GetDistance"><b>GetDistance</b></a>
           <a href="#SetVelocity"><b>SetVelocity</b></a>      <a href="#GetVelocity"><b>GetVelocity</b></a>   <a href="#GetSpeed"><b>GetSpeed</b></a>   <a href="#GetElongation"><b>GetElongation</b></a>
           <a href="#SetAcceleration"><b>SetAcceleration</b></a>  <a href="#GetAcceleration"><b>GetAcceleration</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetCmVelocity  (center of mass of rigid body)
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N   
   (5) RigidBody  B 
   (6) B.SetMass( mB )
   (7) Variable   xB', yB'
   (8) Bcm.SetVelocity( N, xB'*Nx> + yB'*Ny> )
-> (9) v_Bcm_N> = xB'*Nx> + yB'*Ny>

   (10) BCmVelocityInN> = B.GetCmVelocity( N )
-> (11) BCmVelocityInN> = xB'*Nx> + yB'*Ny>

   (12) %--------------------------------------------------------------------
   (13) % Example 2: GetCmVelocity  (center of mass of system)
   (14) %--------------------------------------------------------------------
   (15) Particle   P
   (16) P.SetMass( mP )
   (17) Variable   xP', yP'
   (18) P.SetVelocity( N, xP'*Nx> + yP'*Ny> )
-> (19) v_P_N> = xP'*Nx> + yP'*Ny>

   (20) SystemCmVelocityInN> = System.GetCmVelocity( N )
-> (21) SystemCmVelocityInN> = (mB*xB'+mP*xP')/(mB+mP)*Nx> + (mB*yB'+mP*yP')/(
        mB+mP)*Ny>



</PRE><nobr><a name="GetCoefficient"><font color="darkBlue"><font size=+1><b>GetCoefficient</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetCoefficient    GetCoefficientShallow

 Purpose:  Gets the coefficient of a name or names in an expression.

Syntax 1:  GetCoefficient(        ExpressionY, X )
Syntax 2:  GetCoefficientShallow( ExpressionY, X )

   Input:  ExpressionY -- an expression or matrix of expressions.

           X -- a name that appears linearly in ExpressionY or a
           one-dimensional (row/column) matrix of names that
           appear linearly in ExpressionY.

Output 1:  Does a deep recursive examination of ExpressionY, searching for
           any  X  that appears directly or indirectly in  ExpressionY.

Output 2:  GetCoefficientShallow  does a shallow non-recursive search for
           any  X  that appears directly in  ExpressionY.
           Does not examine the right-hand-side of any symbol appearing
           in ExpressionY to see if it may contain X, i.e., ignores
           assignments made to symbols appearing in ExpressionY.

  Remark:  GetCoefficientShallow is Autolev compatible.
           With SetDefaults( AUTOLEV ), the command  Coef  is interpreted as
           GetCoefficientShallow, otherwise it is interpreted GetCoefficient.

  Remark:  Returns an expression or matrix of expressions (depends on whether
           ExpressionY and X are expressions or matrices of expressions).

 Related:  <a href="#D"><b>D</b></a>  <a href="#Include"><b>Include</b></a>  <a href="#Exclude"><b>Exclude</b></a>  <a href="#GetCoefficient"><b>GetCoefficient</b></a> <a href="#GetCoefficient"><b>GetCoefficientShallow</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetCoefficient  (Scalar expression, scalar name)
   (3) %--------------------------------------------------------------------
   (4) Variable  x, y
   (5) Expression = t*x - 2*y
-> (6) Expression = t*x - 2*y

   (7) coefX = GetCoefficient( Expression,  x )
-> (8) coefX = t

   (9) coefY = GetCoefficient( Expression,  y )
-> (10) coefY = -2

   (11) %--------------------------------------------------------------------
   (12) % Example 2: GetCoefficient  (Scalar expression, matrix of names)
   (13) %--------------------------------------------------------------------
   (14) CoefTY = GetCoefficient( Expression,  t, y )
-> (15) CoefTY = [x;  -2]

   (16) CoefXY = GetCoefficient( Expression,  [x;y] )
-> (17) CoefXY = [t;  -2]

   (18) %--------------------------------------------------------------------
   (19) % Example 3: GetCoefficient  (Matrix expression, scalar name)
   (20) %--------------------------------------------------------------------
   (21) Zero[1] = sin(t)*x - cos(t)*y
-> (22) Zero[1] = sin(t)*x - cos(t)*y

   (23) Zero[2] = cos(t)*x - 3*t^2*y
-> (24) Zero[2] = cos(t)*x - 3*t^2*y

   (25) Fred = GetCoefficient( Zero,  x )
-> (26) Fred = [sin(t);  cos(t)]

   (27) Joe  = GetCoefficient( Zero,  y )
-> (28) Joe = [-cos(t);  -3*t^2]

   (29) %--------------------------------------------------------------------
   (30) % Example 4: GetCoefficient  (Matrix expression, matrix of names)
   (31) %--------------------------------------------------------------------
   (32) Sally = GetCoefficient( Zero,  x, y )
-> (33) Sally = [sin(t), -cos(t);  cos(t), -3*t^2]

   (34) Susan = GetCoefficient( Zero,  [x,y] )
-> (35) Susan = [sin(t), -cos(t);  cos(t), -3*t^2]

   (36) %--------------------------------------------------------------------
   (37) % Example 5: GetCoefficientShallow  (Scalar expression, scalar name)
   (38) %--------------------------------------------------------------------
   (39) shallowCoefX1 = GetCoefficientShallow(        Expression,   x )
-> (40) shallowCoefX1 = 0

   (41) shallowCoefX2 = GetCoefficientShallow( GetRhs(Expression),  x )
-> (42) shallowCoefX2 = t

   (43) shallowCoefX3 = GetCoefficientShallow(      x*Expression,   x )
-> (44) shallowCoefX3 = Expression

   (45) shallowCoefY1 = GetCoefficientShallow(        Expression,   y )
-> (46) shallowCoefY1 = 0

   (47) shallowCoefY2 = GetCoefficientShallow( GetRhs(Expression),  y )
-> (48) shallowCoefY2 = -2

   (49) shallowCoefE1 = GetCoefficientShallow(   Expression,  Expression )
-> (50) shallowCoefE1 = 1

   (51) shallowCoefE2 = GetCoefficientShallow( x*Expression,  Expression )
-> (52) shallowCoefE2 = x



</PRE><nobr><a name="GetColumns"><font color="darkBlue"><font size=+1><b>GetColumns</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetRows    or    GetColumns

 Purpose:  Reports the number of rows or columns of a matrix.
           Creates a matrix from designated rows or columns of a matrix.

Syntax 1:     GetRows( mat )
Syntax 2:  GetColumns( mat )
Syntax 3:     GetRows( mat,  i, j, k,  n:m,  ... )
Syntax 4:  GetColumns( mat,  i, j, k,  n:m,  ... )

   Input:  mat     -- a matrix or matrix expression.
           i, j, k -- positive integers.
           n:m     -- A range of positive integers from n to m.

  Remark:  i, j, k, n, m must be positive integers that are less than or
           equal to the number of rows (or columns) in the matrix mat.
           n may be larger, smaller, or equal to m.

Output 1:  Number of rows    in mat.
Output 2:  Number of columns in mat.
Output 3:  Matrix whose rows    are the i, j, n:m rows    of mat.
Output 4:  Matrix whose columns are the i, j, n:m columns of mat.

  Remark:  To select one element of mat, use e.g., mat[ 2, 3 ].
           For a submatrix, use mat[ 2:3, 1:5 ].  See HELP [].

 Related:  <a href="#GetColumns"><b>GetColumns</b></a>     <a href="#GetDeterminant"><b>GetDeterminant</b></a>  <a href="#GetDiagonalMatrix"><b>GetDiagonalMatrix</b></a>  <a href="#GetEigen"><b>GetEigen</b></a>
           <a href="#GetElement"><b>GetElement</b></a> <a href="#[]"><b>[]</b></a>  <a href="#GetInverse"><b>GetInverse</b></a>      <a href="#GetIdentityMatrix"><b>GetIdentityMatrix</b></a>  <a href="#GetNorm"><b>GetNorm</b></a>  <a href="#GetColumns"><b>GetRows</b></a>
           <a href="#GetTrace"><b>GetTrace</b></a>       <a href="#GetTranspose"><b>GetTranspose</b></a>    <a href="#GetIdentityMatrix"><b>GetZeroMatrix</b></a>      <a href="#Solve"><b>Solve</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetRows  or  GetColumns  (number of rows or columns in a matrix)
   (3) %--------------------------------------------------------------------
   (4) M = [1, 2, 3, 4;  5, 6, 7, 8;  9, 10, 11, 12]
-> (5) M = [1, 2, 3, 4;  5, 6, 7, 8;  9, 10, 11, 12]

   (6) numberOfRows = GetRows( M )
-> (7) numberOfRows = 3

   (8) numberOfColumns = GetColumns( M )
-> (9) numberOfColumns = 4

   (10) %--------------------------------------------------------------------
   (11) % Example 2: GetRows  or  GetColumns  (designated rows or columns in a matrix)
   (12) %--------------------------------------------------------------------
   (13) Rows3And1OfM = GetRows( M,  3,1 )
-> (14) Rows3And1OfM = [9, 10, 11, 12;  1, 2, 3, 4]

   (15) Columns3And1OfM = GetColumns( M,  4,1 )
-> (16) Columns3And1OfM = [4, 1;  8, 5;  12, 9]

   (17) %--------------------------------------------------------------------
   (18) % Example 3: GetRows  or  GetColumns  (range of rows or columns in a matrix)
   (19) %--------------------------------------------------------------------
   (20) RangeOfRowsOfM = GetRows( M,  1:2 )
-> (21) RangeOfRowsOfM = [1, 2, 3, 4;  5, 6, 7, 8]

   (22) RangeOfColumnsOfM = GetColumns( M,  2:3, 3:2 )
-> (23) RangeOfColumnsOfM = [2, 3, 3, 2;  6, 7, 7, 6;  10, 11, 11, 10]

   (24) %--------------------------------------------------------------------
   (25) % Example 4: GetRows  or  GetColumns  (submatrix)
   (26) %--------------------------------------------------------------------
   (27) Submatrix1 = M[ 1:2, 1:2 ]
-> (28) Submatrix1 = [1, 2;  5, 6]

   (29) Submatrix2 = M[ 3 : GetRow(M),  2 : GetColumn(M) ]
-> (30) Submatrix2 = [10, 11, 12]



</PRE><nobr><a name="GetDefaults"><font color="darkBlue"><font size=+1><b>GetDefaults</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetDefaults  and  SetDefaults

Syntax 1:  GetDefaults
Syntax 2:  SetDefaults( AUTOLEV )         // Type HELP AUTOLEV for more info.
Syntax 3:  SetDefaults( MotionGenesis )   // This is the default setting.

Output 1:  Displays the settings of default preferences.

Output 2:  Sets program defaults to be compatible with Autolev, e.g.,
           SetBasisSubscripts( 1, 2, 3 )
           SetCMSymbol( o )
           Restricts how AUTOZ symbols are introduced (backward compatible).

Output 3:  Sets program defaults to be compatible with MotionGenesis, e.g.,
           SetBasisSubscripts( x, y, z )
           SetCMSymbol( cm )
           SetOriginSymbol( o )
           Allows more efficient computation with AUTOZ symbols.

  Remark:  To change a default setting, issue the corresponding command.
           Use HELP for more information, e.g., HELP SetDigits.

  Remark:  Some defaults can be set in the MGDefaultPreferences.txt
           file that resides in the program's MGToolbox folder, e.g.,
           SetScratchDirectory  and  SetWorkingDirectory.

 Related:  <a href="#AUTOLEV"><b>AUTOLEV</b></a>  <a href="#SetPauseOnWarning"><b>SetPauseOnWarning</b></a>



</PRE><nobr><a name="AUTOLEV"><font color="darkBlue"><font size=+1><b>AUTOLEV</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
AUTOLEV

 Purpose:  Sets defaults to be compatible with older versions of the program.

Syntax 1:  SetDefaults( AUTOLEV )
Syntax 2:  SetDefaults( MotionGenesis )   // This is the default setting.

Output 1:  Sets program defaults to be compatible with Autolev, e.g.,
           SetBasisSubscripts( 1, 2, 3 )
           SetCMSymbol( o )
           Restricts how AUTOZ symbols are introduced (backward compatible).

Output 2:  Sets program defaults to be compatible with MotionGenesis, e.g.,
           SetBasisSubscripts( x, y, z )
           SetCMSymbol( cm )
           SetOriginSymbol( o )
           Allows more efficient computation with AUTOZ symbols.

  Remark:  To be AUTOLEV compatible when the program starts, edit the file
           MGDefaultPreferences.txt file  (in the MGToolbox folder).
           Un-comment the line (remove the percent sign) in front of:
           % SetDefaults  AUTOLEV

  Remark:  The following AUTOLEV commands are available, albeit superseded.

       1.  CODE      superseded by   ODE and Solve
       2.  SIMPROT   superseded by   Rotate and SetRotationMatrix
       3.  V1PT      superseded by   SetVelocity
       4.  V2PTS     superseded by   SetVelocity
       5.  A1PT      superseded by   SetAcceleration
       6.  A2PTS     superseded by   SetAcceleration
       7.  KE        superseded by   GetKineticEnergy
       8.  FR        superseded by   GetGeneralizedForce
       9.  FRSTAR    superseded by  -GetGeneralizedEffectiveForce
      10.  TSTAR     superseded by  -GetMomentOfEffectiveForce
      11.  GYROSTAT  may be superseded in future versions

  Remark:  The following commands are only available when
           SetDefaults( AUTOLEV ) has been issued.

       1.  ARRANGE         replaced by   FactorLinear and FactorQuadratic
       2.  CM              replaced by   GetCMPosition
       3.  CODE DYNAMICS   replaced by   ODE
       4.  COEF( s, [x,y]  replaced by   GetCoefficientShallow( s, [x,y] )
                           superseded by GetCoefficient( s, [x,y] )
       5.  DEGREES         replaced by   ConvertUnits, Input, and Output
       6.  DIRCOS          replaced by   Rotate and SetRotationMatrix
       7.  EIG(M,A,B)      replaced by   GetEigen
       8.  INERTIA         replaced by   SetInertia and GetInertia
       9.  KANE            replaced by   GetDynamicsKane, GetStaticsKane, Solve
      10.  MASS            replaced by   SetMass and GetMass
      11.  MOMENTUM        replaced by   GetTranslationalMomentum,
                           and           GetAngularMomentum,
                           and           GetGeneralizedMomentum.
      12.  MotionVariable  replaced by   Variable and SetGeneralizedSpeed
      13.  MotionVariable' replaced by   Variable and SetGeneralizedSpeed
      14.  NiCheck         replaced by   GetEnergyCheckKane
      15.  REPRESENT       replaced by   Matrix, Vector, and Dyadic
      16.  UNITS           replaced by   ConvertUnits, Input, and Output

  Remark:  The following old AUTOLEV commands are incompatible
           with this program -- regardless of SetDefaults( AUTOLEV ).

       1.  Force( Q,   Vec> )   replaced by  Q.AddForce( Vec> )
           Force( P/Q, Vec> )   replaced by  Q.AddForce( P, Vec> )

       2.  Torque( B,   Vec> )  replaced by  B.AddTorque( Vec> )
           Torque( A/B, Vec> )  replaced by  B.AddTorque( A, Vec> )

       3.  NiCheck( SIGMA )     replaced by  GetEnergyCheckSigmaR
       4.  Fr( listOfObject )   removed because theoretically unsound

 Related:  <a href="#AUTOLEV"><b>AUTOLEV</b></a>  <a href="#GetDefaults"><b>GetDefaults</b></a>  <a href="#GetDefaults"><b>SetDefaults</b></a>



</PRE><nobr><a name="GetCofactor"><font color="darkBlue"><font size=+1><b>GetCofactor</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetCofactor   GetMinor

 Purpose:  Calculates the minor or cofactor of a matrix.

Syntax 1:  GetMinor(    squareMatrix, i, j )
Syntax 2:  GetCofactor( squareMatrix, i, j )

   Input:  squareMatrix -- a  square matrix
           i -- an integer designating a row in squareMatrix.
           j -- an integer designating a column in squareMatrix.

Output 1:  Mij, the determinant of the submatrix formed by eliminating the
           ith row and jth column of squareMatrix.
Output 2:  (-1)^(i+j) * Mij

 Related:  <a href="#GetColumns"><b>GetColumns</b></a>     <a href="#GetDeterminant"><b>GetDeterminant</b></a>  <a href="#GetDiagonalMatrix"><b>GetDiagonalMatrix</b></a>  <a href="#GetEigen"><b>GetEigen</b></a>
           <a href="#GetElement"><b>GetElement</b></a> <a href="#[]"><b>[]</b></a>  <a href="#GetInverse"><b>GetInverse</b></a>      <a href="#GetIdentityMatrix"><b>GetIdentityMatrix</b></a>  <a href="#GetNorm"><b>GetNorm</b></a>  <a href="#GetColumns"><b>GetRows</b></a>
           <a href="#GetTrace"><b>GetTrace</b></a>       <a href="#GetTranspose"><b>GetTranspose</b></a>    <a href="#GetIdentityMatrix"><b>GetZeroMatrix</b></a>      <a href="#Solve"><b>Solve</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetMinor
   (3) %--------------------------------------------------------------------
   (4) Constant a{1:3, 1:3}
   (5) M = [a11, a12, a13;  a21, a22, a23;  a31, a32, a33]
-> (6) M = [a11, a12, a13;  a21, a22, a23;  a31, a32, a33]

   (7) minor11 = GetMinor( M, 1, 1 )
-> (8) minor11 = a22*a33 - a23*a32

   (9) minor12 = GetMinor( M, 1, 2 )
-> (10) minor12 = a21*a33 - a23*a31

   (11) %--------------------------------------------------------------------
   (12) % Example 2: GetCofactor
   (13) %--------------------------------------------------------------------
   (14) cofactor11 = GetCofactor( M, 1, 1 )
-> (15) cofactor11 = a22*a33 - a23*a32

   (16) cofactor12 = GetCofactor( M, 1, 2 )
-> (17) cofactor12 = a23*a31 - a21*a33



</PRE><nobr><a name="GetDeterminant"><font color="darkBlue"><font size=+1><b>GetDeterminant</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetDeterminant

 Purpose:  Forms the determinant of a matrix.

Syntax 1:  GetDeterminant( squareMatrix )
Syntax 2:  GetDeterminant( Option, squareMatrix )

   Input:  squareMatrix -- a  square matrix
           Option -- MINORS or GAUSS

  Output:  Determinant of squareMatrix

  Remark:  The determinant is calculated by one of two methods.
           MINORS is advantageous for relatively small matrices
           whereas GAUSS may be better for relatively large ones.
           If neither MINORS or GAUSS is specified, a method is
           chosen based on the size and number of non-numerical
           elements in squareMatrix.

 Related:  <a href="#GetColumns"><b>GetColumns</b></a>     <a href="#GetDeterminant"><b>GetDeterminant</b></a>  <a href="#GetDiagonalMatrix"><b>GetDiagonalMatrix</b></a>  <a href="#GetEigen"><b>GetEigen</b></a>
           <a href="#GetElement"><b>GetElement</b></a> <a href="#[]"><b>[]</b></a>  <a href="#GetInverse"><b>GetInverse</b></a>      <a href="#GetIdentityMatrix"><b>GetIdentityMatrix</b></a>  <a href="#GetNorm"><b>GetNorm</b></a>  <a href="#GetColumns"><b>GetRows</b></a>
           <a href="#GetTrace"><b>GetTrace</b></a>       <a href="#GetTranspose"><b>GetTranspose</b></a>    <a href="#GetIdentityMatrix"><b>GetZeroMatrix</b></a>      <a href="#Solve"><b>Solve</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: GetDeterminant  
   (3) %--------------------------------------------------------------------
   (4) Constant a, b, c,  d, e, f,  g, h, i
   (5) M = [a, b, c;  d, e, f;  g, h, i]
-> (6) M = [a, b, c;  d, e, f;  g, h, i]

   (7) determinant = GetDeterminant( M )
-> (8) determinant = g*(b*f-c*e) + i*(a*e-b*d) - h*(a*f-c*d)

   (9) detWithMinors = GetDeterminant( MINORS, M )
-> (10) detWithMinors = g*(b*f-c*e) + i*(a*e-b*d) - h*(a*f-c*d)

   (11) detWithGauss  = GetDeterminant( GAUSS,  M )
-> (12) detWithGauss = (a*e-b*d)*(i-c*g/a-(f-c*d/a)*(h-b*g/a)/(e-b*d/a))



</PRE><nobr><a name="GetDiagonalMatrix"><font color="darkBlue"><font size=+1><b>GetDiagonalMatrix</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetDiagonalMatrix

 Purpose:  Forms diagonal matrices.
           Forms a column matrix from diagonal elements of a matrix.

Syntax 1:  GetDiagonalMatrix( m, X )
Syntax 2:  GetDiagonalMatrix( numberOfRows, numberOfColumns, X )
Syntax 3:  GetDiagonalMatrix( oneDimensionalMatrix )
Syntax 4:  GetDiagonalMatrix( twoDimensionalMatrix )

   Input:  m -- positive integer
           numberOfRows -- positive integer
           numberOfColumns -- positive integer
           X -- an expression
           oneDimensionalMatrix -- a row or column matrix
           twoDimensionalMatrix -- a rectangular matrix

 Output 1: The m x m square matrix having X as every element on
           the diagonal and 0 elsewhere.

 Output 2: The numberOfRows x numberOfColumns matrix such that
           every i,i element is X while remaining elements are 0.
           (i is smaller than numberOfRows and numberOfCols).

 Output 3: The diagonal matrix whose diagonal elements are the
           elements of oneDimensionalMatrix.

 Output 4: The column matrix whose elements are the elements of
           twoDimensionalmatrix with equal row and column indices.

 Related:  <a href="#GetColumns"><b>GetColumns</b></a>     <a href="#GetDeterminant"><b>GetDeterminant</b></a>  <a href="#GetDiagonalMatrix"><b>GetDiagonalMatrix</b></a>  <a href="#GetEigen"><b>GetEigen</b></a>
           <a href="#GetElement"><b>GetElement</b></a> <a href="#[]"><b>[]</b></a>  <a href="#GetInverse"><b>GetInverse</b></a>      <a href="#GetIdentityMatrix"><b>GetIdentityMatrix</b></a>  <a href="#GetNorm"><b>GetNorm</b></a>  <a href="#GetColumns"><b>GetRows</b></a>
           <a href="#GetTrace"><b>GetTrace</b></a>       <a href="#GetTranspose"><b>GetTranspose</b></a>    <a href="#GetIdentityMatrix"><b>GetZeroMatrix</b></a>      <a href="#Solve"><b>Solve</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetDiagonalMatrix  (3x3 matrix with 15 on the diagonal)
   (3) %--------------------------------------------------------------------
   (4) M1 = GetDiagonalMatrix( 3,  15 )
-> (5) M1 = [15, 0, 0;  0, 15, 0;  0, 0, 15]

   (6) %--------------------------------------------------------------------
   (7) % Example 2: GetDiagonalMatrix  (2x3 matrix with 17 on the diagonal)
   (8) %--------------------------------------------------------------------
   (9) M2 = GetDiagonalMatrix( 2,3,  17 )
-> (10) M2 = [17, 0, 0;  0, 17, 0]

   (11) %--------------------------------------------------------------------
   (12) % Example 3: GetDiagonalMatrix  (3x3 matrix with 18,19,20 on diagonal)
   (13) M3 = GetDiagonalMatrix( [18,19,20] )
-> (14) M3 = [18, 0, 0;  0, 19, 0;  0, 0, 20]

   (15) %--------------------------------------------------------------------
   (16) % Example 4: GetDiagonalMatrix  (get diagonal elements of matrix)
   (17) %--------------------------------------------------------------------
   (18) Constant  A{1:3,1:4}
   (19) M4 = GetDiagonalMatrix( [A11,A12,A13,A14;A21,A22,A23,A24;A31,A32,A33,A34] )
-> (20) M4 = [A11;  A22;  A33]



</PRE><nobr><a name="GetDistance"><font color="darkBlue"><font size=+1><b>GetDistance</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetDistance  GetLength   GetDistanceSquared  GetLengthSquared

 Purpose:  Gets the distance (or its square) between two points.

Syntax 1:  Q.GetDistance( P )
           Q.GetLength( P )
Syntax 2:  Q.GetDistanceSquared( P )
           Q.GetLengthSquared( P )

   Input:  Q -- The name of a point.
           P -- The name of another point.

Output 1:  Distance between Q and P.
Output 2:  Square of the distance between Q and P.

 Related:  <a href="#GetMagnitude"><b>GetMagnitude</b></a>           <a href="#GetMagnitude"><b>GetMagnitudeSquared</b></a>
           <a href="#GetDistance"><b>GetDistance</b></a>            <a href="#GetDistance"><b>GetDistanceSquared</b></a>
           <a href="#GetSpeed"><b>GetSpeed</b></a>               <a href="#GetSpeed"><b>GetSpeedSquared</b></a>
           <a href="#GetAngularSpeed"><b>GetAngularSpeed</b></a>        <a href="#GetAngularSpeed"><b>GetAngularSpeedSquared</b></a>
           <a href="#GetAngleBetweenVectors"><b>GetAngleBetweenVectors</b></a> <a href="#GetAngleBetweenVectors"><b>GetAngleBetweenUnitVectors</b></a>
           <a href="#GetPosition"><b>GetPosition</b></a>            <a href="#SetPosition"><b>SetPosition</b></a>       <a href="#Translate"><b>Translate</b></a>
           <a href="#GetVelocity"><b>GetVelocity</b></a>            <a href="#SetVelocity"><b>SetVelocity</b></a>       <a href="#SetPositionVelocity"><b>SetPositionVelocity</b></a>
           <a href="#GetAcceleration"><b>GetAcceleration</b></a>        <a href="#SetAcceleration"><b>SetAcceleration</b></a>   <a href="#SetVelocityAcceleration"><b>SetVelocityAcceleration</b></a>
           <a href="#GetUnitVector"><b>GetUnitVector</b></a>          <a href="#GetElongation"><b>GetElongation</b></a>     <a href="#Vector"><b>Vector</b></a>   <a href="#Cross"><b>Dot</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetDistance  GetDistanceSquared  
   (3) %--------------------------------------------------------------------
   (4) RigidFrame  N
   (5) Particle    P, Q
   (6) Variable    xQ
   (7) Q.SetPosition( P, xQ*Nx> )
-> (8) p_P_Q> = xQ*Nx>

   (9) distanceBetweenQAndP = Q.GetDistance( P )
-> (10) distanceBetweenQAndP = abs(xQ)

   (11) distanceSquaredQAndP = Q.GetDistanceSquared( P )
-> (12) distanceSquaredQAndP = xQ^2

   (13) %--------------------------------------------------------------------
   (14) % Example 2: GetDistance  GetDistanceSquared  GetLength  GetLengthSquared
   (15) %--------------------------------------------------------------------
   (16) Variable    x, y, z
   (17) P.SetPosition( No,  x*Nx> + y*Ny> + z*Nz> )
-> (18) p_No_P> = x*Nx> + y*Ny> + z*Nz>

   (19) distanceBetweenPAndNo = P.GetDistance( No )
-> (20) distanceBetweenPAndNo = sqrt(x^2+y^2+z^2)

   (21) distanceBetweenQAndNo = Q.GetDistance( No )    % Same as Q.GetLength( No )
-> (22) distanceBetweenQAndNo = sqrt(y^2+z^2+(x+xQ)^2)

   (23) distanceSquaredPAndNo = Q.GetLengthSquared( No )
-> (24) distanceSquaredPAndNo = y^2 + z^2 + (x+xQ)^2



</PRE><nobr><a name="GetDynamics"><font color="darkBlue"><font size=+1><b>GetDynamics</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetDynamics   GetDynamicsKane    GetDynamicsLagrange

 Purpose:  Gets equations of motion (dynamics).

Syntax 1:  Object.GetDynamics()
Syntax 2:  Object.GetDynamics( aboutPoint )
Syntax 3:  System.GetDynamicsKane()
Syntax 4:  System.GetDynamicsLagrange()    IN DEVELOPMENT.  SEE SYNTAX.

   Input:  Object -- The name of a Particle, RigidBody, or System.
           aboutPoint -- The name of a point.

Output 1:  Newton's   equation of motion for Object (i.e., m*a - F).
Output 2:  Euler's    equation of motion for Object about aboutPoint.
Output 3:  Kane's     equation for dynamics for the entire System.
Output 4:  Lagrange's equation for dynamics for the entire System.

  Remark:  If Q is a point of a RigidFrame or RigidBody B, declare it as
           Point Q(B).  This helps with subsequent velocity/acceleration
           and force/moment calculations.

  Remark:  For Newton/Euler equations, type  Help Statics  or  Help Dynamics
           For Kane's       equations, type  Help Kane
           For Lagrange's   equations, type  Help Lagrange

 Related:  <a href="#AddForce"><b>AddForce</b></a>  <a href="#AddTorque"><b>AddTorque</b></a>  <a href="#SetMass"><b>SetMass</b></a>  <a href="#SetInertia"><b>SetInertia</b></a>  <a href="#Rotate"><b>Rotate</b></a>  <a href="#Translate"><b>Translate</b></a>
           <a href="#NewtonianFrame"><b>NewtonianFrame</b></a>  <a href="#Point"><b>Point</b></a>  <a href="#Particle"><b>Particle</b></a>  <a href="#RigidFrame"><b>RigidFrame</b></a>  <a href="#RigidBody"><b>RigidBody</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>
           <a href="#SetGeneralizedSpeed"><b>SetGeneralizedCoordinate</b></a>   <a href="#SetGeneralizedSpeed"><b>SetGeneralizedSpeed</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetDynamics   (dynamics of a particle in free-fall)
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N             
   (5) Particle       Q
   (6) Q.SetMass( mQ )
   (7) Variable  y''
   (8) Q.Translate( No, y*Ny> )
-> (9) p_No_Q> = y*Ny>
-> (10) v_Q_N> = y'*Ny>
-> (11) a_Q_N> = y''*Ny>

   (12) Constant  g
   (13) Q.AddForceGravity( -g*Ny> )
-> (14) Force_Q> = -mQ*g*Ny>

   (15) NewtonsVectorEqnForQ> = Q.GetDynamics()
-> (16) NewtonsVectorEqnForQ> = mQ*(g+y'')*Ny>

   (17) NewtonsScalarEqnForQ = Dot( NewtonsVectorEqnForQ>, Ny> )
-> (18) NewtonsScalarEqnForQ = mQ*(g+y'')

   (19) Solve(  NewtonsScalarEqnForQ,  y'' )
-> (20) y'' = -g

   (21) %--------------------------------------------------------------------
   (22) % Example 2: GetDynamics  (rigid-body pendulum with applied torque)
   (23) %--------------------------------------------------------------------
   (24) RigidBody      B            
   (25) Constant       L                 % Distance to B's center of mass
   (26) Variable       q''               % Pendulum angle 
   (27) Variable       Tz                % Torque is applied to B 
   (28) B.SetMass( m )
   (29) B.SetInertia( Bcm, Ixx, Iyy, Izz )
   (30) B.RotateZ( N, q )  
-> (31) B_N = [cos(q), sin(q), 0;  -sin(q), cos(q), 0;  0, 0, 1]
-> (32) w_B_N> = q'*Bz>
-> (33) alf_B_N> = q''*Bz>

   (34) Bcm.Translate( No, -L*By> )
-> (35) p_No_Bcm> = -L*By>
-> (36) v_Bcm_N> = L*q'*Bx>
-> (37) a_Bcm_N> = L*q''*Bx> + L*q'^2*By>

   (38) B.AddForceGravity( -g*Ny> )
-> (39) Force_Bcm> = -m*g*Ny>

   (40) B.AddTorque( Tz*Bz> )  
-> (41) Torque_B> = Tz*Bz>

   (42) EulersVectorEqnForBAboutNo> = B.GetDynamics( No )
-> (43) EulersVectorEqnForBAboutNo> = (m*g*L*sin(q)+Izz*q''+m*L^2*q''-Tz)*Bz>

   (44) EulersScalarEqnForBAboutNo = Dot( EulersVectorEqnForBAboutNo>, Nz> )
-> (45) EulersScalarEqnForBAboutNo = m*g*L*sin(q) + Izz*q'' + m*L^2*q'' - Tz

   (46) Solve( EulersScalarEqnForBAboutNo, q'' )
-> (47) q'' = (Tz-m*g*L*sin(q))/(Izz+m*L^2)



</PRE><nobr><a name="GetEffectiveForce"><font color="darkBlue"><font size=+1><b>GetEffectiveForce</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetEffectiveForce

 Purpose:  Gets effective force in the NewtonianFrame (or a designated frame).

Syntax 1:  Object.GetEffectiveForce()
Syntax 2:  Object.GetEffectiveForce( refFrame )

   Input:  Object -- The name of a Particle, RigidBody, or System.
           refFrame -- The name of a RigidFrame or RigidBody

Output 1:  Effective force of Object in the NewtonianFrame.
Output 2:  Effective force of Object in refFrame.

  Remark:  A particle Q's effective force in refFrame is defined
           Q.GetMass() * Q.GetAcceleration(refFrame)

 Related:  <a href="#GetAngularMomentum"><b>GetAngularMomentum</b></a>  <a href="#GetTranslationalMomentum"><b>GetTranslationalMomentum</b></a>  <a href="#GetGeneralizedMomentum"><b>GetGeneralizedMomentum</b></a>
           <a href="#GetKineticEnergy"><b>GetKineticEnergy</b></a>    <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>
           <a href="#GetEffectiveForce"><b>GetEffectiveForce</b></a>  <a href="#GetMomentOfEffectiveForce"><b>GetMomentOfEffectiveForce</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetEffectiveForce  (particle moving in a plane)
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N             
   (5) Particle       Q             
   (6) Q.SetMass( mQ )
   (7) Variable       x'', y'', z''    
   (8) Q.SetAcceleration( N, x''*Nx> + y''*Ny> + z''*Nz> )
-> (9) a_Q_N> = x''*Nx> + y''*Ny> + z''*Nz>

   (10) QEffectiveForce> = Q.GetEffectiveForce()
-> (11) QEffectiveForce> = mQ*x''*Nx> + mQ*y''*Ny> + mQ*z''*Nz>

   (12) %--------------------------------------------------------------------
   (13) % Example 2: GetEffectiveForce  (rigid body moving in a plane)
   (14) %--------------------------------------------------------------------
   (15) RigidBody  B             
   (16) B.SetMass( mB )
   (17) Variable   vx', vy', vz'    
   (18) Bcm.SetAcceleration( N, vx'*Nx> + vy'*Ny> + vz'*Nz> )
-> (19) a_Bcm_N> = vx'*Nx> + vy'*Ny> + vz'*Nz>

   (20) BEffectiveForce> = B.GetEffectiveForce()
-> (21) BEffectiveForce> = mB*vx'*Nx> + mB*vy'*Ny> + mB*vz'*Nz>

   (22) %--------------------------------------------------------------------
   (23) % Example 3: GetEffectiveForce  (linear momentum of a system)
   (24) %--------------------------------------------------------------------
   (25) SEffectiveForce> = System.GetEffectiveForce()
-> (26) SEffectiveForce> = (mB*vx'+mQ*x'')*Nx> + (mB*vy'+mQ*y'')*Ny> + (mB*vz'+
        mQ*z'')*Nz>



</PRE><nobr><a name="GetEigen"><font color="darkBlue"><font size=+1><b>GetEigen</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetEigen

 Purpose:  Calculates the eigenvalues or the eigenvalues and
           eigenvectors of a real square matrix.

Syntax 1:  GetEigen( M )
Syntax 2:  GetEigen( M, eigenVectorMatrixName )

   Input:  M -- a square matrix whose elements are real numbers
                or a dyadic whose measures are real numbers.

           eigenVectorMatrixName -- the name of a square matrix whose
                columns are to be the eigenvectors of M

Output 1:  Returns the eigenvalues of M.
Output 2:  Returns the eigenvalues of M.  Assigns eigenVectorMatrixName.

  Remark:  The COLUMNS of eigenVectorMatrixName are the eigenvectors of M.

 Related:  <a href="#GetColumns"><b>GetColumns</b></a>     <a href="#GetDeterminant"><b>GetDeterminant</b></a>  <a href="#GetDiagonalMatrix"><b>GetDiagonalMatrix</b></a>  <a href="#GetEigen"><b>GetEigen</b></a>
           <a href="#GetElement"><b>GetElement</b></a> <a href="#[]"><b>[]</b></a>  <a href="#GetInverse"><b>GetInverse</b></a>      <a href="#GetIdentityMatrix"><b>GetIdentityMatrix</b></a>  <a href="#GetNorm"><b>GetNorm</b></a>  <a href="#GetColumns"><b>GetRows</b></a>
           <a href="#GetTrace"><b>GetTrace</b></a>       <a href="#GetTranspose"><b>GetTranspose</b></a>    <a href="#GetIdentityMatrix"><b>GetZeroMatrix</b></a>      <a href="#Solve"><b>Solve</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetEigen   (eigenvalues of a matrix)
   (3) %--------------------------------------------------------------------
   (4) A = [1, 2, 3;  4, 5, 6;  5, 3, 7]
-> (5) A = [1, 2, 3;  4, 5, 6;  5, 3, 7]

   (6) eigenValuesOfA = GetEigen( A )
-> (7) eigenValuesOfA = [-0.9412871;  1.542281;  12.39901]

   (8) %--------------------------------------------------------------------
   (9) % Example 2: GetEigen   (eigenvalues and eigenvectors of a matrix)
   (10) %--------------------------------------------------------------------
   (11) B = [1, 2;  3, 4]
-> (12) B = [1, 2;  3, 4]

   (13) eigenValuesOfB = GetEigen( B, eigenVectorsOfB )
-> (14) eigenVectorsOfB = [-0.8245648, -0.4159736;  0.5657675, -0.9093767]
-> (15) eigenValuesOfB = [-0.3722813;  5.372281]

   (16) %--------------------------------------------------------------------
   (17) % Example 3: GetEigen   (eigenvalues of a dyadic)
   (18) %--------------------------------------------------------------------
   (19) RigidFrame  F
   (20) D>> = Dyadic( F, A )
-> (21) D>> = Fx>*Fx> + 2*Fx>*Fy> + 3*Fx>*Fz> + 4*Fy>*Fx> + 5*Fy>*Fy> + 6*Fy>*Fz>
        + 5*Fz>*Fx> + 3*Fz>*Fy> + 7*Fz>*Fz>

   (22) eigenValuesOfD = GetEigen( D>> )
-> (23) eigenValuesOfD = [-0.9412871;  1.542281;  12.39901]

   (24) %--------------------------------------------------------------------
   (25) % Example 4: GetEigen   (eigenvalues and eigenvectors of a dyadic)
   (26) %--------------------------------------------------------------------
   (27) eigenValuesOf3D = GetEigen( 3*D>>, eigenVectorsOfD )
-> (28) eigenVectorsOfD = [0.8537881*Fx> - 0.05164451*Fy> - 0.5180529*Fz>;  
        -0.08917212*Fx> - 0.8360999*Fy> + 0.5412811*Fz>;  0.2947511*Fx> + 0.6929328*Fy> + 0.6580015*Fz>]

-> (29) eigenValuesOf3D = [-2.823861;  4.626843;  37.19702]



</PRE><nobr><a name="[]"><font color="darkBlue"><font size=+1><b>[]</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
[]

 Purpose:  Assigns or returns one or more elements of a matrix.
           Use  GetElement  to return elements for an unnamed matrix.

Syntax 1:  mat1D[ index ]
Syntax 2:  mat1D[ indexStart : indexStop ]
Syntax 3:  mat2D[ i, j ]
Syntax 4:  mat2D[ iStart : iStop,  jStart : jStop ]

   Input:  mat1D -- 1D (one-dimensional) matrix (row or column matrix).
           mat2D -- 2D (two-dimensional) matrix.
           index  -- integer identifying ith element of a 1D matrix.
           indexStart : indexStop -- integer range for elements in a 1D matrix.
           i -- integer identifying a row    in a 2D matrix.
           j -- integer identifying a column in a 2D matrix.
           iStart : iStop -- integers identifying rows in a 2D matrix.
           jStart : jStop -- integers identifying columns in a 2D matrix.

Output 1:  The element of mat1D located at index.
Output 2:  A sub-matrix whose elements are chosen by  indexStart : indexStop.
Output 3:  Element in the ith row and jth column of mat2D.
Output 4:  A sub-matrix with rows iStart : iStop  and columns  jStart : jStop.

  Remark:  Alternatively, select rows or columns with GetRows or GetColumns.
           Use GetElement to select elements from an unnamed matrix expression.

 Related:  <a href="#GetColumns"><b>GetColumns</b></a>     <a href="#GetDeterminant"><b>GetDeterminant</b></a>  <a href="#GetDiagonalMatrix"><b>GetDiagonalMatrix</b></a>  <a href="#GetEigen"><b>GetEigen</b></a>
           <a href="#GetElement"><b>GetElement</b></a> <a href="#[]"><b>[]</b></a>  <a href="#GetInverse"><b>GetInverse</b></a>      <a href="#GetIdentityMatrix"><b>GetIdentityMatrix</b></a>  <a href="#GetNorm"><b>GetNorm</b></a>  <a href="#GetColumns"><b>GetRows</b></a>
           <a href="#GetTrace"><b>GetTrace</b></a>       <a href="#GetTranspose"><b>GetTranspose</b></a>    <a href="#GetIdentityMatrix"><b>GetZeroMatrix</b></a>      <a href="#Solve"><b>Solve</b></a>


</PRE><nobr><a name="GetElement"><font color="darkBlue"><font size=+1><b>GetElement</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetElement

 Purpose:  Returns one or more elements from an unnamed matrix expression.
           Type  Help []  for simpler syntax for a named matrix.

Syntax 1:  GetElement( mat1DExpression,  index )
Syntax 2:  GetElement( mat1DExpression,  indexStart : indexStop )
Syntax 3:  GetElement( mat2DExpression,  i, j )
Syntax 4:  GetElement( mat2DExpression,  iStart : iStop,  jStart : jStop )

   Input:  mat1DExpression -- 1D (one-dimensional) matrix or matrix expression.
           mat2DExpression -- 2D (two-dimensional) matrix or matrix expression.
           index  -- integer identifying ith element of a 1D matrix.
           indexStart : indexStop -- integer range for elements in a 1D matrix.
           i -- integer identifying a row    in a 2D matrix.
           j -- integer identifying a column in a 2D matrix.
           iStart : iStop -- integers identifying rows in a 2D matrix.
           jStart : jStop -- integers identifying columns in a 2D matrix.

Output 1:  The element of mat1DExpression located at index.
Output 2:  A sub-matrix whose elements are chosen by  indexStart : indexStop.
Output 3:  Element in the ith row and jth column of mat2D or mat2DExpression.
Output 4:  A sub-matrix with rows iStart : iStop  and columns  jStart : jStop.

  Remark:  Alternatively, select rows or columns with GetRows or GetColumns.
           Use [] to select elements from a named matrix.

 Related:  <a href="#GetColumns"><b>GetColumns</b></a>     <a href="#GetDeterminant"><b>GetDeterminant</b></a>  <a href="#GetDiagonalMatrix"><b>GetDiagonalMatrix</b></a>  <a href="#GetEigen"><b>GetEigen</b></a>
           <a href="#GetElement"><b>GetElement</b></a> <a href="#[]"><b>[]</b></a>  <a href="#GetInverse"><b>GetInverse</b></a>      <a href="#GetIdentityMatrix"><b>GetIdentityMatrix</b></a>  <a href="#GetNorm"><b>GetNorm</b></a>  <a href="#GetColumns"><b>GetRows</b></a>
           <a href="#GetTrace"><b>GetTrace</b></a>       <a href="#GetTranspose"><b>GetTranspose</b></a>    <a href="#GetIdentityMatrix"><b>GetZeroMatrix</b></a>      <a href="#Solve"><b>Solve</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetElement of two-dimensional matrix -- uses [] syntax.
   (3) %--------------------------------------------------------------------
   (4) A = [1, 2, 3;  4,  5, 6; 7, 8, 9]
-> (5) A = [1, 2, 3;  4, 5, 6;  7, 8, 9]

   (6) A12 = A[ 1, 2 ]
-> (7) A12 = 2

   (8) Asubmatrix22 = A[ 1:2, 1:2 ]
-> (9) Asubmatrix22 = [1, 2;  4, 5]

   (10) Asubmatrix23 = A[ 1:2, 1:cols(A) ]
-> (11) Asubmatrix23 = [1, 2, 3;  4, 5, 6]

   (12) %--------------------------------------------------------------------
   (13) % Example 2: GetElement (unnamed two-dimensional matrix)
   (14) %--------------------------------------------------------------------
   (15) AA12 = GetElement( A * A,  1, 2 )
-> (16) AA12 = 36

   (17) AAsubmatrix = GetElements( A * A,  1:2, 2:3 )
-> (18) AAsubmatrix = [36, 42;  81, 96]

   (19) %--------------------------------------------------------------------
   (20) % Example 3: GetElement of one-dimensional matrix -- uses [] syntax.
   (21) %--------------------------------------------------------------------
   (22) B = [t^2, sin(t), cos(t), tan(t)]
-> (23) B = [t^2, sin(t), cos(t), tan(t)]

   (24) B2 = B[ 2 ]
-> (25) B2 = sin(t)

   (26) Bsubmatrix = B[ 2:4 ]
-> (27) Bsubmatrix = [sin(t), cos(t), tan(t)]

   (28) %--------------------------------------------------------------------
   (29) % Example 4: GetElement (unnamed one-dimensional matrix)
   (30) %--------------------------------------------------------------------
   (31) BB2 = GetElement( B + B,  2 )
-> (32) BB2 = 2*sin(t)

   (33) BBsubmatrix = GetElement( B + B,  2:4 )
-> (34) BBsubmatrix = [2*sin(t), 2*cos(t), 2*tan(t)]



</PRE><nobr><a name="GetElongation"><font color="darkBlue"><font size=+1><b>GetElongation</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetElongation

 Purpose:  Gets the time-derivative of the distance between two points.

  Syntax:  Q.GetElongation( P )

   Input:  Q -- The name of a point.
           P -- The name of another point.

  Output:  Time-derivative of the distance between Q and P.

 Related:  <a href="#Translate"><b>Translate</b></a>        <a href="#SetPositionVelocity"><b>SetPositionVelocity</b></a>   <a href="#SetVelocityAcceleration"><b>SetVelocityAcceleration</b></a>
           <a href="#SetPosition"><b>SetPosition</b></a>      <a href="#GetPosition"><b>GetPosition</b></a>   <a href="#GetDistance"><b>GetDistance</b></a>  <a href="#GetDistance"><b>GetDistanceSquared</b></a>
           <a href="#SetVelocity"><b>SetVelocity</b></a>      <a href="#GetVelocity"><b>GetVelocity</b></a>   <a href="#GetSpeed"><b>GetSpeed</b></a>     <a href="#GetElongation"><b>GetElongation</b></a>
           <a href="#SetAcceleration"><b>SetAcceleration</b></a>  <a href="#GetAcceleration"><b>GetAcceleration</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetElongation 
   (3) %--------------------------------------------------------------------
   (4) RigidFrame N             
   (5) Point      P, Q
   (6) Variable   xP', xQ', yQ'
   (7) P.SetPosition( No, xP*Nx> )
-> (8) p_No_P> = xP*Nx>

   (9) ElongationBetweenPAndNo = P.GetElongation( No )
-> (10) ElongationBetweenPAndNo = xP*xP'/abs(xP)

   (11) %--------------------------------------------------------------------
   (12) % Example 2: GetElongation 
   (13) %--------------------------------------------------------------------
   (14) Q.SetPosition( P,  xQ*Nx> + yQ*Ny> )
-> (15) p_P_Q> = xQ*Nx> + yQ*Ny>

   (16) ElongationBetweenQAndP = Q.GetElongation( P )
-> (17) ElongationBetweenQAndP = (xQ*xQ'+yQ*yQ')/sqrt(xQ^2+yQ^2)



</PRE><nobr><a name="GetEnergyCheckKane"><font color="darkBlue"><font size=+1><b>GetEnergyCheckKane</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetEnergyCheckKane  and  GetEnergyCheckSigmaR

 Purpose:  Returns an energy checking function associated with Kane's
           dynamical equations, which theoretically remains constant
           throughout numerical integration of equations of motion.

Syntax 1:  System.GetEnergyCheckKane()
Syntax 2:  System.GetEnergyCheckKane( WF )
Syntax 3:  Object.GetEnergyCheckSigmaR()
Syntax 4:  Object.GetEnergyCheckSigmaR( refFrame )

   Input:  WF -- an expression for the System's work function.

   Input:  Object -- The name of a Particle, RigidBody, or System.

Output 1:  Writes a differential equation of the form WChecki' = fi.
           Returns the associated energy checking function.

Output 2:  Same as Output 1.

Output 3:  Returns Object's SigmaR in the NewtonianFrame,
           a quantity defined by Mitiguy and Banerjee (see below)
           to construct the energy checking function.

Output 4:  Returns Object's SigmaR in refFrame.

  Remark:  Due to round-off and truncation errors and numerical
           integration inaccuracies, the value of a checking function
           tends to vary slightly during numerical integration; but,
           usually (depending on machine accuracy) the variations in
           the value of a checking function become ever smaller when
           appropriate changes are made in error bounds, integration
           stepsize, etc.  When such changes fail to lead to ever
           smaller variations in checking function values, integration
           results must be regarded as suspect or incorrect.

  Remark:  GetEnergyCheckKane uses the following quantities:
           (a) Mass of particles and bodies
           (b) Inertia scalars for rigid bodies
           (c) Velocities of particles or mass center of rigid bodies
           (d) Angular velocities of rigid bodies

  Remark:  The syntax NiCheck(SIGMA) was replaced by GetEnergyCheckSigmaR
           due to algorithm changes (see below).

  Remark:  The algorithm for GetEnergyCheckKane is more efficient than
           the older NiCheck algorithm for programs before Autolev 4.1.
           The newer Mitiguy/Banerjee numerical integration energy checking is
           available in the textbook: Mitiguy, Paul, Advanced Dynamics for
           Professional Mechanical, Aerospace, and BioMechanical Engineers.

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetEnergyCheckKane
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame  N
   (5) Particle        A          % Cart moving horizontally on N.
   (6) RigidBody       B          % Inverted pendulum on cart.
   (7) %------------------
   (8) Constant   L = 1 m         % Length of uniform rod B.
   (9) Constant   g = 9.8 m/s^2   % Earth's gravitational acceleration.
   (10) Variable   x''             % Measure of A's horizontal position on N.
   (11) Specified  phi''           % B's angle with Earth's local vertical.
   (12) SetGeneralizedSpeed( x' )
   (13) SetDt( phi = 3*sin(2*t) )
-> (14) phi = 3*sin(2*t)
-> (15) phi' = 6*cos(2*t)
-> (16) phi'' = -12*sin(2*t)

   (17) A.SetMass( mA = 1 kg )
   (18) B.SetMassInertia( mB = 1 kg,  IB = mB*L^2/12, 0, IB )
-> (19) IB = 0.08333333*mB*L^2

   (20) B.RotateZ( N, phi )
-> (21) B_N = [cos(phi), sin(phi), 0;  -sin(phi), cos(phi), 0;  0, 0, 1]
-> (22) w_B_N> = phi'*Bz>
-> (23) alf_B_N> = phi''*Bz>

   (24) A.Translate( No, x*Nx> )
-> (25) p_No_A> = x*Nx>
-> (26) v_A_N> = x'*Nx>
-> (27) a_A_N> = x''*Nx>

   (28) Bcm.Translate( A, 0.5*L*By> )
-> (29) p_A_Bcm> = 0.5*L*By>
-> (30) v_Bcm_N> = -0.5*L*phi'*Bx> + x'*Nx>
-> (31) a_Bcm_N> = -0.5*L*phi''*Bx> - 0.5*L*phi'^2*By> + x''*Nx>

   (32) System.AddForceGravity( -g*Ny> )
-> (33) Force_A> = -mA*g*Ny>
-> (34) Force_Bcm> = -mB*g*Ny>

   (35) Dynamics = System.GetDynamicsKane()
-> (36) Dynamics = [0.5*mB*L*(sin(phi)*phi'^2-cos(phi)*phi'') + (mA+mB)*x'']

   (37) EnergyCheck = System.GetEnergyCheckKane()
-> (38) WCheck1' = 0.5*mB*L*(sin(phi)*phi'^2-cos(phi)*phi'')*x'
-> (39) EnergyCheck = WCheck1 + 0.5*(mA+mB)*x'^2

   (40) Input  x = 0,  x' = 0
   (41) Input  tFinal = 10 s, tStep = 0.1, absError = 1.0E-9, relError = 1.0E-9
   (42) Output t sec,  EnergyCheck Joules,  x m,  phi degrees 
   (43) ODE( Dynamics = 0,  x'' ) GetEnergyCheckKane

   (44) sigmaB = B.GetEnergyCheckSigmaR()
-> (45) sigmaB = 0.5*mB*L*(sin(phi)*phi'^2-cos(phi)*phi'')*x'

   (46) isVerifySigmaB = IsSimplifyEqual( sigmaB, WCheck1' )
-> (47) isVerifySigmaB = true



</PRE><nobr><a name="GetEnvironmentValue"><font color="darkBlue"><font size=+1><b>GetEnvironmentValue</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetEnvironmentValue

 Purpose:  Displays the value of an operating system environment variable.

  Syntax:  GetEnvironmentValue( envName )

   Input:  envName -- the name of an operating system environment variable.

  Output:  Displays the value assigned to the operating system environment
           variable envName.  For example, on Microsoft Windows PCs,
           GetEnvironmentValue( COMPUTERNAME )
           displays the operating system value assigned to COMPUTERNAME.

  Remark:  If an environment variable, e.g., COMPUTERNAME is not set
           or is set improperly, it may be set as follows:

  Windows 2000 and XP:

           Click on Start, Settings, Control Panel, System, Advanced,
           Environment  Variables.  Under System Variables, click New ...
           Enter the Variable Name COMPUTERNAME and enter a Variable Value
           e.g., yourComputerName.  Click OK to exit each open dialogue box.

  Windows 95/98/Millenium:

           Add the following line to the file Autoexec.bat, which
           resides on the C:\ drive:

               SET COMPUTERNAME=yourComputerName

  Windows NT:

           Click on Start, Settings, Control Panel, System.
           Click on the Environment tab.  Enter the Variable COMPUTERNAME
           and a Value, e.g., yourComputerName. Click OK to exit.


  Unix and Macintosh OSX:

           To set the  HOSTNAME  environment variable, edit the
           file .cshrc and add the following line:

                setenv HOSTNAME yourComputerName

 Related:  <a href="#GetDefaults"><b>GetDefaults</b></a>  <a href="#SetWorkingDirectory"><b>GetWorkingDirectory</b></a>  <a href="#SetWorkingDirectory"><b>SetWorkingDirectory</b></a>
           <a href="#GetEnvironmentValue"><b>GetEnvironmentValue</b></a>   <a href="#SetScratchDirectory"><b>SetScratchDirectory</b></a>

--------------------------------------------------------------------
 Example:

   (1) GetEnvironmentValue( ComputerName )

 The value JPComputer is assigned to the environment variable ComputerName



</PRE><nobr><a name="GetForceElectrostaticPotentialEnergy"><font color="darkBlue"><font size=+1><b>GetForceElectrostaticPotentialEnergy</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetForceElectrostaticPotentialEnergy

 Purpose:  Calculates potential energy associated with electrostatic forces.

  Syntax:  Q.GetForceElectrostaticPotentialEnergy( P, k )

   Input:  Q -- the name of a point
           P -- the name of a point
           k -- scalar representing the electrostatic proportionality
                constant, approximately 8.9875518E+09 N*m^2/Coulomb^2.

  Output:  A potential energy due to the inverse square law
           electrostatic force between P and Q.
           Note: Q's position vector from P must be available.

  Remark:  Ensure charges are assigned to Q and P with the commands:
           Q.SetCharge(...)  and  P.SetCharge(...).

  Remark:  The NIST approximation for k is 8.9875518E+09 N*m^2/Coulomb^2.

 Related:  <a href="#AddForce"><b>AddForce</b></a>  <a href="#AddForceDamper"><b>AddForceDamper</b></a>  <a href="#AddForceElectrostatic"><b>AddForceElectrostatic</b></a>  <a href="#AddForceGravity"><b>AddForceGravity</b></a>
           <a href="#AddForceInverseSquare"><b>AddForceInverseSquare</b></a>  <a href="#AddForceLinearActuator"><b>AddForceLinearActuator</b></a>  <a href="#AddForceSpring"><b>AddForceSpring</b></a>
           <a href="#AddTorque"><b>AddTorque</b></a>  <a href="#AddTorqueDamper"><b>AddTorqueDamper</b></a>
           <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>  <a href="#GetResultantTorque"><b>GetResultantTorque</b></a>
           <a href="#GetForceGravityPotentialEnergy"><b>GetForceGravityPotentialEnergy</b></a>  <a href="#GetForceSpringPotentialEnergy"><b>GetForceSpringPotentialEnergy</b></a>
           <a href="#GetForceElectrostaticPotentialEnergy"><b>GetForceElectrostaticPotentialEnergy</b></a>  <a href="#GetCharge"><b>GetCharge</b></a>  <a href="#SetCharge"><b>SetCharge</b></a>
           <a href="#GetForceInverseSquarePotentialEnergy"><b>GetForceInverseSquarePotentialEnergy</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetForceElectrostaticPotentialEnergy  (horizontal 1D)
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N
   (5) Particle  A
   (6) Variable  xA
   (7) Constant  k
   (8) No.SetCharge( chargeN )
   (9) A.SetCharge(  chargeA )
   (10) A.SetPosition( No, xA*Nx> )
-> (11) p_No_A> = xA*Nx>

   (12) potentialEnergy1 = A.GetForceElectrostaticPotentialEnergy( No, k )
-> (13) potentialEnergy1 = chargeA*chargeN*k/abs(xA)

   (14) %--------------------------------------------------------------------
   (15) % Example 2: GetForceElectrostaticPotentialEnergy  (planar 2D)
   (16) %--------------------------------------------------------------------
   (17) Particle  P, Q
   (18) Variable  x, y
   (19) P.SetCharge( 10 )
   (20) Q.SetCharge( 20 )
   (21) Q.SetPosition( P, x*Nx> + y*Ny> )
-> (22) p_P_Q> = x*Nx> + y*Ny>

   (23) potentialEnergy2 = Q.GetForceElectrostaticPotentialEnergy( P, k )
-> (24) potentialEnergy2 = 200*k/sqrt(x^2+y^2)



</PRE><nobr><a name="GetForceInverseSquarePotentialEnergy"><font color="darkBlue"><font size=+1><b>GetForceInverseSquarePotentialEnergy</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetForceInverseSquarePotentialEnergy

 Purpose:  Calculates potential energy associated with an inverse-square force.

  Syntax:  Q.GetForceInverseSquarePotentialEnergy( P, coef )

   Input:  Q -- the name of a point
           P -- the name of a point
           coef -- a scalar expression

  Output:  A potential energy due to an inverse square law
           force between P and Q.
           Note: Q's position vector from P must be available.

  Remark:  The potential energy is calculated as:
           coef / Q.GetDistance(P)

  Remark:  A positive coef corresponds to a repulsive force,
           i.e., a force that pushes Q away from P, whereas
           a negative coef corresponds to an attractive force,
           i.e., a force that pulls Q towards P.

 Related:  <a href="#AddForce"><b>AddForce</b></a>  <a href="#AddForceDamper"><b>AddForceDamper</b></a>  <a href="#AddForceElectrostatic"><b>AddForceElectrostatic</b></a>  <a href="#AddForceGravity"><b>AddForceGravity</b></a>
           <a href="#AddForceInverseSquare"><b>AddForceInverseSquare</b></a>  <a href="#AddForceLinearActuator"><b>AddForceLinearActuator</b></a>  <a href="#AddForceSpring"><b>AddForceSpring</b></a>
           <a href="#AddTorque"><b>AddTorque</b></a>  <a href="#AddTorqueDamper"><b>AddTorqueDamper</b></a>
           <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>  <a href="#GetResultantTorque"><b>GetResultantTorque</b></a>
           <a href="#GetForceGravityPotentialEnergy"><b>GetForceGravityPotentialEnergy</b></a>  <a href="#GetForceSpringPotentialEnergy"><b>GetForceSpringPotentialEnergy</b></a>
           <a href="#GetForceElectrostaticPotentialEnergy"><b>GetForceElectrostaticPotentialEnergy</b></a>
           <a href="#GetForceInverseSquarePotentialEnergy"><b>GetForceInverseSquarePotentialEnergy</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: GetForceInverseSquarePotentialEnergy
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N             
   (5) Particle   P, Q             
   (6) Variable   x, y
   (7) Constant   coef
   (8) Q.SetPosition( P, x*Nx> + y*Ny> )
-> (9) p_P_Q> = x*Nx> + y*Ny>

   (10) PotentialEnergy = Q.GetForceInverseSquarePotentialEnergy( P, coef )
-> (11) PotentialEnergy = coef/sqrt(x^2+y^2)



</PRE><nobr><a name="GetForceGravityPotentialEnergy"><font color="darkBlue"><font size=+1><b>GetForceGravityPotentialEnergy</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetForceGravityPotentialEnergy

 Purpose:  Calculates potential energy associated with gravity forces.

Syntax 1:  Object.GetForceGravityPotentialEnergy( gravityVector, refPoint )
Syntax 2:  Q.GetForceGravityPotentialEnergy( P, G )

   Input:  Object -- The name of a Particle, RigidBody, or System.
           gravityVector -- A vector whose magnitude is equal to the
                            local gravitational acceleration constant
                            and whose direction is locally downward.
           refPoint -- The point above which potential energy is positive
                       and below which potential energy is negative.

           Q -- the name of a Particle
           P -- the name of a Particle
           G -- a scalar representing the universal gravitational
                constant, approximately 6.6732E-11 N m^2 kg^(-2).

Output 1:  Object's uniform gravitational potential energy for a given
           reference point, due to a uniform local gravitational force.

Output 2:  A potential energy due to the inverse square law
           gravitational force between P and Q.
           Note: Q's position vector from P must be available.

  Remark:  Ensure mass is assigned to appropriate particles and bodies
           before issuing an GetForceGravityPotentialEnergy command.

           NIST defines Earth's gravity acceleration as 9.80665 m/sec^2.
           The NIST approximation for G is 6.6732E-11 N m^2 kg^(-2).
           The mass of the Earth is approximately 5.97E24 kg.
           The mass of the Moon  is approximately 7.34E22 kg.
           Earth's equatorial radius is approximately 6356 km (3949.4 miles).

 Related:  <a href="#AddForce"><b>AddForce</b></a>  <a href="#AddForceDamper"><b>AddForceDamper</b></a>  <a href="#AddForceElectrostatic"><b>AddForceElectrostatic</b></a>  <a href="#AddForceGravity"><b>AddForceGravity</b></a>
           <a href="#AddForceInverseSquare"><b>AddForceInverseSquare</b></a>  <a href="#AddForceLinearActuator"><b>AddForceLinearActuator</b></a>  <a href="#AddForceSpring"><b>AddForceSpring</b></a>
           <a href="#AddTorque"><b>AddTorque</b></a>  <a href="#AddTorqueDamper"><b>AddTorqueDamper</b></a>
           <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>  <a href="#GetResultantTorque"><b>GetResultantTorque</b></a>
           <a href="#GetForceGravityPotentialEnergy"><b>GetForceGravityPotentialEnergy</b></a>  <a href="#GetForceSpringPotentialEnergy"><b>GetForceSpringPotentialEnergy</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetForceGravityPotentialEnergy  (local gravity on a particle)
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N             
   (5) Particle   Q             
   (6) Variable   xQ, yQ
   (7) Q.SetMass( mQ )
   (8) Q.SetPosition( No, xQ*Nx> + yQ*Ny> )
-> (9) p_No_Q> = xQ*Nx> + yQ*Ny>

   (10) QPotentialEnergy = Q.GetForceGravityPotentialEnergy( -9.81*Ny>, No )
-> (11) QPotentialEnergy = 9.81*mQ*yQ

   (12) %--------------------------------------------------------------------
   (13) % Example 2: GetForceGravityPotentialEnergy  (local gravity on rigid body)
   (14) %--------------------------------------------------------------------
   (15) RigidBody  B             
   (16) B.SetMass( mB )
   (17) Variable   xB, yB    
   (18) Bcm.SetPosition( No, xB*Nx> + yB*Ny> )
-> (19) p_No_Bcm> = xB*Nx> + yB*Ny>

   (20) BPotentialEnergy = B.GetPotentialEnergyGravity( -9.81*Ny>, No )
-> (21) BPotentialEnergy = 9.81*mB*yB

   (22) SPotentialEnergy = System.GetForceGravityPotentialEnergy( -9.81*Ny>, No )
-> (23) SPotentialEnergy = 9.81*mB*yB + 9.81*mQ*yQ

   (24) %--------------------------------------------------------------------
   (25) % Example 3: GetPotentialEnergyGravity  (universal gravity)
   (26) %--------------------------------------------------------------------
   (27) Constant   G       % Universal gravitational constant
   (28) Particle   P
   (29) Variable   x, y
   (30) P.SetMass( mP )
   (31) Q.SetPosition( P, x*Nx> + y*Ny> )
-> (32) p_P_Q> = x*Nx> + y*Ny>

   (33) InverseSquareLawPotentialEnergy = Q.GetForceGravityPotentialEnergy( P, G )
-> (34) InverseSquareLawPotentialEnergy = -mP*mQ*G/sqrt(x^2+y^2)



</PRE><nobr><a name="GetForceSpringPotentialEnergy"><font color="darkBlue"><font size=+1><b>GetForceSpringPotentialEnergy</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetForceSpringPotentialEnergy

 Purpose:  Calculates potential energy associated with a spring force.

Syntax 1:  Q.GetForceSpringPotentialEnergy( P, k, Ln )
Syntax 2:  Q.GetForceSpringPotentialEnergy( P, k, Ln, stretchExponent )

   Input:  Q -- the name of a point.
           P -- the name of a point.
           k -- the spring constant (scalar)
           Ln -- the spring's natural length (scalar)
           stretchExponent -- the exponent on the spring's stretch (scalar)

Output 1:  Potential energy of a linear spring associated with a
           spring force on Q from P whose magnitude is equal to
           k * stretch   where  stretch = L - Ln  and
           L is the distance between Q and P.

Output 2:  Potential energy of a linear spring associated with a
           spring force on Q from P whose magnitude is equal to
           k * stretch^stretchExponent.

  Remark:  Q's position vector from P must be available.

 Related:  <a href="#AddForce"><b>AddForce</b></a>  <a href="#AddForceDamper"><b>AddForceDamper</b></a>  <a href="#AddForceElectrostatic"><b>AddForceElectrostatic</b></a>  <a href="#AddForceGravity"><b>AddForceGravity</b></a>
           <a href="#AddForceInverseSquare"><b>AddForceInverseSquare</b></a>  <a href="#AddForceLinearActuator"><b>AddForceLinearActuator</b></a>  <a href="#AddForceSpring"><b>AddForceSpring</b></a>
           <a href="#AddTorque"><b>AddTorque</b></a>  <a href="#AddTorqueDamper"><b>AddTorqueDamper</b></a>
           <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>  <a href="#GetResultantTorque"><b>GetResultantTorque</b></a>
           <a href="#GetForceGravityPotentialEnergy"><b>GetForceGravityPotentialEnergy</b></a>  <a href="#GetForceSpringPotentialEnergy"><b>GetForceSpringPotentialEnergy</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetForceSpringPotentialEnergy  (natural length is 0)
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N
   (5) Particle  P1, Q1
   (6) Variable  x, y
   (7) Constant  k, Ln
   (8) Q1.SetPosition( P1, x*Nx> )
-> (9) p_P1_Q1> = x*Nx>

   (10) PE1 = Q1.GetForceSpringPotentialEnergy( P1, k, 0 )
-> (11) PE1 = 0.5*k*x^2

   (12) %--------------------------------------------------------------------
   (13) % Example 2: GetForceSpringPotentialEnergy  (natural length is Ln)
   (14) %--------------------------------------------------------------------
   (15) Particle  P2, Q2
   (16) Q2.SetPosition( P2, x*Nx> )
-> (17) p_P2_Q2> = x*Nx>

   (18) PE2 = Q2.GetForceSpringPotentialEnergy( P2, k, Ln )
-> (19) PE2 = 0.5*k*(Ln-abs(x))^2

   (20) %--------------------------------------------------------------------
   (21) % Example 3: GetForceSpringPotentialEnergy (natural length is Ln; exponent 3)
   (22) %--------------------------------------------------------------------
   (23) Particle  P3, Q3
   (24) Q3.SetPosition( P3, x*Nx> )
-> (25) p_P3_Q3> = x*Nx>

   (26) PE3 = Q3.GetForceSpringPotentialEnergy( P3, k, Ln, 3 )
-> (27) PE3 = 0.25*k*(Ln-abs(x))^4

   (28) %--------------------------------------------------------------------
   (29) % Example 4: GetForceSpringPotentialEnergy  (natural length is Ln; exponent -1)
   (30) %--------------------------------------------------------------------
   (31) Particle  P4, Q4
   (32) Q4.SetPosition( P4, x*Nx> + y*Ny> )
-> (33) p_P4_Q4> = x*Nx> + y*Ny>

   (34) PE4 = Q4.GetForceSpringPotentialEnergy( P4, k, Ln, -1 )
-> (35) PE4 = k*log(sqrt(x^2+y^2)-Ln)



</PRE><nobr><a name="GetGeneralizedEffectiveForce"><font color="darkBlue"><font size=+1><b>GetGeneralizedEffectiveForce</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetGeneralizedEffectiveForce

 Purpose:  Forms expressions for generalized effective forces or
           contributions to generalized effective forces.

  Syntax:  Object.GetGeneralizedEffectiveForce()

   Input:  Object -- The name of a Particle, RigidBody, or System.

  Output:  Column matrix, each element of which is the contribution of
           Object to a generalized effective force in the NewtonianFrame.

  Remark:  The results produced by this command depend on whether
           the command precedes or follows a CONSTRAIN command.

 Related:  <a href="#GetGeneralizedEffectiveForce"><b>GetGeneralizedEffectiveForce</b></a>  <a href="#GetGeneralizedForce"><b>GetGeneralizedForce</b></a>
           <a href="#GetMomentOfEffectiveForce"><b>GetMomentOfEffectiveForce</b></a>   <a href="#GetEffectiveForce"><b>GetEffectiveForce</b></a>
           <a href="#GetAngularMomentum"><b>GetAngularMomentum</b></a>  <a href="#GetTranslationalMomentum"><b>GetTranslationalMomentum</b></a>  <a href="#GetGeneralizedMomentum"><b>GetGeneralizedMomentum</b></a>
           <a href="#GetKineticEnergy"><b>GetKineticEnergy</b></a>    <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>
           <a href="#Gyrostat"><b>Gyrostat</b></a>  <a href="#SetGeneralizedSpeed"><b>SetGeneralizedCoordinate</b></a>  <a href="#SetGeneralizedSpeed"><b>SetGeneralizedSpeed</b></a>
           <a href="#SetMass"><b>SetMass</b></a>  <a href="#SetInertia"><b>SetInertia</b></a>  <a href="#Rotate"><b>Rotate</b></a>  <a href="#Translate"><b>Translate</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetGeneralizedEffectiveForce
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N
   (5) Particle  A
   (6) RigidBody B
   (7) A.SetMass( mA )
   (8) B.SetMass( mB )
   (9) B.SetInertia( Bcm, Ixx, Iyy, Izz )
   (10) Variable  w{1:3}', vA'
   (11) SetGeneralizedSpeed( w{1:3}, vA )
   (12) A.SetVelocity( N, vA*Nx> )
-> (13) v_A_N> = vA*Nx>

   (14) B.SetAngularVelocity( N, w1*Bx> + w2*By> + w3*Bz> )
-> (15) w_B_N> = w1*Bx> + w2*By> + w3*Bz>

   (16) Bcm.SetVelocity( N, 0> )
-> (17) v_Bcm_N> = 0>

   (18) FrEffectiveA = A.GetGeneralizedEffectiveForce()
-> (19) FrEffectiveA = [0;  0;  0;  mA*vA']

   (20) FrEffectiveB = B.GetGeneralizedEffectiveForce()
-> (21) FrEffectiveB[1] = Ixx*w1' - (Iyy-Izz)*w2*w3
-> (22) FrEffectiveB[2] = (Ixx-Izz)*w1*w3 + Iyy*w2'
-> (23) FrEffectiveB[3] = Izz*w3' - (Ixx-Iyy)*w1*w2
-> (24) FrEffectiveB[4] = 0

   (25) FrEffectiveS = System.GetGeneralizedEffectiveForce()
-> (26) FrEffectiveS[1] = Ixx*w1' - (Iyy-Izz)*w2*w3
-> (27) FrEffectiveS[2] = (Ixx-Izz)*w1*w3 + Iyy*w2'
-> (28) FrEffectiveS[3] = Izz*w3' - (Ixx-Iyy)*w1*w2
-> (29) FrEffectiveS[4] = mA*vA'



</PRE><nobr><a name="GetGeneralizedForce"><font color="darkBlue"><font size=+1><b>GetGeneralizedForce</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetGeneralizedForce

 Purpose:  Forms expressions for a system's generalized forces.

  Syntax:  System.GetGeneralizedForce()

  Output:  Column matrix, each element of which is the contribution of
           forces and torques to one generalized force in the NewtonianFrame.

  Remark:  The results produced by this command depend on whether
           the command precedes or follows a CONSTRAIN command.

 Related:  <a href="#AddForce"><b>AddForce</b></a>  <a href="#AddForceDamper"><b>AddForceDamper</b></a>  <a href="#AddForceElectrostatic"><b>AddForceElectrostatic</b></a>  <a href="#AddForceGravity"><b>AddForceGravity</b></a>
           <a href="#AddForceInverseSquare"><b>AddForceInverseSquare</b></a>  <a href="#AddForceLinearActuator"><b>AddForceLinearActuator</b></a>  <a href="#AddForceSpring"><b>AddForceSpring</b></a>
           <a href="#AddTorque"><b>AddTorque</b></a>  <a href="#AddTorqueDamper"><b>AddTorqueDamper</b></a>
           <a href="#GetGeneralizedEffectiveForce"><b>GetGeneralizedEffectiveForce</b></a>  <a href="#GetGeneralizedForce"><b>GetGeneralizedForce</b></a>
           <a href="#GetGeneralizedMomentum"><b>GetGeneralizedMomentum</b></a>  <a href="#GetTranslationalMomentum"><b>GetTranslationalMomentum</b></a>  <a href="#GetAngularMomentum"><b>GetAngularMomentum</b></a>
           <a href="#SetGeneralizedSpeed"><b>SetGeneralizedCoordinate</b></a>  <a href="#SetGeneralizedSpeed"><b>SetGeneralizedSpeed</b></a>
           <a href="#SetMass"><b>SetMass</b></a>  <a href="#SetInertia"><b>SetInertia</b></a>  <a href="#Rotate"><b>Rotate</b></a>  <a href="#Translate"><b>Translate</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetGeneralizedForce
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N
   (5) Particle  A, B, C
   (6) Constant  k
   (7) Variable  q1', q2'
   (8) SetGeneralizedSpeed( q1', q2' )
   (9) A.SetVelocity( N, q1'*Nx> )
-> (10) v_A_N> = q1'*Nx>

   (11) B.SetVelocity( N, (q1'+q2')*Nx> )
-> (12) v_B_N> = (q1'+q2')*Nx>

   (13) C.SetVelocity( N,  2*q2'*Ny> )
-> (14) v_C_N> = 2*q2'*Ny>

   (15) A.AddForce( -k*q1*Nx> )
-> (16) Force_A> = -k*q1*Nx>

   (17) B.AddForce( A, -k*q2*Nx> )
-> (18) Force_B_A> = -k*q2*Nx>

   (19) C.AddForce( A, 3*Ny> )
-> (20) Force_C_A> = 3*Ny>

   (21) Fr = System.GetGeneralizedForce()
-> (22) Fr = [-k*q1;  6 - k*q2]



</PRE><nobr><a name="GetGeneralizedMomentum"><font color="darkBlue"><font size=+1><b>GetGeneralizedMomentum</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetGeneralizedMomentum

 Purpose:  Forms expressions for generalized momenta or
           contributions to generalized momenta.

  Syntax:  Object.GetGeneralizedMomentum()

   Input:  Object -- The name of a Particle, RigidBody, or System.

  Output:  Column matrix, each element of which is the contribution of
           Object to a generalized momenta in the NewtonianFrame.

  Remark:  The results produced by this command depend on whether
           the command precedes or follows a CONSTRAIN command.

 Related:  <a href="#GetAngularMomentum"><b>GetAngularMomentum</b></a>  <a href="#GetTranslationalMomentum"><b>GetTranslationalMomentum</b></a>  <a href="#GetGeneralizedMomentum"><b>GetGeneralizedMomentum</b></a>
           <a href="#GetKineticEnergy"><b>GetKineticEnergy</b></a>    <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>
           <a href="#Gyrostat"><b>Gyrostat</b></a>  <a href="#SetGeneralizedSpeed"><b>SetGeneralizedCoordinate</b></a>  <a href="#SetGeneralizedSpeed"><b>SetGeneralizedSpeed</b></a>
           <a href="#SetMass"><b>SetMass</b></a>  <a href="#SetInertia"><b>SetInertia</b></a>  <a href="#Rotate"><b>Rotate</b></a>  <a href="#Translate"><b>Translate</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetGeneralizedMomentum
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N
   (5) Particle  A
   (6) RigidBody B
   (7) A.SetMass( mA )
   (8) B.SetMass( mB )
   (9) B.SetInertia( Bcm, Ixx, Iyy, Izz )
   (10) Variable  w{1:3}', vA'
   (11) SetGeneralizedSpeed( w{1:3}, vA )
   (12) A.SetVelocity( N, vA*Nx> )
-> (13) v_A_N> = vA*Nx>

   (14) B.SetAngularVelocity( N, w1*Bx> + w2*By> + w3*Bz> )
-> (15) w_B_N> = w1*Bx> + w2*By> + w3*Bz>

   (16) Bcm.SetVelocity( N, 0> )
-> (17) v_Bcm_N> = 0>

   (18) generalizedMomentaA = A.GetGeneralizedMomentum()
-> (19) generalizedMomentaA = [0;  0;  0;  mA*vA]

   (20) generalizedMomentaB = B.GetGeneralizedMomentum()
-> (21) generalizedMomentaB = [Ixx*w1;  Iyy*w2;  Izz*w3;  0]

   (22) generalizedMomentaS = System.GetGeneralizedMomentum()
-> (23) generalizedMomentaS = [Ixx*w1;  Iyy*w2;  Izz*w3;  mA*vA]



</PRE><nobr><a name="GetIdentityMatrix"><font color="darkBlue"><font size=+1><b>GetIdentityMatrix</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetZeroMatrix     or    GetIdentityMatrix

 Purpose:  Forms a square or rectangular zero or identity matrix.

Syntax 1:  GetZeroMatrix( m )
Syntax 2:  GetZeroMatrix( m, n )
Syntax 3:  GetIdentityMatrix( m )
Syntax 4:  GetIdentityMatrix( m, n )

   Input:  m, n -- positive integers (m rows, n columns).

Output 1:  m x m  matrix with 0 as every element.
Output 2:  m x n  matrix with 0 as every element.

Output 3:  m x m diagonal matrix with the number 1 on each diagonal
                 element and 0 on every off-diagonal element.

Output 4:  m x n matrix with the number 1 for elements whose row and column
           indices are equal and the number 0 for the remaining elements.

 Related:  <a href="#GetColumns"><b>GetColumns</b></a>     <a href="#GetDeterminant"><b>GetDeterminant</b></a>  <a href="#GetDiagonalMatrix"><b>GetDiagonalMatrix</b></a>  <a href="#GetEigen"><b>GetEigen</b></a>
           <a href="#GetElement"><b>GetElement</b></a> <a href="#[]"><b>[]</b></a>  <a href="#GetInverse"><b>GetInverse</b></a>      <a href="#GetIdentityMatrix"><b>GetIdentityMatrix</b></a>  <a href="#GetNorm"><b>GetNorm</b></a>  <a href="#GetColumns"><b>GetRows</b></a>
           <a href="#GetTrace"><b>GetTrace</b></a>       <a href="#GetTranspose"><b>GetTranspose</b></a>    <a href="#GetIdentityMatrix"><b>GetZeroMatrix</b></a>      <a href="#Solve"><b>Solve</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: GetIdentityMatrix 
   (3) %--------------------------------------------------------------------
   (4) Ia = GetIdentityMatrix( 3 )
-> (5) Ia = [1, 0, 0;  0, 1, 0;  0, 0, 1]

   (6) Ib = GetIdentityMatrix( 3, 4 )
-> (7) Ib = [1, 0, 0, 0;  0, 1, 0, 0;  0, 0, 1, 0]

   (8) Ic = GetIdentityMatrix( 4, 3 )
-> (9) Ic = [1, 0, 0;  0, 1, 0;  0, 0, 1;  0, 0, 0]

   (10) %--------------------------------------------------------------------
   (11) % Example: GetZeroMatrix 
   (12) %--------------------------------------------------------------------
   (13) Za = GetZeroMatrix( 3 )
-> (14) Za = [0, 0, 0;  0, 0, 0;  0, 0, 0]

   (15) Zb = GetZeroMatrix( 2, 3 )
-> (16) Zb = [0, 0, 0;  0, 0, 0]

   (17) Zc = GetZeroMatrix( 3, 1 )
-> (18) Zc = [0;  0;  0]



</PRE><nobr><a name="GetInertiaDyadic"><font color="darkBlue"><font size=+1><b>GetInertiaDyadic</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetInertiaDyadic

 Purpose:  Gets an object's inertia dyadic about a point.

Syntax 1:  Object.GetInertiaDyadic( aboutPoint )
Syntax 2:  Object.GetInertiaDyadic( aboutPoint, expressBasis )

   Input:  Object       -- name of a Particle, RigidBody, or System.
           aboutPoint   -- name of a point or particle.
           expressBasis -- name of a RigidFrame or RigidBody.

Output 1:  Object's inertia dyadic about aboutPoint.
Output 2:  Object's inertia dyadic about aboutPoint expressed in expressBasis.

  Remark:  Products of inertia adhere to the "negative sign convention".
           Example: For a 1 kg particle whose position from a point P is
           2*Nx> + 3*Ny>, the product of inertia Ixy = -m*x*y = -6 kg*m^2.

 Related:  <a href="#SetMass"><b>SetMass</b></a>          <a href="#GetMass"><b>GetMass</b></a>         <a href="#SetInertia"><b>SetInertia</b></a>
           <a href="#GetCMPosition"><b>GetCMPosition</b></a>    <a href="#GetCMVelocity"><b>GetCmVelocity</b></a>   <a href="#GetCMAcceleration"><b>GetCmAcceleration</b></a>
           <a href="#GetInertiaDyadic"><b>GetInertiaDyadic</b></a>  <a href="#GetInertiaMatrix"><b>GetInertiaMatrix</b></a>  <a href="#GetMomentOfInertia"><b>GetMomentOfInertia</b></a>
           <a href="#GetProductOfInertia"><b>GetProductOfInertia</b></a>  <a href="#GetRadiusOfGyration"><b>GetRadiusOfGyration</b></a>  <a href="#GetInertiaVector"><b>GetInertiaVector</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetInertiaDyadic  (inertia dyadic of a rigid body)
   (3) %--------------------------------------------------------------------
   (4) RigidBody  B
   (5) B.SetInertia( Bcm, Ixx, Iyy, Izz )
   (6) BInertiaDyadicAboutBcm>> = B.GetInertiaDyadic( Bcm )
-> (7) BInertiaDyadicAboutBcm>> = Ixx*Bx>*Bx> + Iyy*By>*By> + Izz*Bz>*Bz>

   (8) %--------------------------------------------------------------------
   (9) % Example 2: GetInertiaDyadic  (inertia dyadic in designated basis)
   (10) %--------------------------------------------------------------------
   (11) RigidFrame A
   (12) Variable  theta
   (13) B.SetRotationMatrixZ( A, theta )
-> (14) B_A = [cos(theta), sin(theta), 0;  -sin(theta), cos(theta), 0;  0, 0, 1]

   (15) BInertiaDyadicAboutBcmExpressedInA>> = B.GetInertiaDyadic( Bcm, A )
-> (16) BInertiaDyadicAboutBcmExpressedInA>> = (Ixx*cos(theta)^2+Iyy*sin(theta)^2)
        *Ax>*Ax> + (Ixx-Iyy)*sin(theta)*cos(theta)*Ax>*Ay> + (Ixx-Iyy)*sin(the
        ta)*cos(theta)*Ay>*Ax> + (Iyy+(Ixx-Iyy)*sin(theta)^2)*Ay>*Ay> + Izz*Az>*Az>

   (17) %--------------------------------------------------------------------
   (18) % Example 3: GetInertiaDyadic  (inertia dyadic of a particle)
   (19) %--------------------------------------------------------------------
   (20) Particle   Q
   (21) Q.SetMass( mQ )
   (22) Variable   x, y, z
   (23) Q.SetPosition( Bo, x*Bx> + y*By> + z*Bz> )
-> (24) p_Bo_Q> = x*Bx> + y*By> + z*Bz>

   (25) QInertiaDyadicAboutBoExpressedInB>> = Q.GetInertiaDyadic( Bo, B )
-> (26) QInertiaDyadicAboutBoExpressedInB>> = mQ*(y^2+z^2)*Bx>*Bx> - mQ*x*y*Bx>*By>
        - mQ*x*z*Bx>*Bz> - mQ*x*y*By>*Bx> + mQ*(x^2+z^2)*By>*By> - mQ*y*z*By>*Bz>
        - mQ*x*z*Bz>*Bx> - mQ*y*z*Bz>*By> + mQ*(x^2+y^2)*Bz>*Bz>

   (27) %--------------------------------------------------------------------
   (28) % Example 4: GetInertiaDyadic  (inertia dyadic of a system)
   (29) %--------------------------------------------------------------------
   (30) B.SetMass( mB )
   (31) Bcm.SetPosition( Bo, 2*Bx> + 3*By> + 4*Bz> )
-> (32) p_Bo_Bcm> = 2*Bx> + 3*By> + 4*Bz>

   (33) SystemInertiaDyadicAboutBoExpressedInB>> = System.GetInertiaDyadic( Bo, B )
-> (34) SystemInertiaDyadicAboutBoExpressedInB>> = (Ixx+25*mB+mQ*(y^2+z^2))*Bx>*Bx>
        + (-6*mB-mQ*x*y)*Bx>*By> + (-8*mB-mQ*x*z)*Bx>*Bz> + (-6*mB-mQ*x*y)*By>*Bx>
        + (Iyy+20*mB+mQ*(x^2+z^2))*By>*By> + (-12*mB-mQ*y*z)*By>*Bz> + (-8*mB-
        mQ*x*z)*Bz>*Bx> + (-12*mB-mQ*y*z)*Bz>*By> + (Izz+13*mB+mQ*(x^2+y^2))*
        Bz>*Bz>



</PRE><nobr><a name="GetInertiaMatrix"><font color="darkBlue"><font size=+1><b>GetInertiaMatrix</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetInertiaMatrix

 Purpose:  Gets an object's inertia matrix about a point.

  Syntax:  Object.GetInertiaMatrix( aboutPoint, expressBasis )

   Input:  Object       -- name of a Particle, RigidBody, or System.
           aboutPoint   -- name of a Point or Particle.
           expressBasis -- name of a RigidFrame or RigidBody.

  Output:  Object's inertia matrix about aboutPoint expressed in expressBasis.

  Remark:  Products of inertia adhere to the "negative sign convention".
           Example: For a 1 kg particle whose position from a point P is
           2*Nx> + 3*Ny>, the product of inertia Ixy = -m*x*y = -6 kg*m^2.

 Related:  <a href="#SetMass"><b>SetMass</b></a>          <a href="#GetMass"><b>GetMass</b></a>         <a href="#SetInertia"><b>SetInertia</b></a>
           <a href="#GetCMPosition"><b>GetCMPosition</b></a>    <a href="#GetCMVelocity"><b>GetCmVelocity</b></a>   <a href="#GetCMAcceleration"><b>GetCmAcceleration</b></a>
           <a href="#GetInertiaDyadic"><b>GetInertiaDyadic</b></a>  <a href="#GetInertiaMatrix"><b>GetInertiaMatrix</b></a>  <a href="#GetMomentOfInertia"><b>GetMomentOfInertia</b></a>
           <a href="#GetProductOfInertia"><b>GetProductOfInertia</b></a>  <a href="#GetRadiusOfGyration"><b>GetRadiusOfGyration</b></a>  <a href="#GetInertiaVector"><b>GetInertiaVector</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetInertiaMatrix  (inertia matrix of a rigid body)
   (3) %--------------------------------------------------------------------
   (4) RigidBody  B
   (5) B.SetInertia( Bcm, Ixx, Iyy, Izz )
   (6) BInertiaMatrixAboutBcmInB = B.GetInertiaMatrix( Bcm, B )
-> (7) BInertiaMatrixAboutBcmInB = [Ixx, 0, 0;  0, Iyy, 0;  0, 0, Izz]

   (8) %--------------------------------------------------------------------
   (9) % Example 2: GetInertiaMatrix  (inertia matrix in another basis)
   (10) %--------------------------------------------------------------------
   (11) RigidFrame A
   (12) Variable  theta
   (13) B.SetRotationMatrixZ( A, theta )
-> (14) B_A = [cos(theta), sin(theta), 0;  -sin(theta), cos(theta), 0;  0, 0, 1]

   (15) BInertiaMatrixAboutBcmInA = B.GetInertiaMatrix( Bcm, A )
-> (16) BInertiaMatrixAboutBcmInA[1,1] = Ixx*cos(theta)^2 + Iyy*sin(theta)^2
-> (17) BInertiaMatrixAboutBcmInA[1,2] = (Ixx-Iyy)*sin(theta)*cos(theta)
-> (18) BInertiaMatrixAboutBcmInA[1,3] = 0
-> (19) BInertiaMatrixAboutBcmInA[2,1] = (Ixx-Iyy)*sin(theta)*cos(theta)
-> (20) BInertiaMatrixAboutBcmInA[2,2] = Iyy + (Ixx-Iyy)*sin(theta)^2
-> (21) BInertiaMatrixAboutBcmInA[2,3] = 0
-> (22) BInertiaMatrixAboutBcmInA[3,1] = 0
-> (23) BInertiaMatrixAboutBcmInA[3,2] = 0
-> (24) BInertiaMatrixAboutBcmInA[3,3] = Izz

   (25) %--------------------------------------------------------------------
   (26) % Example 3: GetInertiaMatrix  (inertia matrix of a particle)
   (27) %--------------------------------------------------------------------
   (28) Particle   Q
   (29) Q.SetMass( mQ )
   (30) Variable   x, y, z
   (31) Q.SetPosition( Bo, x*Bx> + y*By> + z*Bz> )
-> (32) p_Bo_Q> = x*Bx> + y*By> + z*Bz>

   (33) QInertiaMatrixAboutBoInB = Q.GetInertiaMatrix( Bo, B )
-> (34) QInertiaMatrixAboutBoInB[1,1] = mQ*(y^2+z^2)
-> (35) QInertiaMatrixAboutBoInB[1,2] = -mQ*x*y
-> (36) QInertiaMatrixAboutBoInB[1,3] = -mQ*x*z
-> (37) QInertiaMatrixAboutBoInB[2,1] = -mQ*x*y
-> (38) QInertiaMatrixAboutBoInB[2,2] = mQ*(x^2+z^2)
-> (39) QInertiaMatrixAboutBoInB[2,3] = -mQ*y*z
-> (40) QInertiaMatrixAboutBoInB[3,1] = -mQ*x*z
-> (41) QInertiaMatrixAboutBoInB[3,2] = -mQ*y*z
-> (42) QInertiaMatrixAboutBoInB[3,3] = mQ*(x^2+y^2)

   (43) %--------------------------------------------------------------------
   (44) % Example 4: GetInertiaDyadic  (inertia matrix of a system)
   (45) %--------------------------------------------------------------------
   (46) B.SetMass( mB )
   (47) Bcm.SetPosition( Bo, 2*Bx> + 3*By> + 4*Bz> )
-> (48) p_Bo_Bcm> = 2*Bx> + 3*By> + 4*Bz>

   (49) SystemInertiaMatrixAboutBoInB = System.GetInertiaMatrix( Bo, B )
-> (50) SystemInertiaMatrixAboutBoInB[1,1] = Ixx + 25*mB + mQ*(y^2+z^2)
-> (51) SystemInertiaMatrixAboutBoInB[1,2] = -6*mB - mQ*x*y
-> (52) SystemInertiaMatrixAboutBoInB[1,3] = -8*mB - mQ*x*z
-> (53) SystemInertiaMatrixAboutBoInB[2,1] = -6*mB - mQ*x*y
-> (54) SystemInertiaMatrixAboutBoInB[2,2] = Iyy + 20*mB + mQ*(x^2+z^2)
-> (55) SystemInertiaMatrixAboutBoInB[2,3] = -12*mB - mQ*y*z
-> (56) SystemInertiaMatrixAboutBoInB[3,1] = -8*mB - mQ*x*z
-> (57) SystemInertiaMatrixAboutBoInB[3,2] = -12*mB - mQ*y*z
-> (58) SystemInertiaMatrixAboutBoInB[3,3] = Izz + 13*mB + mQ*(x^2+y^2)



</PRE><nobr><a name="GetInertiaScalar"><font color="darkBlue"><font size=+1><b>GetInertiaScalar</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetInertiaScalar

 Purpose:  Gets an object's inertia scalar about a point for
           two unit vectors.

  Syntax:  Object.GetInertiaScalar( aboutPoint, unitVectorA, unitVectorB )

   Input:  Object -- The name of a Particle, RigidBody, or System.
           aboutPoint -- The name of a point or particle.
           unitVectorA -- Unit vector or expression for a unit vector.
           unitVectorB -- Unit vector or expression for a unit vector.

  Output:  Object's inertia scalar about aboutPoint for the
           unit vectors unitVectorA and unitVectorB.

  Remark:  Products of inertia adhere to the "negative sign convention".
           Example: For a 1 kg particle whose position from a point P is
           2*Nx> + 3*Ny>, the product of inertia Ixy = -m*x*y = -6 kg*m^2.

 Related:  <a href="#SetMass"><b>SetMass</b></a>          <a href="#GetMass"><b>GetMass</b></a>         <a href="#SetInertia"><b>SetInertia</b></a>
           <a href="#GetCMPosition"><b>GetCMPosition</b></a>    <a href="#GetCMVelocity"><b>GetCmVelocity</b></a>   <a href="#GetCMAcceleration"><b>GetCmAcceleration</b></a>
           <a href="#GetInertiaDyadic"><b>GetInertiaDyadic</b></a>  <a href="#GetInertiaMatrix"><b>GetInertiaMatrix</b></a>  <a href="#GetMomentOfInertia"><b>GetMomentOfInertia</b></a>
           <a href="#GetProductOfInertia"><b>GetProductOfInertia</b></a>  <a href="#GetRadiusOfGyration"><b>GetRadiusOfGyration</b></a>  <a href="#GetInertiaVector"><b>GetInertiaVector</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetInertiaScalar  (inertia scalar of a rigid body)
   (3) %--------------------------------------------------------------------
   (4) RigidBody  B
   (5) B.SetInertia( Bcm, Ixx, Iyy, Izz )
   (6) BInertiaScalarAboutBcmForBxBx = B.GetInertiaScalar( Bcm, Bx>, Bx> )
-> (7) BInertiaScalarAboutBcmForBxBx = Ixx

   (8) %--------------------------------------------------------------------
   (9) % Example 2: GetInertiaScalar  (inertia scalar in another basis)
   (10) %--------------------------------------------------------------------
   (11) RigidFrame A
   (12) Variable  theta
   (13) B.SetRotationMatrixZ( A, theta )
-> (14) B_A = [cos(theta), sin(theta), 0;  -sin(theta), cos(theta), 0;  0, 0, 1]

   (15) BInertiaScalarAboutBcmForAxAx = B.GetInertiaScalar( Bcm, Ax>, Ay> )
-> (16) BInertiaScalarAboutBcmForAxAx = (Ixx-Iyy)*sin(theta)*cos(theta)

   (17) %--------------------------------------------------------------------
   (18) % Example 3: GetInertiaScalar  (inertia scalar of a particle)
   (19) %--------------------------------------------------------------------
   (20) Particle   Q
   (21) Q.SetMass( mQ )
   (22) Variable   x, y, z
   (23) Q.SetPosition( Bo, x*Bx> + y*By> + z*Bz> )
-> (24) p_Bo_Q> = x*Bx> + y*By> + z*Bz>

   (25) QInertiaScalarAboutBoForBxBx = Q.GetInertiaScalar( Bo, Bx>, Bx> )
-> (26) QInertiaScalarAboutBoForBxBx = mQ*(y^2+z^2)

   (27) QInertiaScalarAboutBoForByBz = Q.GetInertiaScalar( Bo, By>, Bz> )
-> (28) QInertiaScalarAboutBoForByBz = -mQ*y*z

   (29) %--------------------------------------------------------------------
   (30) % Example 4: GetInertiaScalar  (inertia scalar of a system)
   (31) %--------------------------------------------------------------------
   (32) B.SetMass( mB )
   (33) Bcm.SetPosition( Bo, 2*Bx> + 3*By> + 4*Bz> )
-> (34) p_Bo_Bcm> = 2*Bx> + 3*By> + 4*Bz>

   (35) SystemInertiaScalarAboutBoForByBy = System.GetInertiaScalar( Bo, By>, By> )
-> (36) SystemInertiaScalarAboutBoForByBy = Iyy + 20*mB + mQ*(x^2+z^2)

   (37) SystemInertiaScalarAboutBoForAyAy = System.GetInertiaScalar( Bo, Ay>, Ay> )
-> (38) SystemInertiaScalarAboutBoForAyAy = Iyy + 20*mB + mQ*(x^2+z^2) - sin(
        theta)*(Iyy*sin(theta)+12*mB*cos(theta)+mQ*x^2*sin(theta)+2*mQ*x*y*cos(
        theta)-5*mB*sin(theta)-Ixx*sin(theta)-mQ*y^2*sin(theta))



</PRE><nobr><a name="GetInertiaVector"><font color="darkBlue"><font size=+1><b>GetInertiaVector</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetInertiaVector

 Purpose:  Gets an object's inertia vector for a unit vector.

  Syntax:  Object.GetInertiaVector( aboutPoint, unitVector )

   Input:  Object -- The name of a Particle, RigidBody, or System.
           aboutPoint -- The name of a point or Particle.
           unitVector -- Unit vector or expression for a unit vector.

  Output:  Object's inertia vector aboutPoint for unitVector.

  Remark:  Products of inertia adhere to the "negative sign convention".
           Example: For a 1 kg particle whose position from a point P is
           2*Nx> + 3*Ny>, the product of inertia Ixy = -m*x*y = -6 kg*m^2.

 Related:  <a href="#SetMass"><b>SetMass</b></a>          <a href="#GetMass"><b>GetMass</b></a>         <a href="#SetInertia"><b>SetInertia</b></a>
           <a href="#GetCMPosition"><b>GetCMPosition</b></a>    <a href="#GetCMVelocity"><b>GetCmVelocity</b></a>   <a href="#GetCMAcceleration"><b>GetCmAcceleration</b></a>
           <a href="#GetInertiaDyadic"><b>GetInertiaDyadic</b></a>  <a href="#GetInertiaMatrix"><b>GetInertiaMatrix</b></a>  <a href="#GetMomentOfInertia"><b>GetMomentOfInertia</b></a>
           <a href="#GetProductOfInertia"><b>GetProductOfInertia</b></a>  <a href="#GetRadiusOfGyration"><b>GetRadiusOfGyration</b></a>  <a href="#GetInertiaVector"><b>GetInertiaVector</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetInertiaVector  (inertia vector of a rigid body)
   (3) %--------------------------------------------------------------------
   (4) RigidBody  B
   (5) B.SetInertia( Bcm, Ixx, Iyy, Izz )
   (6) BInertiaVectorAboutBcmForBx> = B.GetInertiaVector( Bcm, Bx> )
-> (7) BInertiaVectorAboutBcmForBx> = Ixx*Bx>

   (8) %--------------------------------------------------------------------
   (9) % Example 2: GetInertiaVector  (inertia vector for Ax>)
   (10) %--------------------------------------------------------------------
   (11) RigidFrame A
   (12) Variable  theta
   (13) B.SetRotationMatrixZ( A, theta )
-> (14) B_A = [cos(theta), sin(theta), 0;  -sin(theta), cos(theta), 0;  0, 0, 1]

   (15) BInertiaVectorAboutBcmForAx> = B.GetInertiaVector( Bcm, Ax> )
-> (16) BInertiaVectorAboutBcmForAx> = Ixx*cos(theta)*Bx> - Iyy*sin(theta)*By>

   (17) %--------------------------------------------------------------------
   (18) % Example 3: GetInertiaVector  (inertia vector of a particle)
   (19) %--------------------------------------------------------------------
   (20) Particle   Q
   (21) Q.SetMass( mQ )
   (22) Variable   x, y, z
   (23) Q.SetPosition( Bo, x*Bx> + y*By> + z*Bz> )
-> (24) p_Bo_Q> = x*Bx> + y*By> + z*Bz>

   (25) QInertiaVectorAboutBoForBx> = Q.GetInertiaVector( Bo, Bx> )
-> (26) QInertiaVectorAboutBoForBx> = mQ*(y^2+z^2)*Bx> - mQ*x*y*By> - mQ*x*z*Bz>

   (27) %--------------------------------------------------------------------
   (28) % Example 4: GetInertiaVector  (inertia vector of a system)
   (29) %--------------------------------------------------------------------
   (30) B.SetMass( mB )
   (31) Bcm.SetPosition( Bo, 2*Bx> + 3*By> + 4*Bz> )
-> (32) p_Bo_Bcm> = 2*Bx> + 3*By> + 4*Bz>

   (33) SInertiaVectorAboutBoForBx> = System.GetInertiaVector( Bo, Bx> )
-> (34) SInertiaVectorAboutBoForBx> = (Ixx+25*mB+mQ*(y^2+z^2))*Bx> + (-6*mB-mQ*
        x*y)*By> + (-8*mB-mQ*x*z)*Bz>



</PRE><nobr><a name="GetInverse"><font color="darkBlue"><font size=+1><b>GetInverse</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetInverse

 Purpose:  Forms the inverse of a matrix or a dyadic.

Syntax 1:  GetInverse( squareMatrixOrDyadic )
Syntax 2:  GetDeterminant( Option, squareMatrixOrDyadic )

   Input:  squareMatrixOrDyadic -- a  square matrix or a dyadic
           Option -- MINORS or GAUSS

  Output:  Inverse of squareMatrixOrDyadic

  Remark:  Matrix inversion is calculated by one of two methods.
           MINORS is advantageous for relatively small matrices
           whereas GAUSS may be better for relatively large ones.
           If neither MINORS or GAUSS is specified, a method is
           chosen based on the size and number of non-numerical
           elements in the squareMatrixOfDyadic.

 Related:  <a href="#GetColumns"><b>GetColumns</b></a>     <a href="#GetDeterminant"><b>GetDeterminant</b></a>  <a href="#GetDiagonalMatrix"><b>GetDiagonalMatrix</b></a>  <a href="#GetEigen"><b>GetEigen</b></a>
           <a href="#GetElement"><b>GetElement</b></a> <a href="#[]"><b>[]</b></a>  <a href="#GetInverse"><b>GetInverse</b></a>      <a href="#GetIdentityMatrix"><b>GetIdentityMatrix</b></a>  <a href="#GetNorm"><b>GetNorm</b></a>  <a href="#GetColumns"><b>GetRows</b></a>
           <a href="#GetTrace"><b>GetTrace</b></a>       <a href="#GetTranspose"><b>GetTranspose</b></a>    <a href="#GetIdentityMatrix"><b>GetZeroMatrix</b></a>      <a href="#Solve"><b>Solve</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetInverse  (inverse of a matrix)
   (3) %--------------------------------------------------------------------
   (4) Constant  a, b, c, d
   (5) M = [a, b;  c, d]
-> (6) M = [a, b;  c, d]

   (7) inverse = GetInverse( M )
-> (8) inverse[1,1] = d/(a*d-b*c)
-> (9) inverse[1,2] = -b/(a*d-b*c)
-> (10) inverse[2,1] = -c/(a*d-b*c)
-> (11) inverse[2,2] = a/(a*d-b*c)

   (12) inverseWithMinors = GetInverse( MINORS, M )
-> (13) inverseWithMinors[1,1] = d/(a*d-b*c)
-> (14) inverseWithMinors[1,2] = -b/(a*d-b*c)
-> (15) inverseWithMinors[2,1] = -c/(a*d-b*c)
-> (16) inverseWithMinors[2,2] = a/(a*d-b*c)

   (17) inverseWithGauss  = GetInverse( GAUSS,  M )
-> (18) inverseWithGauss[1,1] = (1+b*c/(a*d-b*c))/a
-> (19) inverseWithGauss[1,2] = -b/(a*d-b*c)
-> (20) inverseWithGauss[2,1] = -c/(a*d-b*c)
-> (21) inverseWithGauss[2,2] = 1/(d-b*c/a)

   (22) %--------------------------------------------------------------------
   (23) % Example 2: GetInverse  (inverse of a dyadic)
   (24) %--------------------------------------------------------------------
   (25) RigidFrame F
   (26) D>> = 2*Fx>*Fy> - 3*Fy>*Fz> + Fz>*Fx>
-> (27) D>> = 2*Fx>*Fy> - 3*Fy>*Fz> + Fz>*Fx>

   (28) dyadicInverse>> = GetInverse( D>> )
-> (29) dyadicInverse>> = Fx>*Fz> + 0.5*Fy>*Fx> - 0.3333333*Fz>*Fy>



</PRE><nobr><a name="GetTranslationalMomentum"><font color="darkBlue"><font size=+1><b>GetTranslationalMomentum</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetTranslationalMomentum  or  GetLinearMomentum

 Purpose:  Gets translational (linear) momentum in a reference frame.

Syntax 1:  Object.GetTranslationalMomentum()
Syntax 2:  Object.GetTranslationalMomentum( refFrame )

   Input:  Object -- The name of a Particle, RigidBody, or System.
           refFrame -- The name of a RigidFrame or RigidBody

Output 1:  Object's translational (linear) momentum in the NewtonianFrame.
Output 2:  Object's translational (linear) momentum in refFrame.

  Remark:  A particle Q's translational momentum in refFrame is defined
           Q.GetMass() * Q.GetVelocity(refFrame)

 Related:  <a href="#GetAngularMomentum"><b>GetAngularMomentum</b></a>  <a href="#GetTranslationalMomentum"><b>GetTranslationalMomentum</b></a>  <a href="#GetGeneralizedMomentum"><b>GetGeneralizedMomentum</b></a>
           <a href="#GetKineticEnergy"><b>GetKineticEnergy</b></a>    <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>
           <a href="#Gyrostat"><b>Gyrostat</b></a>  <a href="#SetGeneralizedSpeed"><b>SetGeneralizedCoordinate</b></a>  <a href="#SetGeneralizedSpeed"><b>SetGeneralizedSpeed</b></a>
           <a href="#SetMass"><b>SetMass</b></a>  <a href="#SetInertia"><b>SetInertia</b></a>  <a href="#Rotate"><b>Rotate</b></a>  <a href="#Translate"><b>Translate</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>


</PRE><nobr><a name="GetKineticEnergy"><font color="darkBlue"><font size=+1><b>GetKineticEnergy</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetKineticEnergy  or  GetKineticEnergyi (i = 0, 1, 2)

 Purpose:  Gets kinetic energy in the NewtonianFrame (or a designated frame).

Syntax 1:  Object.GetKineticEnergy()  or Object.GetKineticEnergy(  refFrame )
Syntax 2:  Object.GetKineticEnergy0() or Object.GetKineticEnergy0( refFrame )
Syntax 3:  Object.GetKineticEnergy1() or Object.GetKineticEnergy1( refFrame )
Syntax 4:  Object.GetKineticEnergy2() or Object.GetKineticEnergy2( refFrame )

   Input:  Object -- The name of a Particle, RigidBody, or System.
           refFrame -- The name of a RigidFrame or RigidBody

Output 1:  Object's kinetic energy in the NewtonianFrame (or refFrame).

Output 2:  Object's homogeneous kinetic energy function of degree n = 0 in
           quantities declared by SetGeneralizedSpeeds.

Output 3:  Same as Output 2 except n = 1.
Output 4:  Same as Output 2 except n = 2.

 Related:  <a href="#GetAngularMomentum"><b>GetAngularMomentum</b></a>  <a href="#GetTranslationalMomentum"><b>GetTranslationalMomentum</b></a>  <a href="#GetGeneralizedMomentum"><b>GetGeneralizedMomentum</b></a>
           <a href="#GetKineticEnergy"><b>GetKineticEnergy</b></a>    <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>
           <a href="#Gyrostat"><b>Gyrostat</b></a>  <a href="#SetGeneralizedSpeed"><b>SetGeneralizedCoordinate</b></a>  <a href="#SetGeneralizedSpeed"><b>SetGeneralizedSpeed</b></a>
           <a href="#SetMass"><b>SetMass</b></a>  <a href="#SetInertia"><b>SetInertia</b></a>  <a href="#Rotate"><b>Rotate</b></a>  <a href="#Translate"><b>Translate</b></a>   <a href="#GetPower"><b>GetPower</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetKineticEnergy  (Kinetic energy of a particle)
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N             
   (5) Particle       Q         
   (6) Specified      v1    
   (7) Variable       v2    
   (8) Q.SetMass( mQ )
   (9) Q.SetVelocity( N, (v1+v2)*Nx> )
-> (10) v_Q_N> = (v1+v2)*Nx>

   (11) QKineticEnergy = Q.GetKineticEnergy()
-> (12) QKineticEnergy = 0.5*mQ*(v1+v2)^2

   (13) %------------------------
   (14) SetGeneralizedSpeed( v2 )
   (15) QKineticEnergy0 = Q.GetKineticEnergy0()
-> (16) QKineticEnergy0 = 0.5*mQ*v1^2

   (17) QKineticEnergy1 = Q.GetKineticEnergy1()
-> (18) QKineticEnergy1 = mQ*v1*v2

   (19) QKineticEnergy2 = Q.GetKineticEnergy2()
-> (20) QKineticEnergy2 = 0.5*mQ*v2^2

   (21) %--------------------------------------------------------------------
   (22) % Example 2: GetKineticEnergy  (Kinetic energy of a rigid body)
   (23) %--------------------------------------------------------------------
   (24) RigidBody    B             
   (25) B.SetMass( mB )
   (26) B.SetInertia( Bcm, Ixx, Iyy, Izz )
   (27) Variable     vx, vy, wz    
   (28) B.SetAngularVelocity( N, wz*Bz> )
-> (29) w_B_N> = wz*Bz>

   (30) Bcm.SetVelocity( N, vx*Nx> + vy*Ny> )
-> (31) v_Bcm_N> = vx*Nx> + vy*Ny>

   (32) BKineticEnergy = B.GetKineticEnergy()
-> (33) BKineticEnergy = 0.5*Izz*wz^2 + 0.5*mB*(vx^2+vy^2)

   (34) %--------------------------------------------------------------------
   (35) % Example 3: GetKineticEnergy  (Kinetic energy of a system)
   (36) %--------------------------------------------------------------------
   (37) SKineticEnergy = System.GetKineticEnergy( N )
-> (38) SKineticEnergy = 0.5*Izz*wz^2 + 0.5*mB*(vx^2+vy^2) + 0.5*mQ*(v1+v2)^2

   (39) SKineticEnergy0 = System.GetKineticEnergy0()
-> (40) SKineticEnergy0 = 0.5*mQ*v1^2 + 0.5*Izz*wz^2 + 0.5*mB*(vx^2+vy^2)

   (41) SKineticEnergy1 = System.GetKineticEnergy1()
-> (42) SKineticEnergy1 = mQ*v1*v2

   (43) SKineticEnergy2 = System.GetKineticEnergy2()
-> (44) SKineticEnergy2 = 0.5*mQ*v2^2



</PRE><nobr><a name="GetMagnitude"><font color="darkBlue"><font size=+1><b>GetMagnitude</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetMagnitude  and  GetMagnitudeSquared

 Purpose:  Calculates the magnitude of a vector or its magnitude squared.

Syntax 1:  GetMagnitude( vector> )
Syntax 2:  GetMagnitudeSquared( vector> )

   Input:  vector> -- a vector

Output 1:  Magnitude of vector>
Output 2:  Square of the magnitude of vector>

  Remark:  Use  abs           for absolute value of a real or complex scalar.
           Use  GetMagnitude  for the magnitude of a vector.
           Use  GetNorm       for the 2-norm of a real row or column matrix.

 Related:  <a href="#GetMagnitude"><b>GetMagnitude</b></a>           <a href="#GetMagnitude"><b>GetMagnitudeSquared</b></a>     <a href="#abs"><b>abs</b></a>     <a href="#GetNorm"><b>GetNorm</b></a>
           <a href="#GetDistance"><b>GetDistance</b></a>            <a href="#GetDistance"><b>GetDistanceSquared</b></a>
           <a href="#GetSpeed"><b>GetSpeed</b></a>               <a href="#GetSpeed"><b>GetSpeedSquared</b></a>
           <a href="#GetAngularSpeed"><b>GetAngularSpeed</b></a>        <a href="#GetAngularSpeed"><b>GetAngularSpeedSquared</b></a>
           <a href="#GetAngleBetweenVectors"><b>GetAngleBetweenVectors</b></a> <a href="#GetAngleBetweenVectors"><b>GetAngleBetweenUnitVectors</b></a>
           <a href="#GetPosition"><b>GetPosition</b></a>            <a href="#SetPosition"><b>SetPosition</b></a>       <a href="#Translate"><b>Translate</b></a>
           <a href="#GetVelocity"><b>GetVelocity</b></a>            <a href="#SetVelocity"><b>SetVelocity</b></a>       <a href="#SetPositionVelocity"><b>SetPositionVelocity</b></a>
           <a href="#GetAcceleration"><b>GetAcceleration</b></a>        <a href="#SetAcceleration"><b>SetAcceleration</b></a>   <a href="#SetVelocityAcceleration"><b>SetVelocityAcceleration</b></a>
           <a href="#GetUnitVector"><b>GetUnitVector</b></a>          <a href="#GetElongation"><b>GetElongation</b></a>     <a href="#Vector"><b>Vector</b></a>   <a href="#Cross"><b>Dot</b></a>

   (1) %--------------------------------------------------------------------
   (2) %Example: GetMagnitude and GetMagnitudeSquared
   (3) %--------------------------------------------------------------------
   (4) RigidFrame A
   (5) Constant x, y, z
   (6) v> = Vector( A, x, y, z )
-> (7) v> = x*Ax> + y*Ay> + z*Az>

   (8) magnitude = GetMagnitude( v> )
-> (9) magnitude = sqrt(x^2+y^2+z^2)

   (10) magnitudeSquared = GetMagnitudeSquared( v> )
-> (11) magnitudeSquared = x^2 + y^2 + z^2



</PRE><nobr><a name="GetMass"><font color="darkBlue"><font size=+1><b>GetMass</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetMass

 Purpose:  Gets an object's mass.

  Syntax:  Object.GetMass()

   Input:  Object -- The name of a Particle, RigidBody or System.

  Output:  Returns Object's mass.

 Related:  <a href="#SetMass"><b>SetMass</b></a>          <a href="#GetMass"><b>GetMass</b></a>         <a href="#SetInertia"><b>SetInertia</b></a>
           <a href="#GetCMPosition"><b>GetCMPosition</b></a>    <a href="#GetCMVelocity"><b>GetCmVelocity</b></a>   <a href="#GetCMAcceleration"><b>GetCmAcceleration</b></a>
           <a href="#GetInertiaDyadic"><b>GetInertiaDyadic</b></a>  <a href="#GetInertiaMatrix"><b>GetInertiaMatrix</b></a>  <a href="#GetMomentOfInertia"><b>GetMomentOfInertia</b></a>
           <a href="#GetProductOfInertia"><b>GetProductOfInertia</b></a>  <a href="#GetRadiusOfGyration"><b>GetRadiusOfGyration</b></a>  <a href="#GetInertiaVector"><b>GetInertiaVector</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetMass   (mass of particles)
   (3) %--------------------------------------------------------------------
   (4) Particle   P, Q, R, S            
   (5) Variable   mS'
   (6) P.SetMass( 17 )   
   (7) Q.SetMass( mQ )         % Declares mQ as a non-negative constant
   (8) R.SetMass( mR = 3 kg )  % Declares mR and sets its INPUT value to 3 kg
   (9) S.SetMass( mS )         % mS may be governed by an ODE 
   (10) massOfP = P.GetMass()
-> (11) massOfP = 17

   (12) massOfPAndQ = P.GetMass() + Q.GetMass()
-> (13) massOfPAndQ = 17 + mQ

   (14) massOfPQRS = System.GetMass()
-> (15) massOfPQRS = 17 + mQ + mR + mS

   (16) %--------------------------------------------------------------------
   (17) % Example 2: GetMass   (mass of rigid body)
   (18) %--------------------------------------------------------------------
   (19) RigidBody  B
   (20) B.SetMass( mB )    % Declares mB as a non-negative constant
   (21) massOfB = B.GetMass()
-> (22) massOfB = mB

   (23) %--------------------------------------------------------------------
   (24) % Example 3: GetMass   (mass of system of particles and rigid body)
   (25) %--------------------------------------------------------------------
   (26) massOfSystem = System.GetMass()    
-> (27) massOfSystem = 17 + mB + mQ + mR + mS



</PRE><nobr><a name="GetMassUnit"><font color="darkBlue"><font size=+1><b>GetMassUnit</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetMassUnit  GetLengthUnit  GetTimeUnit  GetAngleUnit

 Purpose:  Displays the mass, length, time, or angle unit.
           Stands for the unit of mass, length, or time
           set by the SetUnitSystem command.

Syntax 1:  GetMassUnit()
Syntax 2:  GetLengthUnit()
Syntax 3:  GetTimeUnit()
Syntax 4:  GetAngleUnit()

Output 1:  Displays the current mass   unit to the screen.
Output 2:  Displays the current length unit to the screen.
Output 3:  Displays the current time   unit to the screen.
Output 4:  Displays "radian"  to the screen.

 Related:  <a href="#ODE"><b>ODE</b></a>  <a href="#Solve"><b>Solve</b></a>  <a href="#Input"><b>Input</b></a>  <a href="#Output"><b>Output</b></a>  <a href="#Output"><b>OutputPlot</b></a>  <a href="#Plot"><b>Plot</b></a>  <a href="#Animate"><b>Animate</b></a>
           <a href="#ConvertUnits"><b>ConvertUnits</b></a>  <a href="#GetUnitSystem"><b>GetUnitSystem</b></a>  <a href="#SetUnitSystem"><b>SetUnitSystem</b></a>
           <a href="#GetMassUnit"><b>GetMassUnit</b></a>   <a href="#GetMassUnit"><b>GetLengthUnit</b></a>   <a href="#GetMassUnit"><b>GetTimeUnit</b></a>  <a href="#GetMassUnit"><b>GetAngleUnit</b></a>

--------------------------------------------------------------------
 Examples:
--------------------------------------------------------------------
   (1) GetMassUnit()
 kilogram
   (1) GetLengthUnit()
 meter
   (1) GetTimeUnit()
 second
   (1) GetAngleUnit()
 radian

   (1) %--------------------------------------------------------------------
   (2) %Example 1: GetMassUnit, GetLengthUnit, GetTimeUnit, GetAngleUnit 
   (3) %--------------------------------------------------------------------
   (4) SetUnitSystem( kg, m, sec )
   (5) KilogramsPerGram = ConvertUnits( GetMassUnit, gram )
-> (6) KilogramsPerGram = 1000

   (7) InchesPerMeter = ConvertUnits( inch, GetLengthUnit )
-> (8) InchesPerMeter = 0.0254

   (9) SecondSquaredPerMilliSecondSquared = ConvertUnits( GetTimeUnit^2, milliSecond^2 )
-> (10) SecondSquaredPerMilliSecondSquared = 1000000

   (11) RadianSecPerDegreeSecond = ConvertUnits( GetAngleUnit*sec, degrees*sec )
-> (12) RadianSecPerDegreeSecond = 57.29578

   (13) %--------------------------------------------------------------------
   (14) %Example 2: GetMassUnit, GetLengthUnit, GetTimeUnit, GetAngleUnit 
   (15) %--------------------------------------------------------------------
   (16) Variable  x' = sin(t)
-> (17) x' = sin(t)

   (18) Input  x = 2 GetLengthUnit,  tFinal = 10 seconds
   (19) Output t GetTimeUnit, x GetLengthUnit, x' GetLengthUnit/sec
   (20) ODE() GetUnitExample



</PRE><nobr><a name="GetMemory"><font color="darkBlue"><font size=+1><b>GetMemory</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetMemory

 Purpose:  Reports amount of dynamically allocated program memory.

  Syntax:  GetMemory()

  Output:  Number of bytes of dynamically allocated memory.

 Example:

   (1) x = 5
-> (2) x = 5
   (3) GetMemory()

 25247 BYTES OF MEMORY USED.

   (3) y = 7
-> (4) y = 7
   (5) GetMemory()

 25260 BYTES OF MEMORY USED.



</PRE><nobr><a name="GetMomentOfEffectiveForce"><font color="darkBlue"><font size=+1><b>GetMomentOfEffectiveForce</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetMomentOfEffectiveForce

 Purpose:  Calculates an object's moment of effective force about a point.

Syntax 1:  Object.GetMomentOfEffectiveForce( aboutPoint )
Syntax 2:  Object.GetMomentOfEffectiveForce( aboutPoint, refFrame )

   Input:  Object     -- name of a Particle, RigidBody, or System.
           aboutPoint -- name of a Point.
           refFrame   -- name of a RigidFrame or RigidBody.

Output 1:  Object's moment of effective force abointPoint in the NewtonianFrame.
Output 2:  Object's moment of effective force abointPoint in refFrame.

  Remark:  Particle Q's moment of effective force aboutPoint in refFrame is:
           Cross( Q.GetPosition(aboutPoint), Q.GetEffectiveForce(refFrame) )

 Related:  <a href="#GetTranslationalMomentum"><b>GetTranslationalMomentum</b></a>  <a href="#GetAngularMomentum"><b>GetAngularMomentum</b></a>  <a href="#GetEffectiveForce"><b>GetEffectiveForce</b></a>
           <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>  <a href="#GetMomentOfEffectiveForce"><b>GetMomentOfEffectiveForce</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetMomentOfEffectiveForce  (point moving in a plane)
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N             
   (5) Particle       Q   
   (6) Q.SetMass( mQ )
   (7) Variable       x'', y''
   (8) Q.Translate( No, x*Nx> + y*Ny> )
-> (9) p_No_Q> = x*Nx> + y*Ny>
-> (10) v_Q_N> = x'*Nx> + y'*Ny>
-> (11) a_Q_N> = x''*Nx> + y''*Ny>

   (12) QMomentOfEffectiveForceAboutNo> = Q.GetMomentOfEffectiveForce( No )
-> (13) QMomentOfEffectiveForceAboutNo> = mQ*(x*y''-y*x'')*Nz>

   (14) %--------------------------------------------------------------------
   (15) % Example 2: GetMomentOfEffectiveForce  (rotating rigid body)
   (16) %--------------------------------------------------------------------
   (17) RigidBody  B  
   (18) B.SetMass( mB )
   (19) B.SetInertia( Bcm, Ixx, Iyy, Izz )
   (20) Variable   theta''
   (21) B.RotateZ( N, theta )
-> (22) B_N = [cos(theta), sin(theta), 0;  -sin(theta), cos(theta), 0;  0, 0, 1]
-> (23) w_B_N> = theta'*Bz>
-> (24) alf_B_N> = theta''*Bz>

   (25) BMomentOfEffectiveForceAboutBcm> = B.GetMomentOfEffectiveForce( Bcm )
-> (26) BMomentOfEffectiveForceAboutBcm> = Izz*theta''*Bz>

   (27) %--------------------------------------------------------------------
   (28) % Example 3: GetMomentOfEffectiveForce  (rotating/translating rigid body)
   (29) %--------------------------------------------------------------------
   (30) Bcm.Translate( No, x*Nx> + y*Ny> )
-> (31) p_No_Bcm> = x*Nx> + y*Ny>
-> (32) v_Bcm_N> = x'*Nx> + y'*Ny>
-> (33) a_Bcm_N> = x''*Nx> + y''*Ny>

   (34) BMomentOfEffectiveForceAboutNo> = B.GetMomentOfEffectiveForce( No )
-> (35) BMomentOfEffectiveForceAboutNo> = (Izz*theta''+mB*(x*y''-y*x''))*Bz>



</PRE><nobr><a name="GetMomentOfForces"><font color="darkBlue"><font size=+1><b>GetMomentOfForces</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetMomentOfForces

 Purpose:  Sums the moments of all forces applied to an object.

  Syntax:  Object.GetMomentOfForces( aboutPoint )

   Input:  Object -- name of Point, Particle, RigidFrame, RigidBody, or System.
           aboutPoint -- the name of a point or Particle.

  Output:  Moment of all forces on Object about aboutPoint.

  Remark:  System depends on whether a NewtonianFrame was declared.
           Type HELP SYSTEM for more information.

  Remark:  If Q is a point of a RigidFrame or RigidBody B, declare it as
           Point Q(B).  This helps with subsequent velocity/acceleration
           and force/moment calculations.

 Related:  <a href="#AddForce"><b>AddForce</b></a>  <a href="#AddForceDamper"><b>AddForceDamper</b></a>  <a href="#AddForceElectrostatic"><b>AddForceElectrostatic</b></a>  <a href="#AddForceGravity"><b>AddForceGravity</b></a>
           <a href="#AddForceInverseSquare"><b>AddForceInverseSquare</b></a>  <a href="#AddForceLinearActuator"><b>AddForceLinearActuator</b></a>  <a href="#AddForceSpring"><b>AddForceSpring</b></a>
           <a href="#AddTorque"><b>AddTorque</b></a>  <a href="#AddTorqueDamper"><b>AddTorqueDamper</b></a>
           <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>  <a href="#GetResultantTorque"><b>GetResultantTorque</b></a>
           <a href="#GetForceGravityPotentialEnergy"><b>GetForceGravityPotentialEnergy</b></a>  <a href="#GetForceSpringPotentialEnergy"><b>GetForceSpringPotentialEnergy</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetMomentOfForces  (moment of forces on Ao about No)
   (3) %--------------------------------------------------------------------
   (4) RigidFrame N                                
   (5) RigidBody  A    
   (6) Variable   x, y
   (7) Ao.SetPosition( No, x*Nx> )             
-> (8) p_No_Ao> = x*Nx>

   (9) Ao.AddForce( 2*Nx> + 3*Ny> )               
-> (10) Force_Ao> = 2*Nx> + 3*Ny>

   (11) MomentOfForcesOnAoAboutNo> = Ao.GetMomentOfForces( No )
-> (12) MomentOfForcesOnAoAboutNo> = 3*x*Nz>

   (13) %--------------------------------------------------------------------
   (14) % Example 2: GetMomentOfForces  (moment of forces on A about various points)
   (15) %--------------------------------------------------------------------
   (16) Acm.SetPosition( No, y*Ny> )             
-> (17) p_No_Acm> = y*Ny>

   (18) Acm.AddForce( 4*Nx> + 5*Ny> )  
-> (19) Force_Acm> = 4*Nx> + 5*Ny>

   (20) MomentOfForcesOnAAboutAcm> = A.GetMomentOfForces( Acm )
-> (21) MomentOfForcesOnAAboutAcm> = (2*y+3*x)*Nz>

   (22) MomentOfForcesOnAAboutAo> = A.GetMomentOfForces( Ao )
-> (23) MomentOfForcesOnAAboutAo> = (-5*x-4*y)*Nz>

   (24) MomentOfForcesOnAAboutNo> = A.GetMomentOfForces( No )
-> (25) MomentOfForcesOnAAboutNo> = (3*x-4*y)*Nz>

   (26) %--------------------------------------------------------------------
   (27) % Example 3: GetMomentOfForces (action/reaction)
   (28) %--------------------------------------------------------------------
   (29) RigidBody  B
   (30) Variable   Fx, Fy
   (31) Ao.SetPosition( Bo, 2*x*Nx> )                                   
-> (32) p_Bo_Ao> = 2*x*Nx>

   (33) Ao.AddForce( Bo, Fx*Nx> ) 
-> (34) Force_Ao_Bo> = Fx*Nx>

   (35) MomentOfForcesOnAAboutAo> := A.GetMomentOfForces( Ao )
-> (36) MomentOfForcesOnAAboutAo> = (-5*x-4*y)*Nz>

   (37) MomentOfForcesOnBAboutAo> := B.GetMomentOfForces( Ao )
-> (38) MomentOfForcesOnBAboutAo> = 0>

   (39) %--------------------------------------------------------------------
   (40) % Example 4: GetMomentOfForces (action/reaction with RigidFrame N)
   (41) %--------------------------------------------------------------------
   (42) No.AddForce( Acm, Fy*Ny> )
-> (43) Force_No_Acm> = Fy*Ny>

   (44) MomentOfForcesOnSystemAboutNo> := System.GetMomentOfForces( Ao )
-> (45) MomentOfForcesOnSystemAboutNo> = (-5*x-4*y)*Nz>

   (46) %--------------------------------------------------------------------
   (47) % Example 5: GetMomentOfForces (NewtonianFrame is external to system)
   (48) %--------------------------------------------------------------------
   (49) NewtonianFrame  N
   (50) MomentOfForcesOnSystemAboutNo> := System.GetMomentOfForces( Ao )
-> (51) MomentOfForcesOnSystemAboutNo> = (Fy*x-5*x-4*y)*Nz>



</PRE><nobr><a name="GetMomentOfInertia"><font color="darkBlue"><font size=+1><b>GetMomentOfInertia</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetMomentOfInertia

 Purpose:  Gets an object's moment of inertia about a line.

  Syntax:  Object.GetMomentOfInertia( aboutPoint, unitVector )

   Input:  Object -- The name of a Particle, RigidBody, or System.
           aboutPoint -- The name of a point or Particle.
           unitVector -- Unit vector or expression for a unit vector.

  Output:  Returns Object's moment of inertia for the line that passes
           through aboutPoint and that is parallel to unitVector.

 Related:  <a href="#SetMass"><b>SetMass</b></a>          <a href="#GetMass"><b>GetMass</b></a>         <a href="#SetInertia"><b>SetInertia</b></a>
           <a href="#GetCMPosition"><b>GetCMPosition</b></a>    <a href="#GetCMVelocity"><b>GetCmVelocity</b></a>   <a href="#GetCMAcceleration"><b>GetCmAcceleration</b></a>
           <a href="#GetInertiaDyadic"><b>GetInertiaDyadic</b></a>  <a href="#GetInertiaMatrix"><b>GetInertiaMatrix</b></a>  <a href="#GetMomentOfInertia"><b>GetMomentOfInertia</b></a>
           <a href="#GetProductOfInertia"><b>GetProductOfInertia</b></a>  <a href="#GetRadiusOfGyration"><b>GetRadiusOfGyration</b></a>  <a href="#GetInertiaVector"><b>GetInertiaVector</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetMomentOfInertia  (moment of inertia of a rigid body)
   (3) %--------------------------------------------------------------------
   (4) RigidBody  B
   (5) B.SetInertia( Bcm, Ixx, Iyy, Izz )
   (6) BMomentOfInertiaAboutBcmForBx = B.GetMomentOfInertia( Bcm, Bx> )
-> (7) BMomentOfInertiaAboutBcmForBx = Ixx

   (8) %--------------------------------------------------------------------
   (9) % Example 2: GetMomentOfInertia  (moment of inertia in another basis)
   (10) %--------------------------------------------------------------------
   (11) RigidFrame A
   (12) Variable  theta
   (13) B.SetRotationMatrixZ( A, theta )
-> (14) B_A = [cos(theta), sin(theta), 0;  -sin(theta), cos(theta), 0;  0, 0, 1]

   (15) BMomentOfInertiaAboutBcmForAx = B.GetMomentOfInertia( Bcm, Ax> )
-> (16) BMomentOfInertiaAboutBcmForAx = Ixx*cos(theta)^2 + Iyy*sin(theta)^2

   (17) %--------------------------------------------------------------------
   (18) % Example 3: GetMomentOfInertia  (moment of inertia of a particle)
   (19) %--------------------------------------------------------------------
   (20) Particle   Q
   (21) Q.SetMass( mQ )
   (22) Variable   x, y, z
   (23) Q.SetPosition( Bo, x*Bx> + y*By> + z*Bz> )
-> (24) p_Bo_Q> = x*Bx> + y*By> + z*Bz>

   (25) QMomentOfInertiaAboutBoForBx = Q.GetMomentOfInertia( Bo, Bx> )
-> (26) QMomentOfInertiaAboutBoForBx = mQ*(y^2+z^2)

   (27) %--------------------------------------------------------------------
   (28) % Example 4: GetMomentOfInertia  (moment of inertia of a system)
   (29) %--------------------------------------------------------------------
   (30) B.SetMass( mB )
   (31) Bcm.SetPosition( Bo, 2*Bx> + 3*By> + 4*Bz> )
-> (32) p_Bo_Bcm> = 2*Bx> + 3*By> + 4*Bz>

   (33) SMomentOfInertiaAboutBoForBx = System.GetMomentOfInertia( Bo, Bx> )
-> (34) SMomentOfInertiaAboutBoForBx = Ixx + 25*mB + mQ*(y^2+z^2)

   (35) SMomentOfInertiaAboutBoForAx = System.GetMomentOfInertia( Bo, Ax> )
-> (36) SMomentOfInertiaAboutBoForAx = Ixx + 25*mB + mQ*(y^2+z^2) + sin(theta)*
        (Iyy*sin(theta)+12*mB*cos(theta)+mQ*x^2*sin(theta)+2*mQ*x*y*cos(theta)-
        5*mB*sin(theta)-Ixx*sin(theta)-mQ*y^2*sin(theta))



</PRE><nobr><a name="GetPolynomialRoots"><font color="darkBlue"><font size=+1><b>GetPolynomialRoots</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetPolynomialRoots GetQuadraticRoots       GetCubicRoots       ...
GetPolynomial      GetQuadraticPolynomial  GetCubicPolynomial  ...

 Purpose:  GetPolynomialRoots  gets the roots of a polynomial of degree
 Purpose:  GetPolynomial       creates a polynomial function from a matrix
           of coefficients or determines the coefficients of the leading
           terms of the Taylor-series expansion of a function about 0.

Syntax 1:  GetPolynomialRoots(       M  )
           GetLinearRoots(           M2 )       % M2 is 2-element matrix.
           GetQuadraticRoots(        M3 )       % M3 is 3-element matrix.
           GetCubicRoots(            M4 )       % M4 is 4-element matrix.
           GetQuarticRoots(          M5 )       % M5 is 5-element matrix.
           GetQuinticRoots(          M6 )       % M6 is 6-element matrix.
           GetQuadraticPositiveRoot( M2 )
           GetQuadraticNegativeRoot( M2 )
Syntax 2:  GetPolynomialRoots(       expression = 0,  x, p )
           GetLinearRoots(           expression = 0,  x )
           GetQuadraticRoots(        expression = 0,  x )
           GetCubicRoots(            expression = 0,  x )
           GetQuarticRoots(          expression = 0,  x )
           GetQuinticRoots(          expression = 0,  x )
           GetQuadraticPositiveRoot( expression = 0,  x )
           GetQuadraticNegativeRoot( expression = 0,  x )
Syntax 3:  GetPolynomial(          M,  x )
           GetLinearPolynomial(    M2, x )
           GetQuadraticPolynomial( M3, x )
           GetCubicPolynomial(     M4, x )
           GetQuarticPolynomial(   M5, x )
           GetQuinticPolynomial(   M6, x )
Syntax 4:  GetPolynomial(          expression, x, p )
           GetLinearPolynomial(    expression, x )
           GetQuadraticPolynomial( expression, x )
           GetCubicPolynomial(     expression, x )
           GetQuarticPolynomial(   expression, x )
           GetQuinticPolynomial(   expression, x )

   Input:  M -- row or column matrix with scalar elements.  For example,
           M = [2, 5, 7, 9]  may represent  2*x^3 + 5*x^2 + 7*x + 9.

           p   -- positive integer.
           x   -- scalar name (variable, constant, specified, ...)
           expression -- scalar expression that is a function of x.  A polynomial
           is created from a Taylor series expansion of expression about x = 0.

Output 1:  Row or column matrix whose elements are the roots of the
           polynomial represented by M.

           For special case of quadratic formula:  a*x^2 + b*x + c = 0,
           GetQuadraticPositiveRoot  returns (-b + sqrt(b^2 - 4*a*c)) / 2*a
           GetQuadraticNegativeRoot  returns (-b - sqrt(b^2 - 4*a*c)) / 2*a

           Note: To also assign results to x, use
           SolveQuadraticPositiveRoot  or  SolveQuadraticNegativeRoot.

Output 2:  Column matrix whose elements are the roots of the polynomial
           formed by the p+1 leading terms of the Taylor series expansion
           of expression about x = 0.  For example,

           taylorSeriesRoots = GetPolynomialRoots( exp(x),  x,  3 )

           returns the roots of the polynomial generated by doing a Taylor
           series expansion of exp(x) about x=0, i.e., it returns the roots
           of the polynomial  1 + x + x^2/2 + x^3/factorial(3).

Output 3:  Polynomial of degree p-1 in x equal to:
           M[1]*x^(p-1) + M[2]*x^(p-2) + ... M[p-1]*x + M[p].

Output 4:  Column matrix having p+1 elements whose ith element is the
           coefficient of the term of degree  p+1-i  in x  in the
           Taylor series expansion of expression about x = 0.

 Related:  <a href="#GetPolynomialRoots"><b>GetPolynomial</b></a>  <a href="#GetPolynomialRoots"><b>GetPolynomialRoots</b></a>  <a href="#GetPolynomialRoots"><b>GetQuadraticRoots</b></a>  ...
           <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRoot</b></a>  <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRootDt</b></a>  ...
           <a href="#Solve"><b>Solve</b></a>  <a href="#SolveDt"><b>SolveDt</b></a>  <a href="#SolveSetInput"><b>SolveSetInput</b></a>
           <a href="#Spline"><b>Spline</b></a> (Line, Cubic, Bell, Pulse, Step, Transition, Polynomial, ...)
           <a href="#FactorLinear"><b>FactorLinear</b></a>  <a href="#FactorLinear"><b>FactorQuadratic</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetLinearRoots     (roots of linear equation).
   (3) %--------------------------------------------------------------------
   (4) Variable x
   (5) Constant a, b, c
   (6) root1A = GetLinearRoot( a*x = b,  x )
-> (7) root1A = b/a

   (8) root1B = GetLinearRoot( [a; -b] )
-> (9) root1B = b/a

   (10) %--------------------------------------------------------------------
   (11) % Example 2: GetQuadraticRoots  (roots of quadratic equation).
   (12) %--------------------------------------------------------------------
   (13) root2A = GetQuadraticRoots( a*x^2 + b*x + c = 0,  x )
-> (14) root2A[1] = -0.5*(b+sqrt(b^2-4*a*c))/a
-> (15) root2A[2] = -0.5*(b-sqrt(b^2-4*a*c))/a

   (16) positiveRootA = GetQuadraticPositiveRoot( a*x^2 + b*x + c = 0,  x )
-> (17) positiveRootA = -0.5*(b-sqrt(b^2-4*a*c))/a

   (18) negativeRootA = GetQuadraticNegativeRoot( a*x^2 + b*x + c = 0,  x )
-> (19) negativeRootA = -0.5*(b+sqrt(b^2-4*a*c))/a

   (20) root2B = GetQuadraticRoots( [a; b; c] )
-> (21) root2B[1] = -0.5*(b+sqrt(b^2-4*a*c))/a
-> (22) root2B[2] = -0.5*(b-sqrt(b^2-4*a*c))/a

   (23) %--------------------------------------------------------------------
   (24) % Example 3: GetCubicRoots      (roots of 3rd-order polynomial).
   (25) %--------------------------------------------------------------------
   (26) SetImaginaryNumber( i )
   (27) Variable  p
   (28) root3A = GetCubicRoots( 3*p^3 + 5*p^2 + 9*p + 17 = 0,   p )
-> (29) root3A = [-1.775053;  0.05419336 - 1.785905*i;  0.05419336 + 1.785905*i]

   (30) root3B = GetCubicRoots( [3, 5, 9, 17] )
-> (31) root3B = [-1.775053, 0.05419336 - 1.785905*i, 0.05419336 + 1.785905*i]

   (32) %--------------------------------------------------------------------
   (33) % Example 4: GetQuarticRoots    (roots of 4th-order polynomial).
   (34) %--------------------------------------------------------------------
   (35) root4A = GetQuarticRoots( 2*p^4 + 3*p^3 + 5*p^2 + 9*p + 17 = 0,   p )
-> (36) root4A = [-1.361636 - 1.014663*i;  -1.361636 + 1.014663*i;  0.6116363
        - 1.604248*i;  0.6116363 + 1.604248*i]

   (37) root4B = GetQuarticRoots( [2, 3, 5, 9, 17] )
-> (38) root4B = [-1.361636 - 1.014663*i, -1.361636 + 1.014663*i, 0.6116363 - 1.604248*i, 0.6116363 + 1.604248*i]

   (39) %--------------------------------------------------------------------
   (40) % Example 5: GetQuinticRoots    (roots of 5th-order polynomial).
   (41) %--------------------------------------------------------------------
   (42) root5A = GetQuinticRoots( p^5 + 2*p^4 + 3*p^3 + 5*p^2 + 9*p + 17 = 0,  p )
-> (43) root5A = [-1.857621;  -0.9475112 - 1.507048*i;  -0.9475112 + 1.507048*i;  
        0.8763218 - 1.455989*i;  0.8763218 + 1.455989*i]

   (44) root5B = GetQuinticRoots( [1, 2, 3, 5, 9, 17] )
-> (45) root5B = [-1.857621, -0.9475112 - 1.507048*i, -0.9475112 + 1.507048*i, 0.8763218 - 1.455989*i, 0.8763218 + 1.455989*i]

   (46) %--------------------------------------------------------------------
   (47) % Example 6: GetPolynomialRoots  (roots of nth-order polynomial).
   (48) %--------------------------------------------------------------------
   (49) root7A = GetPolynomialRoots( p^7 + 2*p^3 + 13 = 0,   p, 7 )  
-> (50) root7A = [-1.348251;  -0.9844658 - 1.16944*i;  -0.9844658 + 1.16944*i;  
        0.3798201 - 1.331288*i;  0.3798201 + 1.331288*i;  1.278771 - 0.7194889*i;  1.278771 + 0.7194889*i]

   (51) root7B = GetPolynomialRoots( [1, 0, 0, 0, 2, 0, 0, 13] )
-> (52) root7B = [-1.348251, -0.9844658 - 1.16944*i, -0.9844658 + 1.16944*i, 
        0.3798201 - 1.331288*i, 0.3798201 + 1.331288*i, 1.278771 - 0.7194889*i, 1.278771 + 0.7194889*i]

   (53) %--------------------------------------------------------------------
   (54) % Example 7: GetPolynomial 
   (55) %--------------------------------------------------------------------
   (56) quadraticFunctionA = GetPolynomial(  [t, 5, 3],  x )
-> (57) quadraticFunctionA = 3 + 5*x + t*x^2

   (58) approximateAsCubic = GetCubicPolynomial( sin(x),  x )
-> (59) approximateAsCubic = [-0.1666667;  0;  1;  0]

   (60) approximateAs5thOrder = GetPolynomial( cos(x),  x, 5 )
-> (61) approximateAs5thOrder = [0;  0.04166667;  0;  -0.5;  0;  1]



</PRE><nobr><a name="GetEulerParameterMatrix44"><font color="darkBlue"><font size=+1><b>GetEulerParameterMatrix44</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetEulerParameterMatrix44

 Purpose:  Gets the 4x4 Euler parameter matrix that multiplies a 4x1 Euler-
           parameter matrix to produce the 4 Euler parameters associated
           with concatenating two rotation matrices.

  Syntax:  GetEulerParameterMatrix44( e0, e1, e2, e3 )

   Input:  e0, e1, e2, e3 -- expressions for Euler parameters (quaternion)

  Output:  4x4 Euler parameter matrix, equal to:
           [ e0,  -e1,  -e2,  -e3;
             e1,   e0,  -e3,   e2;
             e2,   e3,   e0,  -e1;
             e3,  -e2,   e1,   e0   ]

  Remark:  Definitions of Euler parameters (quaternion) etc., are in
           Kane, T. R.,  Likins, P. W.,  and Levinson D. A.,
           Spacecraft Dynamics, McGraw-Hill, 1983, Ch. 1., and
           Mitiguy, Paul, Advanced Dynamics for Professional
           Mechanical, Aerospace, and BioMechanical Engineers.

 Related:  <a href="#Rotate"><b>Rotate</b></a>  <a href="#RotateX"><b>RotateX</b></a>  <a href="#RotateY"><b>RotateY</b></a>  <a href="#RotateZ"><b>RotateZ</b></a>
           <a href="#RotateX"><b>RotateNegativeX</b></a>  <a href="#RotateY"><b>RotateNegativeY</b></a>  <a href="#RotateZ"><b>RotateNegativeZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixY</b></a>  <a href="#SetRotationMatrixZ"><b>SetRotationMatrixZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixNegativeX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixNegativeY</b></a>  ...
           <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>  <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>  <a href="#SetAngularAcceleration"><b>SetAngularAcceleration</b></a>
           <a href="#GetRotationMatrix"><b>GetRotationMatrix</b></a>  <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>  <a href="#GetAngularAcceleration"><b>GetAngularAcceleration</b></a>
           <a href="#SetRotationMatrixODE"><b>SetRotationMatrixODE</b></a>   <a href="#SetRigidTransform"><b>SetRigidTransform</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: GetEulerParameterMatrix44.al  
   (3) %--------------------------------------------------------------------
   (4) Variable  e0, e1, e2, e3
   (5) E = GetEulerParameterMatrix44( e0, e1, e2, e3 )
-> (6) E = [e0, -e1, -e2, -e3;  e1, e0, -e3, e2;  e2, e3, e0, -e1;  e3, -e2, e1, e0]



</PRE><nobr><a name="GetPosition"><font color="darkBlue"><font size=+1><b>GetPosition</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetPosition

 Purpose:  Gets the position of a point from another point.

  Syntax:  Q.GetPosition( fromPoint )

   Input:  Q, fromPoint -- names of points (e.g., Point or Particle).

  Output:  Q's position vector from fromPoint.

 Related:  <a href="#Translate"><b>Translate</b></a>        <a href="#SetPositionVelocity"><b>SetPositionVelocity</b></a>   <a href="#SetVelocityAcceleration"><b>SetVelocityAcceleration</b></a>
           <a href="#SetPosition"><b>SetPosition</b></a>      <a href="#GetPosition"><b>GetPosition</b></a>   <a href="#GetDistance"><b>GetDistance</b></a>  <a href="#GetDistance"><b>GetDistanceSquared</b></a>
           <a href="#SetVelocity"><b>SetVelocity</b></a>      <a href="#GetVelocity"><b>GetVelocity</b></a>   <a href="#GetSpeed"><b>GetSpeed</b></a>     <a href="#GetElongation"><b>GetElongation</b></a>
           <a href="#SetAcceleration"><b>SetAcceleration</b></a>  <a href="#GetAcceleration"><b>GetAcceleration</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: GetPosition 
   (3) %--------------------------------------------------------------------
   (4) RigidFrame N             
   (5) Point      P
   (6) Particle   Q            
   (7) Variable   xP, yP, zP
   (8) Variable   xQ, yQ, zQ
   (9) P.SetPosition( No, xP*Nx> + yP*Ny> + zP*Nz> )
-> (10) p_No_P> = xP*Nx> + yP*Ny> + zP*Nz>

   (11) Q.SetPosition( P,  xQ*Nx> + yQ*Ny> + zQ*Nz> )
-> (12) p_P_Q> = xQ*Nx> + yQ*Ny> + zQ*Nz>

   (13) QPositionVectorFromNo> = Q.GetPosition( No )
-> (14) QPositionVectorFromNo> = (xP+xQ)*Nx> + (yP+yQ)*Ny> + (zP+zQ)*Nz>



</PRE><nobr><a name="GetPotentialEnergy"><font color="darkBlue"><font size=+1><b>GetPotentialEnergy</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetPotentialEnergy

 Purpose:  Help with potential energy associated with various forces.

           For help with  gravity  potential energy, type
           Help  GetForceGravityPotentialEnergy

           For help with  spring  potential energy, type
           Help  GetForceSpringPotentialEnergy

           For help with  electrostatic  potential energy, type
           Help  GetForceElectrostaticPotentialEnergy

           For help with other inverse-square forces' potential energy, type
           Help  GetForceInverseSquarePotentialEnergy


</PRE><nobr><a name="GetPower"><font color="darkBlue"><font size=+1><b>GetPower</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetPower

 Purpose:  Gets the power of all forces and torques in the system.

Syntax 1:  System.GetPower()
Syntax 2:  Q.GetPowerForce()
Syntax 3:  Q.GetPowerForce( P )
Syntax 4:  B.GetPowerTorque()
Syntax 5:  B.GetPowerTorque( A )

   Input:  Q, P -- names of points (e.g., Point or Particle).
           B, A -- name of a RigidFrame or RigidBody.

Output 1:  Power of all forces and torques in the system.
Output 2:  Power of Force_Q>    (the external force on Q).
Output 3:  Power of Force_Q_P>  (the action/reaction force on Q from P).
Output 4:  Power of Torque_B>   (the external torque on B).
Output 5:  Power of Torque_B_A> (the action/reaction torque on B from A).

  Remark:  Power is calculated in the NewtonianFrame.  To calculate in a
           different reference frame, temporarily reassign NewtonianFrame.

 Related:  <a href="#AddForce"><b>AddForce</b></a>  <a href="#AddForceDamper"><b>AddForceDamper</b></a>  <a href="#AddForceElectrostatic"><b>AddForceElectrostatic</b></a>  <a href="#AddForceGravity"><b>AddForceGravity</b></a>
           <a href="#AddForceInverseSquare"><b>AddForceInverseSquare</b></a>  <a href="#AddForceLinearActuator"><b>AddForceLinearActuator</b></a>  <a href="#AddForceSpring"><b>AddForceSpring</b></a>
           <a href="#AddTorque"><b>AddTorque</b></a>  <a href="#AddTorqueDamper"><b>AddTorqueDamper</b></a>
           <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>  <a href="#GetResultantTorque"><b>GetResultantTorque</b></a>
           <a href="#GetForceGravityPotentialEnergy"><b>GetForceGravityPotentialEnergy</b></a>  <a href="#GetForceSpringPotentialEnergy"><b>GetForceSpringPotentialEnergy</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>  <a href="#GetKineticEnergy"><b>GetKineticEnergy</b></a>

   (1) %----------------------------------------------------------------------
   (2) % Example 1: GetPowerForce   (Power of force on point Bo from point Ao)
   (3) %----------------------------------------------------------------------
   (4) NewtonianFrame  N
   (5) RigidBody       A, B
   (6) Variable        vx, vy, wz
   (7) Ao.SetVelocity( N,  2*Nx> )
-> (8) v_Ao_N> = 2*Nx>

   (9) Bo.SetVelocity( N,  vx*Nx> + vy*Ny> )
-> (10) v_Bo_N> = vx*Nx> + vy*Ny>

   (11) Bo.AddForce( Ao,  444*Nx> )
-> (12) Force_Bo_Ao> = 444*Nx>

   (13) PowerOfForceOnBoFromAo = Bo.GetPowerForce( Ao )
-> (14) PowerOfForceOnBoFromAo = -888 + 444*vx

   (15) %----------------------------------------------------------------------
   (16) % Example 2: GetPowerForce   (Power of external force on point Bo)
   (17) %----------------------------------------------------------------------
   (18) Specified       Fx, Fy, Tz
   (19) Bo.AddForce( Fx*Nx> + Fy*Ny> )
-> (20) Force_Bo> = Fx*Nx> + Fy*Ny>

   (21) PowerOfExternalForceOnBo = Bo.GetPowerForce()
-> (22) PowerOfExternalForceOnBo = Fx*vx + Fy*vy

   (23) %----------------------------------------------------------------------
   (24) % Example 3: GetPowerTorque  (Power of torque on body B from body A)
   (25) %----------------------------------------------------------------------
   (26) A.SetAngularVelocity( N, 3*Nz> )  
-> (27) w_A_N> = 3*Nz>

   (28) B.SetAngularVelocity( N, wz*Nz> )  
-> (29) w_B_N> = wz*Nz>

   (30) B.AddTorque( A,  333*Nz> )  
-> (31) Torque_B_A> = 333*Nz>

   (32) PowerOfTorqueOnBFromA = B.GetPowerTorque( A )   
-> (33) PowerOfTorqueOnBFromA = -999 + 333*wz

   (34) %----------------------------------------------------------------------
   (35) % Example 4: GetPowerTorque  (Power of external torque on body B)
   (36) %----------------------------------------------------------------------
   (37) B.AddTorque( Tz*Nz> )  
-> (38) Torque_B> = Tz*Nz>

   (39) PowerOfExternalTorqueOnB = B.GetPowerTorque()
-> (40) PowerOfExternalTorqueOnB = Tz*wz

   (41) %----------------------------------------------------------------------
   (42) % Example 5: GetPower   (Power of all forces and torques on the system)
   (43) %----------------------------------------------------------------------
   (44) PowerOfSystem = System.GetPower()   
-> (45) PowerOfSystem = -1887 + 333*wz + 444*vx + Fx*vx + Fy*vy + Tz*wz



</PRE><nobr><a name="GetProductOfInertia"><font color="darkBlue"><font size=+1><b>GetProductOfInertia</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetProductOfInertia

 Purpose:  Gets an object's product of inertia about a point for
           two orthogonal unit vectors.

  Syntax:  Object.GetProductOfInertia( aboutPoint, unitVectorA, unitVectorB )

   Input:  Object -- The name of a Particle, RigidBody, or System.
           aboutPoint -- The name of a point or Particle.
           unitVectorA -- Unit vector or expression for a unit vector.
           unitVectorB -- Unit vector or expression for a unit vector.

  Output:  Object's product of inertia about aboutPoint for
           the unit vectors unitVectorA and unitVectorB.

  Remark:  Products of inertia adhere to the "negative sign convention".
           Example: For a 1 kg particle whose position from a point P is
           2*Nx> + 3*Ny>, the product of inertia Ixy = -m*x*y = -6 kg*m^2.

 Related:  <a href="#SetMass"><b>SetMass</b></a>          <a href="#GetMass"><b>GetMass</b></a>         <a href="#SetInertia"><b>SetInertia</b></a>
           <a href="#GetCMPosition"><b>GetCMPosition</b></a>    <a href="#GetCMVelocity"><b>GetCmVelocity</b></a>   <a href="#GetCMAcceleration"><b>GetCmAcceleration</b></a>
           <a href="#GetInertiaDyadic"><b>GetInertiaDyadic</b></a>  <a href="#GetInertiaMatrix"><b>GetInertiaMatrix</b></a>  <a href="#GetMomentOfInertia"><b>GetMomentOfInertia</b></a>
           <a href="#GetProductOfInertia"><b>GetProductOfInertia</b></a>  <a href="#GetRadiusOfGyration"><b>GetRadiusOfGyration</b></a>  <a href="#GetInertiaVector"><b>GetInertiaVector</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetProductOfInertia  (product of inertia of a rigid body)
   (3) %--------------------------------------------------------------------
   (4) RigidBody  B
   (5) B.SetInertia( Bcm, Ixx, Iyy, Izz )
   (6) BProductOfInertiaAboutBcmForBxBy = B.GetProductOfInertia( Bcm, Bx>, By> )
-> (7) BProductOfInertiaAboutBcmForBxBy = 0

   (8) %--------------------------------------------------------------------
   (9) % Example 2: GetProductOfInertia  (product of inertia in another basis)
   (10) %--------------------------------------------------------------------
   (11) RigidFrame A
   (12) Variable  theta
   (13) B.SetRotationMatrixZ( A, theta )
-> (14) B_A = [cos(theta), sin(theta), 0;  -sin(theta), cos(theta), 0;  0, 0, 1]

   (15) BProductOfInertiaAboutBcmForAxAy = B.GetProductOfInertia( Bcm, Ax>, Ay> )
-> (16) BProductOfInertiaAboutBcmForAxAy = (Ixx-Iyy)*sin(theta)*cos(theta)

   (17) %--------------------------------------------------------------------
   (18) % Example 3: GetProductOfInertia  (product of inertia of a particle)
   (19) %--------------------------------------------------------------------
   (20) Particle   Q
   (21) Q.SetMass( mQ )
   (22) Variable   x, y, z
   (23) Q.SetPosition( Bo, x*Bx> + y*By> + z*Bz> )
-> (24) p_Bo_Q> = x*Bx> + y*By> + z*Bz>

   (25) QProductOfInertiaAboutBoForBxBy = Q.GetProductOfInertia( Bo, Bx>, By> )
-> (26) QProductOfInertiaAboutBoForBxBy = -mQ*x*y

   (27) %--------------------------------------------------------------------
   (28) % Example 4: GetProductOfInertia  (product of inertia of a system)
   (29) %--------------------------------------------------------------------
   (30) B.SetMass( mB )
   (31) Bcm.SetPosition( Bo, 2*Bx> + 3*By> + 4*Bz> )
-> (32) p_Bo_Bcm> = 2*Bx> + 3*By> + 4*Bz>

   (33) SProductOfInertiaAboutBoForBxBy = System.GetProductOfInertia( Bo, Bx>, By> )
-> (34) SProductOfInertiaAboutBoForBxBy = -6*mB - mQ*x*y

   (35) SProductOfInertiaAboutBoForAxBy = System.GetProductOfInertia( Bo, Ax>, Ay> )
-> (36) SProductOfInertiaAboutBoForAxBy = -6*mB - mQ*x*y - sin(theta)*(Iyy*cos(
        theta)+mQ*x^2*cos(theta)-12*mB*sin(theta)-5*mB*cos(theta)-Ixx*cos(theta)
        -2*mQ*x*y*sin(theta)-mQ*y^2*cos(theta))



</PRE><nobr><a name="GetRadiusOfGyration"><font color="darkBlue"><font size=+1><b>GetRadiusOfGyration</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetRadiusOfGyration

 Purpose:  Gets an object's radius of gyration about a line.

  Syntax:  Object.GetRadiusOfGyration( aboutPoint, unitVector )

   Input:  Object -- The name of a Particle, RigidBody, or System.
           aboutPoint -- The name of a point or Particle.
           unitVector -- Unit vector or expression for a unit vector.

  Output:  Object's radius of gyration for the line that passes
           through aboutPoint and that is parallel to unitVector.

 Related:  <a href="#SetMass"><b>SetMass</b></a>          <a href="#GetMass"><b>GetMass</b></a>         <a href="#SetInertia"><b>SetInertia</b></a>
           <a href="#GetCMPosition"><b>GetCMPosition</b></a>    <a href="#GetCMVelocity"><b>GetCmVelocity</b></a>   <a href="#GetCMAcceleration"><b>GetCmAcceleration</b></a>
           <a href="#GetInertiaDyadic"><b>GetInertiaDyadic</b></a>  <a href="#GetInertiaMatrix"><b>GetInertiaMatrix</b></a>  <a href="#GetMomentOfInertia"><b>GetMomentOfInertia</b></a>
           <a href="#GetProductOfInertia"><b>GetProductOfInertia</b></a>  <a href="#GetRadiusOfGyration"><b>GetRadiusOfGyration</b></a>  <a href="#GetInertiaVector"><b>GetInertiaVector</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetRadiusOfGyration  (radius of gyration of a rigid body)
   (3) %--------------------------------------------------------------------
   (4) RigidBody  B
   (5) B.SetMass( mB )
   (6) B.SetInertia( Bcm, Ixx, Iyy, Izz )
   (7) BRadiusOfGyrationAboutBcmForBx = B.GetRadiusOfGyration( Bcm, Bx> )
-> (8) BRadiusOfGyrationAboutBcmForBx = sqrt(Ixx)/sqrt(mB)

   (9) %--------------------------------------------------------------------
   (10) % Example 2: GetRadiusOfGyration  (radius of gyration in another basis)
   (11) %--------------------------------------------------------------------
   (12) RigidFrame A
   (13) Variable  theta
   (14) B.SetRotationMatrixZ( A, theta )
-> (15) B_A = [cos(theta), sin(theta), 0;  -sin(theta), cos(theta), 0;  0, 0, 1]

   (16) BRadiusOfGyrationAboutBcmForAx = B.GetRadiusOfGyration( Bcm, Ax> )
-> (17) BRadiusOfGyrationAboutBcmForAx = sqrt(Ixx*cos(theta)^2+Iyy*sin(theta)^2)
        /sqrt(mB)

   (18) %--------------------------------------------------------------------
   (19) % Example 3: GetRadiusOfGyration  (radius of gyration of a particle)
   (20) %--------------------------------------------------------------------
   (21) Particle   Q
   (22) Q.SetMass( mQ )
   (23) Variable   x, y, z
   (24) Q.SetPosition( Bo, x*Bx> + y*By> + z*Bz> )
-> (25) p_Bo_Q> = x*Bx> + y*By> + z*Bz>

   (26) QRadiusOfGyrationAboutBoForBx = Q.GetRadiusOfGyration( Bo, Bx> )
-> (27) QRadiusOfGyrationAboutBoForBx = sqrt(y^2+z^2)

   (28) %--------------------------------------------------------------------
   (29) % Example 4: GetRadiusOfGyration  (radius of gyration of a system)
   (30) %--------------------------------------------------------------------
   (31) Bcm.SetPosition( Bo, 2*Bx> + 3*By> + 4*Bz> )
-> (32) p_Bo_Bcm> = 2*Bx> + 3*By> + 4*Bz>

   (33) SRadiusOfGyrationAboutBoForBx = System.GetRadiusOfGyration( Bo, Bx> )
-> (34) SRadiusOfGyrationAboutBoForBx = sqrt((Ixx+25*mB+mQ*(y^2+z^2))/(mB+mQ))

   (35) SRadiusOfGyrationAboutBoForAx = System.GetRadiusOfGyration( Bo, Ax> )
-> (36) SRadiusOfGyrationAboutBoForAx = sqrt((Ixx+25*mB+mQ*(y^2+z^2)+sin(theta)
        *(Iyy*sin(theta)+12*mB*cos(theta)+mQ*x^2*sin(theta)+2*mQ*x*y*cos(theta)
        -5*mB*sin(theta)-Ixx*sin(theta)-mQ*y^2*sin(theta)))/(mB+mQ))



</PRE><nobr><a name="GetResultantForce"><font color="darkBlue"><font size=+1><b>GetResultantForce</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetResultantForce  GetNetForce  (synonymous)

 Purpose:  Returns the sum of forces applied to an object.

Syntax 1:  Object.GetResultantForce()  or  Object.GetNetForce()
Syntax 2:  Q.GetResultantForce( P )    or       Q.GetNetForce( P )

   Input:  Object -- a Point, Particle, RigidBody, RigidFrame, or System
           Q, P -- names of points (e.g., Point or Particle).

Output 1:  Sum of all forces applied to Object.
Output 2:  Sum of all forces applied to Q by P.

  Remark:  If Q is a point of a RigidFrame or RigidBody B, declare it as
           Point Q(B).  This helps with subsequent velocity/acceleration
           and force/moment calculations.

  Remark:  Force_Q>  denotes the inherently "external" forces on Q whereas
           Q.GetResultantForce() also accounts for all action/reaction
           forces applied to Q from all other points in the system.

           Force_Q_P>  denotes the action/reaction force on Q from P whereas
           Q.GetResultantTorque(P)  returns  Force_Q_P> - Force_P_Q>.

  Remark:  Q.GetForce(P) is deprecated for Q.GetResultantForce(P).

  Remark:  The NewtonianFrame is not part of the "System" for the command
           System.GetResultantForce().  Type HELP SYSTEM for more information.

 Related:  <a href="#AddForce"><b>AddForce</b></a>  <a href="#AddForceDamper"><b>AddForceDamper</b></a>  <a href="#AddForceElectrostatic"><b>AddForceElectrostatic</b></a>  <a href="#AddForceGravity"><b>AddForceGravity</b></a>
           <a href="#AddForceInverseSquare"><b>AddForceInverseSquare</b></a>  <a href="#AddForceLinearActuator"><b>AddForceLinearActuator</b></a>  <a href="#AddForceSpring"><b>AddForceSpring</b></a>
           <a href="#AddTorque"><b>AddTorque</b></a>  <a href="#AddTorqueDamper"><b>AddTorqueDamper</b></a>
           <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>  <a href="#GetResultantTorque"><b>GetResultantTorque</b></a>
           <a href="#GetForceGravityPotentialEnergy"><b>GetForceGravityPotentialEnergy</b></a>  <a href="#GetForceSpringPotentialEnergy"><b>GetForceSpringPotentialEnergy</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  GetResultantForce  or  GetNetForce
   (3) %--------------------------------------------------------------------
   (4) RigidBody  A, B
   (5) Point      Bp( B )                          % Bp is a point of body B.
   (6) Specified  Fx, Fy
   (7) Bp.AddForce( Fx*Ax> )                       % Add external force on Bp.
-> (8) Force_Bp> = Fx*Ax>

   (9) Bp.AddForce( Ao,  888*Ax> )                 % Add action/reaction force on Bp from Ao.
-> (10) Force_Bp_Ao> = 888*Ax>

   (11) NetForceOnBpFromAo> = Bp.GetNetForce( Ao )  % Net action/reaction force on Bp from Ao.
-> (12) NetForceOnBpFromAo> = 888*Ax>

   (13) NetForceOnAoFromBp> = Ao.GetNetForce( Bp )  % Net action/reaction force on Ao from Bp.
-> (14) NetForceOnAoFromBp> = -888*Ax>

   (15) NetForceOnBp> = Bp.GetResultantForce()      % Net force on point Bp.
-> (16) NetForceOnBp> = (888+Fx)*Ax>

   (17) NetForceOnB> = B.GetResultantForce()        % Net force on body B.
-> (18) NetForceOnB> = (888+Fx)*Ax>

   (19) NetForceOnA> = A.GetResultantForce()        % Net force on body A.
-> (20) NetForceOnA> = -888*Ax>

   (21) NetForceOnS> = System.GetResultantForce()   % Net force on System(A, B, Bp).
-> (22) NetForceOnS> = Fx*Ax>

   (23) %--------------------------------------------------------------------
   (24) % Example 2:  GetResultantForce  or  GetNetForce
   (25) %--------------------------------------------------------------------
   (26) Bo.AddForce( Fy*Ay> )                       % Add external force on Bo.
-> (27) Force_Bo> = Fy*Ay>

   (28) Bo.AddForce( Ao,  9*Ay> )                   % Add action/reaction force on Bo from Ao.
-> (29) Force_Bo_Ao> = 9*Ay>

   (30) Ao.AddForce( Bo,  2*Ay> )                   % Add action/reaction force on Ao from Bo.
-> (31) Force_Ao_Bo> = 2*Ay>

   (32) NetForceOnBoFromAo> = Bo.GetNetForce( Ao )  % Net action/reaction force on Bo from Ao.
-> (33) NetForceOnBoFromAo> = 7*Ay>

   (34) NetForceOnBo> = Bo.GetResultantForce()      % Net force on point Bo.
-> (35) NetForceOnBo> = (7+Fy)*Ay>

   (36) NetForceOnB> := B.GetResultantForce()       % Net force on body B.
-> (37) NetForceOnB> = (888+Fx)*Ax> + (7+Fy)*Ay>

   (38) NetForceOnA> := A.GetResultantForce()       % Net force on body A.
-> (39) NetForceOnA> = -888*Ax> - 7*Ay>

   (40) NetForceOnS> := System.GetResultantForce()  % Net force on System(A, B, Bp).
-> (41) NetForceOnS> = Fx*Ax> + Fy*Ay>



</PRE><nobr><a name="GetResultantTorque"><font color="darkBlue"><font size=+1><b>GetResultantTorque</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetResultantTorque  GetNetTorque  (synonymous)

 Purpose:  Returns the sum of torques applied to a rigid object.

Syntax 1:  Object.GetResultantTorque()  or  Object.GetNetTorque()
Syntax 2:  B.GetResultantTorque( A )    or       B.GetNetTorque( A )

   Input:  Object -- a RigidBody, RigidFrame, or System
           B -- the name of a RigidBody or RigidFrame.
           A -- the name of a RigidBody or RigidFrame.

Output 1:  Sum of all torques applied to Object.
Output 2:  Sum of all torques applied to B by A.

  Remark:  Torque_B>  denotes the inherently "external" torque on B whereas
           B.GetResultantTorque() also accounts for all action/reaction
           torques applied to B from all other objects in the system.

           Torque_B_A>  denotes the torque on B from A whereas
           B.GetResultantTorque(A)  returns  Torque_B_A> - Torque_A_B>.

  Remark:  B.GetTorque(A) is deprecated for B.GetResultantTorque(A).

  Remark:  The NewtonianFrame is not part of the "System" for the command
           System.GetResultantTorque().  Type HELP SYSTEM for more information.

 Related:  <a href="#AddForce"><b>AddForce</b></a>  <a href="#AddForceDamper"><b>AddForceDamper</b></a>  <a href="#AddForceElectrostatic"><b>AddForceElectrostatic</b></a>  <a href="#AddForceGravity"><b>AddForceGravity</b></a>
           <a href="#AddForceInverseSquare"><b>AddForceInverseSquare</b></a>  <a href="#AddForceLinearActuator"><b>AddForceLinearActuator</b></a>  <a href="#AddForceSpring"><b>AddForceSpring</b></a>
           <a href="#AddTorque"><b>AddTorque</b></a>  <a href="#AddTorqueDamper"><b>AddTorqueDamper</b></a>
           <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>  <a href="#GetResultantTorque"><b>GetResultantTorque</b></a>
           <a href="#GetForceGravityPotentialEnergy"><b>GetForceGravityPotentialEnergy</b></a>  <a href="#GetForceSpringPotentialEnergy"><b>GetForceSpringPotentialEnergy</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  GetResultantTorque  or  GetNetTorque
   (3) %--------------------------------------------------------------------
   (4) RigidBody  A, B
   (5) Specified  Tx
   (6) B.AddTorque( Tx*Ax> )                     % Add external torque on B.
-> (7) Torque_B> = Tx*Ax>

   (8) B.AddTorque( A,  888*Ax> )                % Add action/reaction torque on B from A.
-> (9) Torque_B_A> = 888*Ax>

   (10) NetTorqueOnBFromA> = B.GetNetTorque( A )  % Net action/reaction torque on B from A.
-> (11) NetTorqueOnBFromA> = 888*Ax>

   (12) NetTorqueOnAFromB> = A.GetNetTorque( B )  % Net action/reaction torque on A from B.
-> (13) NetTorqueOnAFromB> = -888*Ax>

   (14) NetTorqueOnB> = B.GetResultantTorque()    % Net torque on body B.
-> (15) NetTorqueOnB> = (888+Tx)*Ax>

   (16) NetTorqueOnA> = A.GetResultantTorque()    % Net torque on body A.
-> (17) NetTorqueOnA> = -888*Ax>

   (18) NetTorqueOnS> = System.GetNetTorque()     % Net torque on System(A, B).
-> (19) NetTorqueOnS> = Tx*Ax>

   (20) %--------------------------------------------------------------------
   (21) % Example 2:  GetResultantTorque  or  GetNetTorque
   (22) %--------------------------------------------------------------------
   (23) B.AddTorque( A,  9*Ay> )                  % Add action/reaction torque on B from A.
-> (24) Torque_B_A> = 888*Ax> + 9*Ay>

   (25) A.AddTorque( B,  2*Ay> )                  % Add action/reaction torque on A from B.
-> (26) Torque_A_B> = 2*Ay>

   (27) NetTorqueOnBFromA> := B.GetNetTorque( A ) % Net action/reaction torque on B from A.
-> (28) NetTorqueOnBFromA> = 888*Ax> + 7*Ay>

   (29) NetTorqueOnB> := B.GetResultantTorque()   % Net torque on body B.
-> (30) NetTorqueOnB> = (888+Tx)*Ax> + 7*Ay>

   (31) NetTorqueOnA> := A.GetResultantTorque()   % Net torque on body A.
-> (32) NetTorqueOnA> = -888*Ax> - 7*Ay>

   (33) NetTorqueOnS> := System.GetNetTorque()    % Net torque on System(A, B).
-> (34) NetTorqueOnS> = Tx*Ax>



</PRE><nobr><a name="GetRhs"><font color="darkBlue"><font size=+1><b>GetRhs</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetRhs

 Purpose:  Returns the expression that is assigned to a name.
           For example, if  y = 3*sin(t),  GetRhs(y)  returns 3*sin(t).

Syntax 1:  GetRhs( scalarName )
Syntax 2:  GetRhs( mathExpression )

 Input 1:  scalarName -- the name of a scalar quantity (e.g., y).
 Input 2:  mathExpression -- a scalar, vector, dyadic, or matrix expression.

Output 1:  The expression assigned to scalarName.  If scalarName does
           not have a right-hand-side, then scalarName is returned.
Output 2:  The expression that results when each scalarName appearing in
           mathExpression is replaced with its assigned right-hand-side.

  Remark:  Use the Explicit command to produce an expression that is solely in
           terms of scalar quantities that do not have a right-hand-side
           (e.g., names appearing in Constant or Variable declarations).

  Remark:  The GetRhs command is usually unnecessary for names of
           matrices, vectors, or dyadics.  Usually, these names are
           automatically replaced with their right-hand-sides.

 Related:  <a href="#Evaluate"><b>Evaluate</b></a>  <a href="#Explicit"><b>Explicit</b></a>  <a href="#GetRhs"><b>GetRhs</b></a>  <a href="#ReplaceString"><b>ReplaceString</b></a>  <a href="#SetAutoRhs"><b>SetAutoRhs</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example:  GetRhs
   (3) %--------------------------------------------------------------------
   (4) a = sin(t)
-> (5) a = sin(t)

   (6) b = cos(t)
-> (7) b = cos(t)

   (8) c = a + b
-> (9) c = a + b

   (10) r1 = GetRhs( a )              
-> (11) r1 = sin(t)

   (12) r2 = GetRhs( a + b )              
-> (13) r2 = sin(t) + cos(t)

   (14) r3 = GetRhs( a + b + c )  
-> (15) r3 = sin(t) + cos(t) + a + b

   (16) r4 = GetRhs( [a;  b;  c] )  
-> (17) r4 = [sin(t);  cos(t);  a + b]



</PRE><nobr><a name="GetRotationMatrix"><font color="darkBlue"><font size=+1><b>GetRotationMatrix</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetRotationMatrix

 Purpose:  Gets the rotation matrix relating two sets of bases vectors.

  Syntax:  B.GetRotationMatrix( N )

   Input:  B, N -- name of a RigidFrame or RigidBody.

  Output:  Rotation matrix B_N that relates Bx>, By>, Bz>  to  Nx>, Ny>, Nz>.

 Related:  <a href="#GetAngularAcceleration"><b>GetAngularAcceleration</b></a>  <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>  <a href="#GetRotationMatrix"><b>GetRotationMatrix</b></a>
           <a href="#SetAngularAcceleration"><b>SetAngularAcceleration</b></a>  <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>  <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>
           <a href="#GetRotationMatrixDyadic"><b>GetRotationMatrixDyadic</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: GetRotationMatrix 
   (3) %--------------------------------------------------------------------
   (4) RigidFrame N             
   (5) RigidBody  A, B
   (6) Variable   qA, qB
   (7) A.SetRotationMatrixX( N, qA )
-> (8) A_N = [1, 0, 0;  0, cos(qA), sin(qA);  0, -sin(qA), cos(qA)]

   (9) B.SetRotationMatrixY( A, qB )
-> (10) B_A = [cos(qB), 0, -sin(qB);  0, 1, 0;  sin(qB), 0, cos(qB)]

   (11) BRotationMatrixToN = B.GetRotationMatrix( N )
-> (12) BRotationMatrixToN[1,1] = cos(qB)
-> (13) BRotationMatrixToN[1,2] = sin(qA)*sin(qB)
-> (14) BRotationMatrixToN[1,3] = -sin(qB)*cos(qA)
-> (15) BRotationMatrixToN[2,1] = 0
-> (16) BRotationMatrixToN[2,2] = cos(qA)
-> (17) BRotationMatrixToN[2,3] = sin(qA)
-> (18) BRotationMatrixToN[3,1] = sin(qB)
-> (19) BRotationMatrixToN[3,2] = -sin(qA)*cos(qB)
-> (20) BRotationMatrixToN[3,3] = cos(qA)*cos(qB)



</PRE><nobr><a name="GetRotationMatrixDyadic"><font color="darkBlue"><font size=+1><b>GetRotationMatrixDyadic</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetRotationMatrixDyadic

 Purpose:  Gets the rotation matrix dyadic relating two sets of bases vectors.

  Syntax:  B.GetRotationMatrixDyadic( A )

   Input:  B, A -- name of a RigidFrame or RigidBody.

  Output:  Rotation dyadic B_A>> that relates Bx>, By>, Bz>  to  Ax>, Ay>, Az>.

 Related:  <a href="#GetAngularAcceleration"><b>GetAngularAcceleration</b></a>  <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>  <a href="#GetRotationMatrix"><b>GetRotationMatrix</b></a>
           <a href="#SetAngularAcceleration"><b>SetAngularAcceleration</b></a>  <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>  <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetRotationMatrixDyadic (form a rotation matrix dyadic)
   (3) %--------------------------------------------------------------------
   (4) RigidFrame A, B
   (5) Variable   q
   (6) B.SetRotationMatrixZ( A, q )
-> (7) B_A = [cos(q), sin(q), 0;  -sin(q), cos(q), 0;  0, 0, 1]

   (8) B_A>> = B.GetRotationMatrixDyadic( A )
-> (9) B_A>> = cos(q)*Bx>*Ax> + sin(q)*Bx>*Ay> - sin(q)*By>*Ax> + cos(q)*By>*Ay> + Bz>*Az>

   (10) A_B>> = A.GetRotationMatrixDyadic( B )
-> (11) A_B>> = cos(q)*Ax>*Bx> - sin(q)*Ax>*By> + sin(q)*Ay>*Bx> + cos(q)*Ay>*By> + Az>*Bz>

   (12) %--------------------------------------------------------------------
   (13) % Example 2: Use A_B>> to express a vector in another frame.
   (14) %--------------------------------------------------------------------
   (15) Variable  x, y, z
   (16) vA> = x*Ax> + y*Ay> + z*Az>    % Vector v expressed in frame A.
-> (17) vA> = x*Ax> + y*Ay> + z*Az>

   (18) vB> := Dot(   vA>,  A_B>> )    % Vector v expressed in frame B.
-> (19) vB> = (x*cos(q)+y*sin(q))*Bx> + (y*cos(q)-x*sin(q))*By> + z*Bz>

   (20) vB> := Dot( B_A>>,   vA>  )    % Vector v expressed in frame B.
-> (21) vB> = (x*cos(q)+y*sin(q))*Bx> + (y*cos(q)-x*sin(q))*By> + z*Bz>

   (22) vB> := Express( vA>,   B  )    % Vector v expressed in frame B.
-> (23) vB> = (x*cos(q)+y*sin(q))*Bx> + (y*cos(q)-x*sin(q))*By> + z*Bz>

   (24) vA> := Dot(   vB>,  B_A>> )    % Vector v expressed in frame A.
-> (25) vA> = x*Ax> + y*Ay> + z*Az>

   (26) vA> := Dot( A_B>>,   vB>  )    % Vector v expressed in frame A.
-> (27) vA> = x*Ax> + y*Ay> + z*Az>

   (28) vA> := Express( vB>,  A   )    % Vector v expressed in frame A.
-> (29) vA> = x*Ax> + y*Ay> + z*Az>



</PRE><nobr><a name="GetState"><font color="darkBlue"><font size=+1><b>GetState</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetState  and  GetDtState   (EXPERIMENTAL COMMAND, NOT RECOMMEND FOR USE).

 Purpose:  Creates an array of all names that are currently regarded as state.

Syntax 1:  GetState()
Syntax 2:  GetDtState()

Output 1:  Creates an array of all names that are currently regarded as state.
           These names are usually named in a Variable or Specified declaration.
Output 2:  The time-derivative of the matrix returned by State().

 Related:  <a href="#Constant"><b>Constant</b></a>  <a href="#ImaginaryNumber"><b>ImaginaryNumber</b></a>  <a href="#Specified"><b>Specified</b></a>  <a href="#Variable"><b>Variable</b></a>
           <a href="#SetGeneralizedSpeed"><b>SetGeneralizedCoordinate</b></a>  <a href="#SetGeneralizedSpeed"><b>SetGeneralizedSpeed</b></a>
           <a href="#SetGeneralizedSpeed"><b>GetGeneralizedCoordinate</b></a>  <a href="#SetGeneralizedSpeed"><b>GetGeneralizedSpeed</b></a>
           <a href="#SetDt"><b>SetDt</b></a>  <a href="#SolveDt"><b>SolveDt</b></a>  <a href="#SetAutoDifferentiate"><b>SetAutoDifferentiate</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetState and GetDtState
   (3) %--------------------------------------------------------------------
   (4) Variable   x, x', x''
   (5) State = GetState()
-> (6) State = [x;  x']

   (7) DtState = GetDtState()
-> (8) DtState = [x';  x'']

   (9) %--------------------------------------------------------------------
   (10) % Example 2: GetState and GetDtState
   (11) %--------------------------------------------------------------------
   (12) Specified  y'
   (13) State := GetState()
-> (14) State = [x;  x';  y]

   (15) DtState := GetDtState()
-> (16) DtState = [x';  x'';  y']



</PRE><nobr><a name="GetSpeed"><font color="darkBlue"><font size=+1><b>GetSpeed</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetSpeed  and  GetSpeedSquared

 Purpose:  Gets a point's speed in a reference frame.

Syntax 1:  Q.GetSpeed( refFrame )
Syntax 2:  Q.GetSpeedSquared( refFrame )

   Input:  Q -- name of a point.
           refFrame -- name of a RigidFrame or RigidBody.

Output 1:  Magnitude of Q's velocity in refFrame.
Output 2:  Square of the magnitude of Q's velocity in refFrame.

 Related:  <a href="#GetMagnitude"><b>GetMagnitude</b></a>           <a href="#GetMagnitude"><b>GetMagnitudeSquared</b></a>
           <a href="#GetDistance"><b>GetDistance</b></a>            <a href="#GetDistance"><b>GetDistanceSquared</b></a>
           <a href="#GetSpeed"><b>GetSpeed</b></a>               <a href="#GetSpeed"><b>GetSpeedSquared</b></a>
           <a href="#GetAngularSpeed"><b>GetAngularSpeed</b></a>        <a href="#GetAngularSpeed"><b>GetAngularSpeedSquared</b></a>
           <a href="#GetAngleBetweenVectors"><b>GetAngleBetweenVectors</b></a> <a href="#GetAngleBetweenVectors"><b>GetAngleBetweenUnitVectors</b></a>
           <a href="#GetPosition"><b>GetPosition</b></a>            <a href="#SetPosition"><b>SetPosition</b></a>       <a href="#Translate"><b>Translate</b></a>
           <a href="#GetVelocity"><b>GetVelocity</b></a>            <a href="#SetVelocity"><b>SetVelocity</b></a>       <a href="#SetPositionVelocity"><b>SetPositionVelocity</b></a>
           <a href="#GetAcceleration"><b>GetAcceleration</b></a>        <a href="#SetAcceleration"><b>SetAcceleration</b></a>   <a href="#SetVelocityAcceleration"><b>SetVelocityAcceleration</b></a>
           <a href="#GetUnitVector"><b>GetUnitVector</b></a>          <a href="#GetElongation"><b>GetElongation</b></a>     <a href="#Vector"><b>Vector</b></a>   <a href="#Cross"><b>Dot</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: GetSpeed  and  GetSpeedSquared
   (3) %--------------------------------------------------------------------
   (4) RigidFrame N
   (5) Point      Q            
   (6) Variable   vx, vy
   (7) Q.SetVelocity( N, vx*Nx> + vy*Ny> )
-> (8) v_Q_N> = vx*Nx> + vy*Ny>

   (9) speed = Q.GetSpeed( N )   
-> (10) speed = sqrt(vx^2+vy^2)

   (11) speedSquared = Q.GetSpeedSquared( N )   
-> (12) speedSquared = vx^2 + vy^2



</PRE><nobr><a name="GetStatics"><font color="darkBlue"><font size=+1><b>GetStatics</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetStatics    GetStaticsKane    GetStaticsLagrange

 Purpose:  Gets equations governing static equilibrium.

Syntax 1:  Object.GetStatics()
Syntax 2:  Object.GetStatics( aboutPoint )
Syntax 3:  System.GetStaticsKane()
Syntax 4:  System.GetStaticsLagrange()  IN DEVELOPMENT.  SEE SYNTAX.

   Input:  Object -- Point, Particle, RigidFrame, RigidBody, or System.
           aboutPoint -- The name of a point.

Output 1:  Resultant of all forces on Object.
Output 2:  Resultant of all moments on Object about aboutPoint.
Output 3:  Kane's     equation for statics for the entire System.
Output 4:  Lagrange's equation for statics for the entire System.

  Remark:  If Q is a point of a RigidFrame or RigidBody B, declare it as
           Point Q(B).  This helps with subsequent velocity/acceleration
           and force/moment calculations.

  Remark:  For Newton/Euler equations, type  Help Statics  or  Help Dynamics
           For Kane's       equations, type  Help Kane
           For Lagrange's   equations, type  Help Lagrange

 Related:  <a href="#AddForce"><b>AddForce</b></a>  <a href="#AddForceDamper"><b>AddForceDamper</b></a>  <a href="#AddForceElectrostatic"><b>AddForceElectrostatic</b></a>  <a href="#AddForceGravity"><b>AddForceGravity</b></a>
           <a href="#AddForceInverseSquare"><b>AddForceInverseSquare</b></a>  <a href="#AddForceLinearActuator"><b>AddForceLinearActuator</b></a>  <a href="#AddForceSpring"><b>AddForceSpring</b></a>
           <a href="#AddTorque"><b>AddTorque</b></a>  <a href="#AddTorqueDamper"><b>AddTorqueDamper</b></a>
           <a href="#GetMomentOfForces"><b>GetMomentOfForces</b></a>  <a href="#GetResultantForce"><b>GetResultantForce</b></a>  <a href="#GetResultantTorque"><b>GetResultantTorque</b></a>
           <a href="#GetForceGravityPotentialEnergy"><b>GetForceGravityPotentialEnergy</b></a>  <a href="#GetForceSpringPotentialEnergy"><b>GetForceSpringPotentialEnergy</b></a>
           <a href="#SetMass"><b>SetMass</b></a>  <a href="#SetPosition"><b>SetPosition</b></a>  <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>  <a href="#Rotate"><b>Rotate</b></a>
           <a href="#NewtonianFrame"><b>NewtonianFrame</b></a>  <a href="#Point"><b>Point</b></a>  <a href="#Particle"><b>Particle</b></a>  <a href="#RigidFrame"><b>RigidFrame</b></a>  <a href="#RigidBody"><b>RigidBody</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>
           <a href="#SetGeneralizedSpeed"><b>SetGeneralizedCoordinate</b></a>  <a href="#SetGeneralizedSpeed"><b>SetGeneralizedSpeed</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: GetStatics 
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N             
   (5) RigidBody      B           % Rigid pendulum
   (6) Constant       g           % Local gravitational constant
   (7) Constant       L           % Length of pendulum
   (8) Variable       theta       % Pendulum angle
   (9) Variable       Tz          % Torque applied to B from N
   (10) Variable       Fx, Fy      % Support force on Bo from No
   (11) B.SetMass( m )
   (12) B.SetRotationMatrixZ( N, theta )  
-> (13) B_N = [cos(theta), sin(theta), 0;  -sin(theta), cos(theta), 0;  0, 0, 1]

   (14) Bcm.SetPosition( Bo, -L*By> )
-> (15) p_Bo_Bcm> = -L*By>

   (16) Bo.AddForce( No, Fx*Nx> + Fy*Ny> ) 
-> (17) Force_Bo_No> = Fx*Nx> + Fy*Ny>

   (18) Bcm.AddForce( -m*g*Ny> )
-> (19) Force_Bcm> = -m*g*Ny>

   (20) B.AddTorque( Tz*Bz> )  
-> (21) Torque_B> = Tz*Bz>

   (22) % Resultant of all forces on B    
   (23) BStaticForces> = B.GetStatics()
-> (24) BStaticForces> = Fx*Nx> + (Fy-m*g)*Ny>

   (25) % Resultant of the moments of all forces on B about Bo    
   (26) BStaticMoments> = B.GetStatics( Bo )
-> (27) BStaticMoments> = Tz*Bz> - m*g*L*sin(theta)*Nz>

   (28) % Solve scalar equations for Fx, Fy, and Tz
   (29) BStatics[1] = Dot( BStaticForces>,  Nx> )
-> (30) BStatics[1] = Fx

   (31) BStatics[2] = Dot( BStaticForces>,  Ny> )
-> (32) BStatics[2] = Fy - m*g

   (33) BStatics[3] = Dot( BStaticMoments>, Nz> )
-> (34) BStatics[3] = Tz - m*g*L*sin(theta)

   (35) Solve( BStatics, Fx, Fy, Tz )
-> (36) Fx = 0
-> (37) Fy = m*g
-> (38) Tz = m*g*L*sin(theta)



</PRE><nobr><a name="SVD"><font color="darkBlue"><font size=+1><b>SVD</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SVD        Experimental command, not recommended for use!

 Purpose:  Calculates the singular values (and possibly singular vectors)
           of a real matrix.

Syntax 1:  SVD( M )
Syntax 2:  SVD( M, nameU, nameV )

   Input:  M -- a matrix whose elements are real numbers.

           nameU -- the name to be assigned to the matrix whose columns
           are the singular vectors of M * Transpose(M).

           nameV -- the name to be assigned to the matrix whose columns
           are the singular vectors of Transpose(M) * M.

Output 1:  Returns a column matrix Scol with M's singular values ordered
           from lowest to highest (subject to change).
Output 2:  Returns the column matrix Scol and assigns M's singular vectors
           to the columns of nameU and the columns of nameV.

  Remark:  M = U * S * Transpose(V), where U and V are orthonormal matrices
           and S is a diagonal matrix with M's singular values on the diagonal.

 Related:  <a href="#GetColumns"><b>GetColumns</b></a>     <a href="#GetDeterminant"><b>GetDeterminant</b></a>  <a href="#GetDiagonalMatrix"><b>GetDiagonalMatrix</b></a>  <a href="#GetEigen"><b>GetEigen</b></a>
           <a href="#GetElement"><b>GetElement</b></a> <a href="#[]"><b>[]</b></a>  <a href="#GetInverse"><b>GetInverse</b></a>      <a href="#GetIdentityMatrix"><b>GetIdentityMatrix</b></a>  <a href="#GetNorm"><b>GetNorm</b></a>  <a href="#GetColumns"><b>GetRows</b></a>
           <a href="#GetTrace"><b>GetTrace</b></a>       <a href="#GetTranspose"><b>GetTranspose</b></a>    <a href="#GetIdentityMatrix"><b>GetZeroMatrix</b></a>      <a href="#Solve"><b>Solve</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: SVD   (singularValues of a full-rank matrix)
   (3) %--------------------------------------------------------------------
   (4) A = [1, 2, 3;  4, 5, 6;  5, 3, 7]
-> (5) A = [1, 2, 3;  4, 5, 6;  5, 3, 7]

   (6) SingularValuesOfA = SVD( A )
-> (7) SingularValuesOfA = [0.7659489;  1.801498;  13.04484]

   (8) %--------------------------------------------------------------------
   (9) % Example 2: SVD   (singularValues of a singular matrix)
   (10) %--------------------------------------------------------------------
   (11) B = [1, 2, 3;  4, 5, 6;  2, 4, 6]
-> (12) B = [1, 2, 3;  4, 5, 6;  2, 4, 6]

   (13) SingularValuesOfB = SVD( B )
-> (14) SingularValuesOfB = [5.27944E-08;  1.363919;  12.04739]

   (15) %--------------------------------------------------------------------
   (16) % Example 3: SVD   (singularValues of a non-square matrix)
   (17) %--------------------------------------------------------------------
   (18) C = [1, 2, 3;  4, 5, 6]
-> (19) C = [1, 2, 3;  4, 5, 6]

   (20) SingularValuesOfC = SVD( C )
-> (21) SingularValuesOfC = [0.7728696;  9.508032]

   (22) %--------------------------------------------------------------------
   (23) % Example 4: SVD   (singularValues and singularVectors of a matrix)
   (24) %--------------------------------------------------------------------
   (25) D = [1, 2;  3, 4]
-> (26) D = [1, 2;  3, 4]

   (27) SingularValuesOfD := SVD( D, SingularVectorU, SingularVectorV )
-> (28) SingularVectorU = [-0.9145143, -0.4045536;  0.4045536, -0.9145143]
-> (29) SingularVectorV = [-0.8174156, -0.5760484;  0.5760484, -0.8174156]
-> (30) SingularValuesOfD = [0.3659662;  5.464986]



</PRE><nobr><a name="GetTaylorSeries"><font color="darkBlue"><font size=+1><b>GetTaylorSeries</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetTaylorSeries

 Purpose:  Expands functions in Taylor series.

  Syntax:  GetTaylorSeries( F, Range, arg1, arg2, ... )

   Input:  F -- a  scalar, vector, dyadic, or matrix expression.

           Range -- n  or  n:m,  where n and m are positive
                    integers such that n < m.

           argi -- the scalar name Ci (e.g., a constant or variable) or
                   the equation Ci = D (D is a scalar expression); or
                   the equation Ci = D:P, where P is a scalar name.

  Output:  The following table describes output associated with F.

           Range|    argi    |              Output
           -----|------------|-----------------------------------
             n  |  Ci        |  nth term of the Taylor series
                |            |  expansion of F about Ci = 0.
                |            |
             n  |  Ci = D    |  nth term of the Taylor series
                |            |  expansion of F about Ci = D.
                |            |
             n  |  Ci = D:P  |  nth term of the Taylor series
                |            |  expansion of F about Ci = D,
                |            |  with P in place of Ci - D.
                |            |
            n:m |  Ci        |  nth  through  mth  terms of Taylor
                |            |  expansion of F about Ci = 0.
                |            |
            n:m |  Ci = D    |  nth  through  mth  terms of Taylor
                |            |  expansion of F about Ci = D.
                |            |
            n:m |  Ci = D:P  |  nth  through  mth  terms of Taylor
                |            |  expansion of F about Ei = D,
                |            |  with P in place of Ci - D.

  Remark:  Certain numerical inaccuracies in Taylor series expansions
           may make it advantageous to issue a command such as
           SetAutoEpsilon( 1.0E-13 ).

 Related:  <a href="#GetDefaults"><b>GetDefaults</b></a>  <a href="#SetAutoZee"><b>SetAutoZee</b></a>
           <a href="#GetTaylorSeries"><b>GetTaylorSeries</b></a>  <a href="#Linearize"><b>Linearize</b></a>  <a href="#SetAutoTaylorSeries"><b>SetAutoLinearize</b></a>  <a href="#SetAutoTaylorSeries"><b>SetAutoTaylorSeries</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  GetTaylorSeries   (one function with one variable)
   (3) %--------------------------------------------------------------------
   (4) Variable x, dx
   (5) TaylorCosAbout0 = GetTaylorSeries( cos(x), 0:4, x )
-> (6) TaylorCosAbout0 = 1 + 0.04166667*x^4 - 0.5*x^2

   (7) TaylorCosAbout1 = GetTaylorSeries( cos(x), 0:3, x=1 )
-> (8) TaylorCosAbout1 = 1.381773 + 0.1402452*(-1+x)^3 - 0.841471*x - 0.2701512
       *(-1+x)^2

   (9) TaylorCosAbout1Dx = GetTaylorSeries( cos(x), 0:3, x=1:dx )
-> (10) TaylorCosAbout1Dx = 0.5403023 + 0.1402452*dx^3 - 0.841471*dx - 0.2701512
        *dx^2

   (11) %--------------------------------------------------------------------
   (12) % Example 2:  GetTaylorSeries   (one function with two variables)
   (13) %--------------------------------------------------------------------
   (14) Variable y, dy
   (15) TaylorExpXYAbout0 = GetTaylorSeries( exp(x+y), 0:1, x, y )
-> (16) TaylorExpXYAbout0 = 1 + x + y

   (17) TaylorExpXYAbout2 = GetTaylorSeries( exp(x+y), 0:1, x=2, y=2 )
-> (18) TaylorExpXYAbout2 = -163.7945 + 54.59815*x + 54.59815*y

   (19) TaylorExpXYAbout2Dxy = GetTaylorSeries( exp(x+y), 0:1, x=2:dx, y=2:dy )
-> (20) TaylorExpXYAbout2Dxy = 54.59815 + 54.59815*dx + 54.59815*dy

   (21) %--------------------------------------------------------------------
   (22) % Example 3:  GetTaylorSeries   (matrix of functions with one variable)
   (23) %--------------------------------------------------------------------
   (24) matrix = [sin(x); cos(x); exp(x)]
-> (25) matrix = [sin(x);  cos(x);  exp(x)]

   (26) matrixExpanded = GetTaylorSeries( matrix, 0:4, x=0 )
-> (27) matrixExpanded[1] = -0.1666667*x*(-6+x^2)
-> (28) matrixExpanded[2] = 1 + 0.04166667*x^4 - 0.5*x^2
-> (29) matrixExpanded[3] = 1 + x + 0.04166667*x^4 + 0.1666667*x^3 + 0.5*x^2

   (30) %--------------------------------------------------------------------
   (31) % Example 4:  GetTaylorSeries   (vector function of two variable)
   (32) %--------------------------------------------------------------------
   (33) z = sin(x) + cos(y)
-> (34) z = sin(x) + cos(y)

   (35) RigidFrame  N
   (36) vector> = sin(x)*Nx> + cos(y)*Ny> + z*Nz>
-> (37) vector> = sin(x)*Nx> + cos(y)*Ny> + z*Nz>

   (38) vectorExpanded> = GetTaylorSeries( vector>, 0:1, x=1:dx, y=2:dy )
-> (39) vectorExpanded> = (0.841471+0.5403023*dx)*Nx> + (-0.4161468-0.9092974*
        dy)*Ny> + (0.4253241+0.5403023*dx-0.9092974*dy)*Nz>



</PRE><nobr><a name="Linearize"><font color="darkBlue"><font size=+1><b>Linearize</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Linearize  Linearize0   Linearize1

 Purpose:  Returns the sum of the 0th and 1st term of a Taylor series
           or returns just the 0th or 1st terms of that Taylor series.

  Syntax:  Linearize(  F, arg1, arg2, ... )
           Linearize0( F, arg1, arg2, ... )  --  same as Evaluate.
           Linearize1( F, arg1, arg2, ... )

   Input:  F -- a  scalar, vector, dyadic, or matrix expression.

           argi -- the scalar name Ci (e.g., a constant or variable) or
                   the equation Ci = D (D is a scalar expression); or
                   the equation Ci = D:P, where P is a scalar name.

  Output:  The following table describes output associated with F.

               argi    |  Output is Taylor series expansion of F
           ------------|-----------------------------------
             Ci        |  0th  and/or  1st  terms about Ci = 0.
             Ci = D    |  0th  and/or  1st  terms about Ci = D.
             Ci = D:P  |  0th  and/or  1st  terms about Ei = D,
                       |  with P in place of Ci - D.

  Remark:  Certain numerical inaccuracies in Taylor series expansions
           may make it advantageous to issue a command such as
           SetAutoEpsilon( 1.0E-13 ).

 Related:  <a href="#GetDefaults"><b>GetDefaults</b></a>  <a href="#SetAutoZee"><b>SetAutoZee</b></a>
           <a href="#GetTaylorSeries"><b>GetTaylorSeries</b></a>  <a href="#Linearize"><b>Linearize</b></a>  <a href="#SetAutoTaylorSeries"><b>SetAutoLinearize</b></a>  <a href="#SetAutoTaylorSeries"><b>SetAutoTaylorSeries</b></a>
           <a href="#FactorLinear"><b>FactorLinear</b></a>  <a href="#FactorLinear"><b>FactorQuadratic</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  Linearize   (one function with one variable)
   (3) %--------------------------------------------------------------------
   (4) Variable x, dx
   (5) linearizeCosAbout0 = Linearize( cos(x), x )
-> (6) linearizeCosAbout0 = 1

   (7) linearizeCosAbout1 = Linearize( cos(x), x=1 )
-> (8) linearizeCosAbout1 = 1.381773 - 0.841471*x

   (9) linearizeCosAbout1Dx = Linearize( cos(x), x=1:dx )
-> (10) linearizeCosAbout1Dx = 0.5403023 - 0.841471*dx

   (11) %--------------------------------------------------------------------
   (12) % Example 2:  Linearize   (one function with two variables)
   (13) %--------------------------------------------------------------------
   (14) Variable y, dy
   (15) linearizeExpXYAbout0 = Linearize( exp(x+y), x, y )
-> (16) linearizeExpXYAbout0 = 1 + x + y

   (17) linearizeExpXYAbout2 = Linearize( exp(x+y), x=2, y=2 )
-> (18) linearizeExpXYAbout2 = -163.7945 + 54.59815*x + 54.59815*y

   (19) linearizeExpXYAbout2Dxy = Linearize( exp(x+y), x=2:dx, y=2:dy )
-> (20) linearizeExpXYAbout2Dxy = 54.59815 + 54.59815*dx + 54.59815*dy

   (21) %--------------------------------------------------------------------
   (22) % Example 3:  Linearize   (matrix of functions with one variable)
   (23) %--------------------------------------------------------------------
   (24) matrix = [sin(x); cos(x); exp(x)]
-> (25) matrix = [sin(x);  cos(x);  exp(x)]

   (26) linearizeMatrix  = Linearize(  matrix, x=0 )
-> (27) linearizeMatrix = [x;  1;  1 + x]

   (28) linearizeMatrix0 = Linearize0( matrix, x=0 )
-> (29) linearizeMatrix0 = [0;  1;  1]

   (30) linearizeMatrix1 = Linearize1( matrix, x=0 )
-> (31) linearizeMatrix1 = [x;  0;  x]

   (32) %--------------------------------------------------------------------
   (33) % Example 4:  Linearize   (vector function of two variable)
   (34) %--------------------------------------------------------------------
   (35) z = sin(x) + cos(y)
-> (36) z = sin(x) + cos(y)

   (37) RigidFrame  N
   (38) vector> = sin(x)*Nx> + cos(y)*Ny> + z*Nz>
-> (39) vector> = sin(x)*Nx> + cos(y)*Ny> + z*Nz>

   (40) vectorExpanded> = Linearize( vector>, x=1:dx, y=2:dy )
-> (41) vectorExpanded> = (0.841471+0.5403023*dx)*Nx> + (-0.4161468-0.9092974*
        dy)*Ny> + (0.4253241+0.5403023*dx-0.9092974*dy)*Nz>



</PRE><nobr><a name="GetNorm"><font color="darkBlue"><font size=+1><b>GetNorm</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetNorm

 Purpose:  Forms the 2-norm of a real one-dimensional (row or column) matrix.

  Syntax:  GetNorm( matrixExpression )

   Input:  matrixExpression -- row or column matrix.

  Output:  sqrt( matrixExpression * transpose(matrixExpression) )

  Remark:  Use  abs           for absolute value of a real or complex scalar.
           Use  GetMagnitude  for the magnitude of a vector.
           Use  GetNorm       for the 2-norm of a real row or column matrix.

 Related:  <a href="#GetColumns"><b>GetColumns</b></a>     <a href="#GetDeterminant"><b>GetDeterminant</b></a>  <a href="#GetDiagonalMatrix"><b>GetDiagonalMatrix</b></a>  <a href="#GetEigen"><b>GetEigen</b></a>
           <a href="#GetElement"><b>GetElement</b></a> <a href="#[]"><b>[]</b></a>  <a href="#GetInverse"><b>GetInverse</b></a>      <a href="#GetIdentityMatrix"><b>GetIdentityMatrix</b></a>  <a href="#GetNorm"><b>GetNorm</b></a>  <a href="#GetColumns"><b>GetRows</b></a>
           <a href="#GetTrace"><b>GetTrace</b></a>       <a href="#GetTranspose"><b>GetTranspose</b></a>    <a href="#GetIdentityMatrix"><b>GetZeroMatrix</b></a>      <a href="#Solve"><b>Solve</b></a>
           <a href="#abs"><b>abs</b></a>            <a href="#GetMagnitude"><b>GetMagnitude</b></a>    <a href="#GetMagnitude"><b>GetMagnitudeSquared</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetNorm   (row matrix)
   (3) %--------------------------------------------------------------------
   (4) A = [1, 2, -2]
-> (5) A = [1, 2, -2]

   (6) Anorm = GetNorm( A )
-> (7) Anorm = 3

   (8) %--------------------------------------------------------------------
   (9) % Example 2: GetNorm   (column matrix)
   (10) %--------------------------------------------------------------------
   (11) B = [5;  12]
-> (12) B = [5;  12]

   (13) Bnorm = GetNorm( B )
-> (14) Bnorm = 13

   (15) %--------------------------------------------------------------------
   (16) % Example 3: GetNorm   (symbolic column matrix)
   (17) %--------------------------------------------------------------------
   (18) C = [sin(t);  cos(t);  3;  4;  exp(t)]
-> (19) C = [sin(t);  cos(t);  3;  4;  exp(t)]

   (20) Cnorm = GetNorm( C )
-> (21) Cnorm = sqrt(26+exp(2*t))



</PRE><nobr><a name="GetTrace"><font color="darkBlue"><font size=+1><b>GetTrace</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetTrace

 Purpose:  Forms the trace of a matrix or dyadic.

  Syntax:  GetTrace( A )

   Input:  A -- a matrix or a dyadic.

  Output:  Trace of A.

 Related:  <a href="#GetColumns"><b>GetColumns</b></a>     <a href="#GetDeterminant"><b>GetDeterminant</b></a>  <a href="#GetDiagonalMatrix"><b>GetDiagonalMatrix</b></a>  <a href="#GetEigen"><b>GetEigen</b></a>
           <a href="#GetElement"><b>GetElement</b></a> <a href="#[]"><b>[]</b></a>  <a href="#GetInverse"><b>GetInverse</b></a>      <a href="#GetIdentityMatrix"><b>GetIdentityMatrix</b></a>  <a href="#GetNorm"><b>GetNorm</b></a>  <a href="#GetColumns"><b>GetRows</b></a>
           <a href="#GetTrace"><b>GetTrace</b></a>       <a href="#GetTranspose"><b>GetTranspose</b></a>    <a href="#GetIdentityMatrix"><b>GetZeroMatrix</b></a>      <a href="#Solve"><b>Solve</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetTrace   ( trace of a matrix )
   (3) %--------------------------------------------------------------------
   (4) Constant a{1:3,1:3}
   (5) M = [a11, a12, a13; a21, a22, a23]
-> (6) M = [a11, a12, a13;  a21, a22, a23]

   (7) traceOfMatrixM = GetTrace( M )
-> (8) traceOfMatrixM = a11 + a22

   (9) %--------------------------------------------------------------------
   (10) % Example 2: GetTrace   ( trace of a dyadic )
   (11) %--------------------------------------------------------------------
   (12) RigidBody B
   (13) D>> = Dyadic( B,  a11, a12, 0,  0, 0, 0,  0, a23, a33  )
-> (14) D>> = a11*Bx>*Bx> + a12*Bx>*By> + a23*Bz>*By> + a33*Bz>*Bz>

   (15) traceOfDyadicD = GetTrace( D>> )
-> (16) traceOfDyadicD = a11 + a33



</PRE><nobr><a name="GetTranspose"><font color="darkBlue"><font size=+1><b>GetTranspose</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetTranspose

 Purpose:  Forms the transpose of a matrix or dyadic.

  Syntax:  GetTranspose( A )

   Input:  A -- a matrix or a dyadic.

  Output:  Trace of A.

 Related:  <a href="#GetColumns"><b>GetColumns</b></a>     <a href="#GetDeterminant"><b>GetDeterminant</b></a>  <a href="#GetDiagonalMatrix"><b>GetDiagonalMatrix</b></a>  <a href="#GetEigen"><b>GetEigen</b></a>
           <a href="#GetElement"><b>GetElement</b></a> <a href="#[]"><b>[]</b></a>  <a href="#GetInverse"><b>GetInverse</b></a>      <a href="#GetIdentityMatrix"><b>GetIdentityMatrix</b></a>  <a href="#GetNorm"><b>GetNorm</b></a>  <a href="#GetColumns"><b>GetRows</b></a>
           <a href="#GetTrace"><b>GetTrace</b></a>       <a href="#GetTranspose"><b>GetTranspose</b></a>    <a href="#GetIdentityMatrix"><b>GetZeroMatrix</b></a>      <a href="#Solve"><b>Solve</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: GetTranspose  ( transpose of a matrix )
   (3) %--------------------------------------------------------------------
   (4) Constant a, b
   (5) M = [a, b;  3, 4;  5, 6]
-> (6) M = [a, b;  3, 4;  5, 6]

   (7) transposeM = GetTranspose( M )
-> (8) transposeM = [a, 3, 5;  b, 4, 6]

   (9) %--------------------------------------------------------------------
   (10) % Example 2: GetTranspose  ( transpose of a dyadic )
   (11) %--------------------------------------------------------------------
   (12) RigidBody B
   (13) D>> = Dyadic( B,  a, a*b, 3,  4, b^2, 5,  6, 7, 8 )
-> (14) D>> = a*Bx>*Bx> + a*b*Bx>*By> + 3*Bx>*Bz> + 4*By>*Bx> + b^2*By>*By>
        + 5*By>*Bz> + 6*Bz>*Bx> + 7*Bz>*By> + 8*Bz>*Bz>

   (15) tranposeD>> = GetTranspose( D>> )
-> (16) tranposeD>> = a*Bx>*Bx> + 4*Bx>*By> + 6*Bx>*Bz> + a*b*By>*Bx> + b^2*By>*By>
        + 7*By>*Bz> + 3*Bz>*Bx> + 5*Bz>*By> + 8*Bz>*Bz>



</PRE><nobr><a name="GetUnitVector"><font color="darkBlue"><font size=+1><b>GetUnitVector</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetUnitVector

 Purpose:  Forms a unit vector in the same direction as a given vector.

Syntax 1:  GetUnitVector( v> )
Syntax 2:  GetUnitVector( v>, denominator )
Syntax 3:  Q.GetUnitVector( fromPoint )
Syntax 4:  Q.GetUnitVector( fromPoint, denominator )

   Input:  v> -- a vector
           Q -- The name of a point.
           fromPoint -- The name of another point.
           denominator -- A non-negative scalar expression equal to the
                          magnitude of v> -- or equal to the magnitude
                          of v> plus a small "epsilon", where epsilon's
                          purpose is to avoid divide-by-zero errors.

Output 1:  v> divided by the magnitude of v>
Output 2:  v> divided by denominator
Output 3:  Unit vector directed to Q from fromPoint
Output 4:  Q's position vector fromPoint divided by denominator

 Remark:   denominator is useful when a symbol already exists for the
           magnitude of v> - or when an "epsilon" is useful for avoiding
           divide-by-zero errors that otherwise may result when the
           magnitude of v> is zero.

 Related:  <a href="#GetMagnitude"><b>GetMagnitude</b></a>           <a href="#GetMagnitude"><b>GetMagnitudeSquared</b></a>
           <a href="#GetDistance"><b>GetDistance</b></a>            <a href="#GetDistance"><b>GetDistanceSquared</b></a>
           <a href="#GetSpeed"><b>GetSpeed</b></a>               <a href="#GetSpeed"><b>GetSpeedSquared</b></a>
           <a href="#GetAngularSpeed"><b>GetAngularSpeed</b></a>        <a href="#GetAngularSpeed"><b>GetAngularSpeedSquared</b></a>
           <a href="#GetAngleBetweenVectors"><b>GetAngleBetweenVectors</b></a> <a href="#GetAngleBetweenVectors"><b>GetAngleBetweenUnitVectors</b></a>   <a href="#ConvertUnits"><b>ConvertUnits</b></a>
           <a href="#GetUnitVector"><b>GetUnitVector</b></a>          <a href="#Vector"><b>Vector</b></a>   <a href="#Cross"><b>Cross</b></a>  <a href="#Cross"><b>Dot</b></a>   <a href="#Rotate"><b>Rotate</b></a>

   (1) %--------------------------------------------------------------------
   (2) %Example 1: GetUnitVector   (Unit vector from vector)
   (3) %--------------------------------------------------------------------
   (4) RigidFrame N
   (5) v> = 3*Nx> + 4*Ny>
-> (6) v> = 3*Nx> + 4*Ny>

   (7) unitVector> = GetUnitVector( v> )
-> (8) unitVector> = 0.6*Nx> + 0.8*Ny>

   (9) %--------------------------------------------------------------------
   (10) %Example 2: GetUnitVector   (Unit vector from vector with denominator)
   (11) %--------------------------------------------------------------------
   (12) Constant  epsilon
   (13) unitVectorWithEpsilon> = GetUnitVector( t*Nx>, epsilon+t )
-> (14) unitVectorWithEpsilon> = t/(epsilon+t)*Nx>

   (15) %--------------------------------------------------------------------
   (16) %Example 3: GetUnitVector   (Unit vector between points)
   (17) %--------------------------------------------------------------------
   (18) Point     P, Q
   (19) Variable  zQ
   (20) Q.SetPosition( P,  zQ*Nz> )
-> (21) p_P_Q> = zQ*Nz>

   (22) UnitPositionVectorFromPToQ> = Q.GetUnitVector( P )
-> (23) UnitPositionVectorFromPToQ> = zQ/abs(zQ)*Nz>

   (24) %--------------------------------------------------------------------
   (25) %Example 4: GetUnitVector   (Unit vector between points with denominator)
   (26) %--------------------------------------------------------------------
   (27) Variable  xP, yP
   (28) P.SetPosition( No, xP*Nx> + yP*Ny> )
-> (29) p_No_P> = xP*Nx> + yP*Ny>

   (30) L = Q.GetDistance( No )
-> (31) L = sqrt(xP^2+yP^2+zQ^2)

   (32) UnitPositionVectorFromNoToQ> = Q.GetUnitVector( No, L )
-> (33) UnitPositionVectorFromNoToQ> = xP/L*Nx> + yP/L*Ny> + zQ/L*Nz>



</PRE><nobr><a name="GetUnitSystem"><font color="darkBlue"><font size=+1><b>GetUnitSystem</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetUnitSystem

 Purpose:  Displays the dimensions of a quantity.
           Displays the names of all units recognized by the program.

Syntax 1:  GetUnitSystem( unitExpression )
Syntax 2:  GetUnitSystem()

   Input:  unitExpression -- an expression involving names of units and their
                             products (*), quotients (/), and powers (^).

Output 1:  The dimension of unitExpression.  For example, if unitExpression
           is  Newton*meter,  the response is  mass*length^2/time^2.

Output 2:  Names of all units recognized by the program.

 Related:  <a href="#ODE"><b>ODE</b></a>  <a href="#Solve"><b>Solve</b></a>  <a href="#Input"><b>Input</b></a>  <a href="#Output"><b>Output</b></a>  <a href="#Output"><b>OutputPlot</b></a>  <a href="#Plot"><b>Plot</b></a>  <a href="#Animate"><b>Animate</b></a>
           <a href="#ConvertUnits"><b>ConvertUnits</b></a>  <a href="#GetUnitSystem"><b>GetUnitSystem</b></a>  <a href="#SetUnitSystem"><b>SetUnitSystem</b></a>
           <a href="#GetMassUnit"><b>GetMassUnit</b></a>   <a href="#GetMassUnit"><b>GetLengthUnit</b></a>   <a href="#GetMassUnit"><b>GetTimeUnit</b></a>   <a href="#GetMassUnit"><b>GetAngleUnit</b></a>

--------------------------------------------------------------------
 Example:  GetUnitSystem
--------------------------------------------------------------------
   (1) GetUnitSystem( Newton * meter^2 )
mass*length^3/time^2



</PRE><nobr><a name="GetVelocity"><font color="darkBlue"><font size=+1><b>GetVelocity</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetVelocity  or  GetRelativeVelocity

 Purpose:  Gets a point's velocity in a reference frame or gets a point's
           velocity relative to another point in a reference frame.

Syntax 1:  Q.GetVelocity( refFrame )
Syntax 2:  Q.GetVelocityRelative( P, refFrame )
           Q.GetRelativeVelocity( P, refFrame )

   Input:  Q, P -- names of points (e.g., Point or Particle).
           refFrame -- name of a RigidFrame or RigidBody.

Output 1:  Returns Q's velocity in refFrame.
Output 2:  Returns Q's velocity relative to P in refFrame, defined as
           Q.GetVelocity(refFrame) - P.GetVelocity(refFrame) or as
           Dt( Q.GetPosition(P), refFrame ).

 Related:  <a href="#Translate"><b>Translate</b></a>        <a href="#SetPositionVelocity"><b>SetPositionVelocity</b></a>        <a href="#SetVelocityAcceleration"><b>SetVelocityAcceleration</b></a>
           <a href="#SetPosition"><b>SetPosition</b></a>      <a href="#GetPosition"><b>GetPosition</b></a>   <a href="#GetDistance"><b>GetDistance</b></a>  <a href="#GetElongation"><b>GetElongation</b></a>
           <a href="#SetVelocity"><b>SetVelocity</b></a>      <a href="#GetVelocity"><b>GetVelocity</b></a>   <a href="#GetSpeed"><b>GetSpeed</b></a>     <a href="#GetVelocity"><b>GetRelativeVelocity</b></a>
           <a href="#SetAcceleration"><b>SetAcceleration</b></a>  <a href="#GetAcceleration"><b>GetAcceleration</b></a>            <a href="#GetAcceleration"><b>GetRelativeAcceleration</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: GetVelocity 
   (3) %--------------------------------------------------------------------
   (4) RigidFrame  N
   (5) RigidBody   B
   (6) Variable    vx, vy, wz
   (7) Bo.SetVelocity( N,  vx*Nx> + vy*Ny> )
-> (8) v_Bo_N> = vx*Nx> + vy*Ny>

   (9) BoVelocityInN> = Bo.GetVelocity( N )   
-> (10) BoVelocityInN> = vx*Nx> + vy*Ny>

   (11) %--------------------------------------------------------------------
   (12) % Example: GetRelativeVelocity  (also called GetVelocityRelative)
   (13) %--------------------------------------------------------------------
   (14) Point       P            
   (15) Variable    x', y'
   (16) P.SetVelocity( N,  x'*Nx> + y'*Ny> )
-> (17) v_P_N> = x'*Nx> + y'*Ny>

   (18) vQRelativeToBo> = P.GetRelativeVelocity( Bo, N )
-> (19) vQRelativeToBo> = (x'-vx)*Nx> + (y'-vy)*Ny>

   (20) %--------------------------------------------------------------------
   (21) % Example: GetRelativeVelocity  (via differentiation).
   (22) %--------------------------------------------------------------------
   (23) Point       S            
   (24) S.SetPosition( P,  t^2*Nx> + t^3*Ny> )
-> (25) p_P_S> = t^2*Nx> + t^3*Ny>

   (26) vSRelativeToP> = S.GetRelativeVelocity( P, N )
-> (27) vSRelativeToP> = 2*t*Nx> + 3*t^2*Ny>

   (28) %--------------------------------------------------------------------
   (29) % Example: GetVelocity (via two points fixed on RigidBody B).
   (30) %--------------------------------------------------------------------
   (31) Point       Q( B )
   (32) B.SetAngularVelocity( N, wz*Bz> )
-> (33) w_B_N> = wz*Bz>

   (34) Q.SetPosition( Bo,  x*Bx> + y*By> )
-> (35) p_Bo_Q> = x*Bx> + y*By>

   (36) QVelocityInN> = Q.GetVelocity( N )
-> (37) QVelocityInN> = -wz*y*Bx> + wz*x*By> + vx*Nx> + vy*Ny>



</PRE><nobr><a name="GetVelocityRemainder"><font color="darkBlue"><font size=+1><b>GetVelocityRemainder</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetVelocityRemainder  GetAngularVelocityRemainder

 Purpose:  Forms velocity and angular velocity remainder.

Syntax 1:  Q.GetVelocityRemainder( refFrame )
Syntax 2:  B.GetAngularVelocityRemainder( refFrame )
Syntax 3:  GetVelocityRemainder( mathExpression )

   Input:  Q -- name of a Point or Particle.
           B -- name of a RigidFrame or RigidBody.
           refFrame -- name of a RigidFrame or  RigidBody.
           mathExpression -- A scalar, vector, matrix, ... expression.

Output 1:  Portion of Q's velocity in refFrame that does NOT
           multiply an independent generalized speed.

Output 2:  Portion of B's angular velocity in in refFrame that does NOT
           multiply an independent generalized speed.

Output 3:  Portion of mathExpression that does NOT
           multiply an independent generalized speed.

  Remark:  The returned quantity may depend on whether the command is
           issued before or after the CONSTRAIN command.

 Related:  <a href="#GetPartialVelocity"><b>GetPartialVelocity</b></a>    <a href="#GetPartialVelocity"><b>GetPartialAngularVelocity</b></a>
           <a href="#GetVelocityRemainder"><b>GetVelocityRemainder</b></a>  <a href="#GetVelocityRemainder"><b>GetAngularVelocityRemainder</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: GetVelocityRemainder and GetAngularVelocityRemainder
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N
   (5) RigidBody      B       % Sphere
   (6) Point          BN(B)   % Point of B in contact with N
   (7) %----------------------------------------------
   (8) Constant    R
   (9) Variable    x', y'
   (10) Variable    wz
   (11) Specified   wx,  wy
   (12) SetGeneralizedSpeed( x', y', wz )
   (13) %----------------------------------------------
   (14) %     Kinematics
   (15) B.SetAngularVelocity( N,  wx*Nx> + wy*Ny> + wz*Nz> )
-> (16) w_B_N> = wx*Nx> + wy*Ny> + wz*Nz>

   (17) Bcm.SetPositionVelocity( No, x*Nx> + y*Ny> + R*Nz> )
-> (18) p_No_Bcm> = x*Nx> + y*Ny> + R*Nz>
-> (19) v_Bcm_N> = x'*Nx> + y'*Ny>

   (20) %----------------------------------------------
   (21) %     Angular velocity and velocity remainders
   (22) wBNRemainder> = B.GetAngularVelocityRemainder( N ) 
-> (23) wBNRemainder> = wx*Nx> + wy*Ny>

   (24) vBcmNRemainder> = Bcm.GetVelocityRemainder( N )
-> (25) vBcmNRemainder> = 0>



</PRE><nobr><a name="if"><font color="darkBlue"><font size=+1><b>if</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
if  else  elseif  (used for control flow in scripts, also see IsPositive, etc.)

 Purpose:  Controls whether or not certain lines are executed in a script
           depending on whether a logical expression evaluates to true.
           If true, statements contained within braces are executed.
           Otherwise, the statements are skipped.

Syntax 1:  if( LogicalExpression )  { Statements }

Syntax 2:  if( LogicalExpression )  { StatementsA }
           else                     { StatementsB }

Syntax 3:  if(     LogicalExpressionA )  { StatementsA }
           elseif( LogicalExpressionB )  { StatementsB }

Syntax 4:  if(     LogicalExpressionA )  { StatementsA }
           elseif( LogicalExpressionB )  { StatementsB }
           elseif( LogicalExpressionC )  { StatementsC }
           else                          { StatementsD }

   Input:  LogicalExpression -- an expression that evaluates to true or false
           and which involves at least one of the comparative operators which
           are evaluates using logic in the command IsSimplifyZero.

           ==   equal to
           !=   not equal to
           <=   less than or equal to
           <    less than
           >=   greater than or equal to  -- must be preceded by a blank space.
           >    greater than              -- must be preceded by a blank space.

           Use && (and) or || (or) to separate multiple logical expressions.

  Remark:  See: IsNegative,  IsNegativeOr0,  IsPositiveOr0,  IsPositive
           To implement   if t < 0,  Fx = sin(t),  else Fx = cos(t),  use:
           Fx = IsNegative(t) * sin(t)  +  IsPositiveOr0(t) * cos(t)

  Remark:  Alternatively, use MATLAB, C, or Fortran to control code flow.
           For example, the following shows how to make x = 0 when t >= pi.

           Specified sintOrZero = sin(t)
           Variable y' = sintOrZero               % Valid when t <= pi.
           Input   tFinal = 4,  y = 0             % Arbitrary input values.
           Output  t, y,  y'
           %% if( t > pi ) sintOrZero = 0;  end
           ODE()  simulateWithIfStatement.m       % Create MATLAB program.

           Edit simulateWithIfStatement.m and verify it contains the line
           %% if( t > pi ) sintOrZero = 0;  end
           Un-comment and move this line so the MATLAB code has

           sintOrZero = sin(t);
           if( t > pi ) sintOrZero = 0;  end

 Related:  <a href="#!"><b>!</b></a>  <a href="#%"><b>%</b></a>  <a href="#&"><b>&</b></a>  <a href="#Clear"><b>Clear</b></a>  <a href="#Save"><b>Save</b></a>  <a href="#Run"><b>Run</b></a>  <a href="#Quit"><b>Quit</b></a>  <a href="#if"><b>if</b></a>  <a href="#if"><b>else</b></a>  <a href="#if"><b>elseif</b></a>  <a href="#ceil"><b>ceil</b></a>  <a href="#ceil"><b>floor</b></a>  <a href="#sign"><b>sign</b></a>
           <a href="#IsPositive"><b>IsNegative</b></a>  <a href="#IsPositive"><b>IsNegativeOr0</b></a>  <a href="#IsPositive"><b>IsPositiveOr0</b></a>  <a href="#IsPositive"><b>IsPositive</b></a>
           <a href="#IsSimplifyEqual"><b>IsSimplifyEqual</b></a>  <a href="#IsSimplifyZero"><b>IsSimplifyZero</b></a>  <a href="#IsSimplifyTrue"><b>IsSimplifyTrue</b></a>

--------------------------------------------------------------------
Example 1a: if                   % Results in x = 18.
--------------------------------------------------------------------
 if( 5 != 4 )  { x = 6*3 }

--------------------------------------------------------------------
Example 1b: if                   % Results in x = 18   and  y = 24.
--------------------------------------------------------------------
 if( (5 >= 6  ||  2*pi >= 6)  &&  8 < 9 )  { x = 6*3;  y=6*4 }

--------------------------------------------------------------------
Example 2: if  else              % Results in x = 3   and  y = 4.
--------------------------------------------------------------------
 if( 5 >= 6 )  { x = 6*3;  y=6*4 }
 else          { x = 3;    y=4  }

--------------------------------------------------------------------
Example 3: if  elseif            % Results in x = 17.
--------------------------------------------------------------------
 if( 5 >= 6  )           { x = 6*3;  y=6*4 }
 elseif( sqrt(5) > 2 )   { x = 17 }

--------------------------------------------------------------------
Example 4: if  elseif  else      % Results in x = 18  and  y = 24.
--------------------------------------------------------------------
 if( 5 >= 6  )           { x = 6*3;  y=6*4 }
 elseif( sqrt(5) >  9 )  { x = 17 }
 elseif( sqrt(4) == 2 )  { x = 16 }
 else
 {
    x = 6 * 3
    y = 6 * 4
 }
--------------------------------------------------------------------
Example 5:  if t < 0,  Fx = sin(t),  else Fx = cos(t)
--------------------------------------------------------------------
 Fx = IsNegative(t) * sin(t)  +  IsPositiveOr0(t) * cos(t)

--------------------------------------------------------------------
Example 6:  if 5 < t < 9,  Fy = exp(t),  else Fy = 0
--------------------------------------------------------------------
 isTimeGreaterThan5 = IsPositive( t - 5 )
 isTimeLessThan9    = IsNegative( t - 9 )
 isTimeBetween5And9 = isTimeGreaterThan5 * isTimeLessThan9
 Fy = isTimeBetween5And9 * exp(t)


</PRE><nobr><a name="ImaginaryNumber"><font color="darkBlue"><font size=+1><b>ImaginaryNumber</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
ImaginaryNumber

 Purpose:  Declares the name assigned to the square root of -1.
           Returns  the name assigned to the square root of -1.

Syntax 1:  SetImaginaryNumber( i )
Syntax 2:  GetImaginaryNumber()

   Input:  i -- the name to be assigned to sqrt(-1).

Output 2:  Name assigned to sqrt(-1).

  Remark:  The default name of the square root of -1 is imaginary.

 Related:  <a href="#Constant"><b>Constant</b></a>  <a href="#ImaginaryNumber"><b>ImaginaryNumber</b></a>  <a href="#Specified"><b>Specified</b></a>  <a href="#Variable"><b>Variable</b></a>
           <a href="#MathFunctions"><b>MathFunctions</b></a>  <a href="#SetComplex"><b>SetComplex</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: ImaginaryNumber  
   (3) %--------------------------------------------------------------------
   (4) B = 3 + sqrt(-1)         % Default name of sqrt(-1) is imaginary
-> (5) B = 3 + imaginary

   (6) SetImaginaryNumber( i )
   (7) C = 3 + sqrt(-1)
-> (8) C = 3 + i

   (9) D = 4*sqrt(-1) + 3*GetImaginaryNumber()
-> (10) D = 7*i

   (11) E = abs(3+i) + sin(i) + cosh(i)
-> (12) E = 3.70258 + 1.175201*i



</PRE><nobr><a name="IndependentVariable"><font color="darkBlue"><font size=+1><b>IndependentVariable</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
IndependentVariable

 Purpose:  Declares the name assigned to the independent variable.
           Returns  the name assigned to the independent variable.

Syntax 1:  SetIndependentVariable( t )
Syntax 2:  GetIndependentVariable()

   Input:  t --  the name to be assigned as the independent variable.

Output 2:  Name assigned to the independent variable.

  Remark:  The default name of the independent variable is t.

  Remark:  The prime symbol ' denotes implicit ordinary differentiation
           with respect to the independent variable.  For example, when
           the independent variable t denotes time, x' denotes dx/dt,
           the ordinary time-derivative of x.

 Related:  <a href="#Constant"><b>Constant</b></a>  <a href="#ImaginaryNumber"><b>ImaginaryNumber</b></a>  <a href="#Specified"><b>Specified</b></a>  <a href="#Variable"><b>Variable</b></a>
           <a href="#SetGeneralizedSpeed"><b>SetGeneralizedCoordinate</b></a>  <a href="#SetGeneralizedSpeed"><b>SetGeneralizedSpeed</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  IndependentVariable  
   (3) %--------------------------------------------------------------------
   (4) Variable  y''  
   (5) a = GetIndependentVariable() + y + dt(y)
-> (6) a = t + y + y'

   (7) SetIndependentVariable( s )
   (8) b = GetIndependentVariable()^2
-> (9) b = s^2



</PRE><nobr><a name="Input"><font color="darkBlue"><font size=+1><b>Input</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Input

 Purpose:  Assigns/reports numerical values (with optional units) to constants,
           initial values, and numerical integration parameters for use by the
           ODE, Solve, EvaluateAtInput, and EvaluateToNumber commands.

Syntax 1:  Input a = v1 unitsA,  b = v2 unitsB,  c = v3,  d = v4 noUnits
Syntax 2:  Input
Syntax 3:  Input( a )                 or  Input( a + 2*b + 3*c )
Syntax 4:  Input( a,  NoUnitSystem )  or  Input( a + 2*b + 3*c,  NoUnitSystem )
Syntax 5:  Input( a, GetUnitSystem )  or  Input( a + 2*b + 3*c, GetUnitSystem )
Syntax 6:  ClearInput( a, b, c )

           a, b, c, d     -- names of scalars or a matrix of names of scalars.
           v1, v2, v3, v4 -- expressions that resolve to a real number.
           unitsA, unitsB -- units associated with a and b.

Output 1:  Assigns input values (possibly with units) to  a, b, c, d.
Output 2:  Lists quantities (values and units) assigned in Input statements.
Output 3:  Returns the input value of  a   (no units conversion).
Output 4:  Returns the input value of  a   (no units conversion).
Output 5:  Returns the input value of  a   multiplied by the conversion factor
           from a's units to the current units in SetUnitSystem.
Output 6:  Clears the input values and units assigned to  a, b, c.

  Remark:  Input values and units can also be assigned by declarations in:
           Constant, SetMass, and SetInertia.

  Remark:  Input values can also be assigned to:  absError,  relError,
           tInitial,  tFinal,  tStep,  printIntScreen,  printIntFile.

  Remark:  Type GetUnitSystem for a list of units

 Related:  <a href="#ODE"><b>ODE</b></a>  <a href="#Solve"><b>Solve</b></a>  <a href="#Input"><b>Input</b></a>  <a href="#Output"><b>Output</b></a>  <a href="#Output"><b>OutputPlot</b></a>  <a href="#Plot"><b>Plot</b></a>  <a href="#Animate"><b>Animate</b></a>
           <a href="#ConvertUnits"><b>ConvertUnits</b></a>  <a href="#GetUnitSystem"><b>GetUnitSystem</b></a>  <a href="#SetUnitSystem"><b>SetUnitSystem</b></a>  <a href="#SetDigits"><b>SetDigits</b></a>
           <a href="#t"><b>t</b></a>  <a href="#absError"><b>tInitial</b></a>  <a href="#absError"><b>tFinal</b></a>  <a href="#absError"><b>tStep</b></a>  <a href="#absError"><b>absError</b></a>  <a href="#absError"><b>printIntScreen</b></a>  <a href="#absError"><b>printIntFile</b></a>
           <a href="#Solve"><b>Solve</b></a>  <a href="#SolveDt"><b>SolveDt</b></a>  <a href="#SolveSetInput"><b>SolveSetInput</b></a>  <a href="#SolveSetInputDt"><b>SolveSetInputDt</b></a>  ...

   (1) %--------------------------------------------------------------------
   (2) % Example 1: Assigning Input   
   (3) %--------------------------------------------------------------------
   (4) SetUnitSystem( kg, m, s )
   (5) Constant  a = 2 m,   b = 3 cm/s,  c
   (6) Variable  y'' = a*y + b*y' + c*sin(y)
-> (7) y'' = a*y + c*sin(y) + b*y'

   (8) Input     y = 4 m,   y' = 0,   c = 5 + Input(a) meters
   (9) %
   (10) %--------------------------------------------------------------------
   (11) % Example 2: Returning Input   
   (12) %--------------------------------------------------------------------
   (13) ac = Input( a + c )
-> (14) ac = 9

   (15) b1 = Input( b,  NoUnitSystem ) 
-> (16) b1 = 3

   (17) b2 = Input( b, GetUnitSystem ) 
-> (18) b2 = 0.03

   (19) %
   (20) %--------------------------------------------------------------------
   (21) % Example 3: Type INPUT to display current input values, e.g.:
   (22) %--------------------------------------------------------------------
   (23) %  INPUT has been assigned as follows:
   (24) %   a                         2                       m
   (25) %   b                         3                       cm/s
   (26) %   c                         7                       meters
   (27) %   y                         4                       m
   (28) %   y'                        0
   (29) %--------------------------------------------------------------------
   (30) % Example 4: ClearInput  
   (31) %--------------------------------------------------------------------
   (32) ClearInput( a, b, y' )


</PRE><nobr><a name="int"><font color="darkBlue"><font size=+1><b>int</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
int

 Purpose:  Returns the integer portion of a real scalar expression.

  Syntax:  int( realScalarExpression )

   Input:  realScalarExpression -- a real scalar expression.

  Output:  Integer portion of realScalarExpression.

 Related:  <a href="#ceil"><b>ceil</b></a>  <a href="#ceil"><b>floor</b></a>  <a href="#int"><b>int</b></a>  <a href="#min"><b>max</b></a>  <a href="#min"><b>min</b></a>  <a href="#round"><b>round</b></a>  <a href="#RoundDigits"><b>RoundDigits</b></a>  <a href="#sign"><b>sign</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: int 
   (3) %--------------------------------------------------------------------
   (4) A = int( 2.991 ) 
-> (5) A = 2

   (6) B = int( 3.001 ) 
-> (7) B = 3

   (8) C = int( -2.991 ) 
-> (9) C = -2

   (10) D = int( -3.001 ) 
-> (11) D = -3

   (12) E = int( 2.9 + t ) 
-> (13) E = int(2.9+t)



</PRE><nobr><a name="Integrate"><font color="darkBlue"><font size=+1><b>Integrate</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Integrate

 Purpose:  Integrates a scalar function or matrix of scalar functions.

  Syntax:  Integrate( scalarOrMatrixExpression,  x = xi : xf )

   Input:  scalarOrMatrixExpression -- a scalar or matrix of scalar
                                       expressions that depend on x.
           x  -- a scalar symbol
           xi -- the integral's lower limit for x
           xf -- the integral's upper limit for x

  Output:  Integral of (scalarOfMatrixExpression * dx) from x=xi to x=xf,
           where dx is the differential of x.

  Remark:  Integrate returns a number or matrix of numbers.
           Integrate may be nested to create double and triple integrals.

  Remark:  Do not use Integrate with time-integrals (x=t) which involve
           implicit-derivatives of time (e.g., the integrand or limits
           involve y and y' exists (or vice-versa).
           Good:     Integrate( t^2,  t=0:3 )
           Bad:      Variable x' = 3;  Input x = 0;  Integrate( x, t=0:3)

  Remark:  Integrate returns a numerical approximation to the integral.
           The accuracy of the solution tends to improve as the input
           value assigned to absError and/or relError gets smaller.
           The default value of absError (e.g., absError = 1.0E-7)
           can be changed via the Input command, e.g.,
           Input  absError = 1.0E-7

 Related:  <a href="#D"><b>D</b></a>  <a href="#Dt"><b>Dt</b></a>  <a href="#Dt"><b>DtDt</b></a>  <a href="#Integrate"><b>Integrate</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>  <a href="#absError"><b>absError</b></a>  <a href="#absError"><b>relError</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  Integrate( scalarExpression,  x=xi:xf )
   (3) %--------------------------------------------------------------------
   (4) Input absError = 1.0E-9
   (5) Variable  x
   (6) integral1 = Integrate( 2*x,  x=0:3 )
-> (7) integral1 = 9

   (8) %--------------------------------------------------------------------
   (9) % Example 2:  Integrate( matrixExpression,  x=xi:xf )
   (10) %--------------------------------------------------------------------
   (11) matrix = [x^2;  3*sqrt(cos(x))*exp(2*x)]
-> (12) matrix = [x^2;  3*sqrt(cos(x))*exp(2*x)]

   (13) integral2 = Integrate( matrix,  x = -pi/2 : pi/2 )
-> (14) integral2 = [2.583856;  20.08743]

   (15) %--------------------------------------------------------------------
   (16) % Example 3:  Integrate( Integrate( ... ) )
   (17) %--------------------------------------------------------------------
   (18) Variable  y
   (19) integral3 = Integrate( exp(y) * Integrate( cos(x),  x=1:3 ),  y=0:2 )
-> (20) integral3 = -4.474582

   (21) %--------------------------------------------------------------------
   (22) % Example 4:  Integrate( Integrate( ... ) )
   (23) %--------------------------------------------------------------------
   (24) integral4 = Integrate( Integrate( x*y,  x=0:y ),  y=2:0 )
-> (25) integral4 = -2

   (26) integral5 = Integrate( Integrate( cos(x*y)*exp(y),  x=0:y ),  y=0:2 )
-> (27) integral5 = 2.291264



</PRE><nobr><a name="Interface"><font color="darkBlue"><font size=+1><b>Interface</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Interface with the Operating System:
 Issue a system command:             !
 Clear the workspace:                CLEAR
 Print a message on the screen:      ECHO
 List or change defaults:            GetDefaults
 Display the amount of memory used:  GetMemory
 Learn about the help system:        HELP
 List the input and responses:       LIST
 Pause the program:                  Pause
 Run/load a specific input file:     RUN
 Quit/exit the program:              QUIT
 Save input and responses:           SAVE



</PRE><nobr><a name="IsPositive"><font color="darkBlue"><font size=+1><b>IsPositive</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
IsNegative  IsNegativeOr0  IsPositiveOr0  IsPositive    (subject to change).

 Purpose:  Return a value that depends on the sign of a real scalar expression.

Syntax 1:  IsNegative( x )       % Returns  true  if x <  0,  otherwise  false.
Syntax 2:  IsNegativeOr0( x )    % Returns  true  if x <= 0,  otherwise  false.
           IsNonPositive( x )
Syntax 3:  IsPositiveOr0( x )    % Returns  true  if x >- 0,  otherwise  false.
           IsNonNegative( x )
Syntax 4:  IsPositive( x )       % Returns  true  if x >  0,  otherwise  false.

   Input:  x -- a real scalar expression.

  Remark:  The derivative of these functions can be assumed to be 0.

  Remark:  To implement  if t < 0, Fx = sin(t),  else Fx = cos(t), use:
           Fx = IsNegative(t) * sin(t)  +  IsPositiveOr0(t) * cos(t)

  Remark:  IsPositive can be used to implement a logical OR whereas the
           multiplication operator * can mimic a logical AND.
           IsPositive( false + false )   returns false
           IsPositive( false + true  )   returns true
           IsPositive( true  + false )   returns true
           IsPositive( true  + true  )   returns true
                       false * false     returns false
                       false * true      returns false
                       true  * false     returns false
                       true  * true      returns true

 Related:  <a href="#ceil"><b>ceil</b></a>  <a href="#ceil"><b>floor</b></a>  <a href="#int"><b>int</b></a>  <a href="#min"><b>max</b></a>  <a href="#min"><b>min</b></a>  <a href="#round"><b>round</b></a>  <a href="#sign"><b>sign</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>
           <a href="#IsPositive"><b>IsNegative</b></a>  <a href="#IsPositive"><b>IsNegativeOr0</b></a>  <a href="#IsPositive"><b>IsPositiveOr0</b></a>  <a href="#IsPositive"><b>IsPositive</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: IsPositive  and  IsPositiveOr0
   (3) %--------------------------------------------------------------------
   (4) a = IsPositive( 2.3 )
-> (5) a = true

   (6) b = IsPositive( 0 )
-> (7) b = false

   (8) c = IsPositiveOr0( 0 )
-> (9) c = true

   (10) d = IsPositive(  2.3 ) + IsPositiveOr0(  2.3 ) + IsPositive(5+t)
-> (11) d = 2 + IsPositive(5+t)

   (12) e = IsPositive( -2.3 ) + IsPositiveOr0( -2.3 ) + IsPositive(5+t)
-> (13) e = IsPositive(5+t)

   (14) %--------------------------------------------------------------------
   (15) % Example 2: IsNegative  and  IsNegativeOr0
   (16) %--------------------------------------------------------------------
   (17) f = IsNegative( 2.3 )
-> (18) f = false

   (19) g = IsNegative( 0 )
-> (20) g = false

   (21) h = IsNegativeOr0( 0 )
-> (22) h = true

   (23) i = IsNegative(  2.3 ) + IsNegativeOr0(  2.3 ) + IsNegative(5+t)
-> (24) i = IsNegative(5+t)

   (25) j = IsNegative( -2.3 ) + IsNegativeOr0( -2.3 ) + IsNegative(5+t)
-> (26) j = 2 + IsNegative(5+t)

   (27) %--------------------------------------------------------------------
   (28) % Example 3:  if t < 0,  Fx = sin(t),  else Fx = cos(t)
   (29) %--------------------------------------------------------------------
   (30) Fx = IsNegative(t) * sin(t)  +  IsPositiveOr0(t) * cos(t)     
-> (31) Fx = IsNegative(t)*sin(t) + IsPositiveOr0(t)*cos(t)

   (32) %--------------------------------------------------------------------
   (33) % Example 4:  if t <= 5,  Fy = sin(t),  else Fy = cos(t)
   (34) %--------------------------------------------------------------------
   (35) isTLessThanOrEqualTo5 = IsNegativeOr0(-5 + t)
-> (36) isTLessThanOrEqualTo5 = IsNegativeOr0(-5+t)

   (37) isTGreaterThan5 = IsPositive(-5 + t)  
-> (38) isTGreaterThan5 = IsPositive(-5+t)

   (39) Fy = isTLessThanOrEqualTo5 * sin(t)  +  isTGreaterThan5 * cos(t)
-> (40) Fy = sin(t)*isTLessThanOrEqualTo5 + cos(t)*isTGreaterThan5

   (41) %--------------------------------------------------------------------
   (42) % Example 5:  IsPositive used to implement a logical OR 
   (43) %--------------------------------------------------------------------
   (44) orA = IsPositive( false + false )
-> (45) orA = false

   (46) orB = IsPositive( false + true  )
-> (47) orB = true

   (48) orC = IsPositive( true  + false )
-> (49) orC = true

   (50) orD = IsPositive( true  + true  )
-> (51) orD = true

   (52) %--------------------------------------------------------------------
   (53) % Example 6:  IsPositive used as "if" statement for calculations.
   (54) %--------------------------------------------------------------------
   (55) isTLessThanPi = isPositive(pi-t)      % true   if t < pi, otherwise 0 (false).
-> (56) isTLessThanPi = IsPositive(pi-t)

   (57) sintOrZero = sin(t) * isTLessThanPi   % sin(t) if t < pi, otherwise 0 (false).
-> (58) sintOrZero = sin(t)*isTLessThanPi

   (59) Variable y' = sintOrZero
-> (60) y' = sintOrZero

   (61) Input  tFinal = 4,  y = 0             % Arbitrary input values.
   (62) Output  t,  y,  y'                   
   (63) ODE()  simulateWithIfStatement



</PRE><nobr><a name="IsContainSymbol"><font color="darkBlue"><font size=+1><b>IsContainSymbol</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
IsContainSymbol   (semi-experimental command)

 Purpose:  Checks whether an expression contains a certain symbol.

  Syntax:  IsContainSymbol( expression, X )

   Input:  expression -- an expression or matrix of expressions.
           X -- the name of a scalar, unit vector, zero vector, zero dyadic,
           or unit dyadic or  or matrix of these -- e.g., a Variable.

   Output: True or false (or a matrix of true/false) depending on whether
           expression contains X.

 Related:  <a href="#D"><b>D</b></a>  <a href="#Dt"><b>Dt</b></a>  <a href="#Dt"><b>DtDt</b></a>  <a href="#Integrate"><b>Integrate</b></a>  <a href="#GetPartialVelocity"><b>GetPartials</b></a>  <a href="#GetJacobian"><b>GetJacobian</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  IsContainSymbol( scalarExpression, name )
   (3) %--------------------------------------------------------------------
   (4) Variable x, y
   (5) s = 3*x + y^2 
-> (6) s = 3*x + y^2

   (7) sContainXYT = IsContainSymbol( s,  [x, y, t] )
-> (8) sContainXYT = [true, true, false]

   (9) y = exp(t)
-> (10) y = exp(t)

   (11) sContainXYT := IsContainSymbol( s,  [x, y, t] )
-> (12) sContainXYT = [true, true, true]

   (13) %--------------------------------------------------------------------
   (14) % Example 2:  IsContainSymbol( matrixExpression, name )
   (15) %--------------------------------------------------------------------
   (16) matrix = [1, 2*t;  3*x, 4*y^2]
-> (17) matrix = [1, 2*t;  3*x, 4*y^2]

   (18) mContainX = IsContainSymbol( matrix,  x )
-> (19) mContainX = [false, false;  true, false]

   (20) mContainT = IsContainSymbol( matrix,  t )
-> (21) mContainT = [false, true;  false, true]

   (22) %--------------------------------------------------------------------
   (23) % Example 3:  IsContainSymbol( vectorExpression, name )
   (24) %--------------------------------------------------------------------
   (25) RigidFrame A
   (26) v> = x*Ax> + y^2*Ay>
-> (27) v> = x*Ax> + y^2*Ay>

   (28) vContains = IsContainSymbol( v>,   [x, y, t, Ax>, Ay>, Az>] )
-> (29) vContains = [true, true, true, true, true, false]

   (30) d>> = 1>> + x*Ay>*Az>              
-> (31) d>> = 1>> + x*Ay>*Az>

   (32) dContains = IsContainSymbol( d>>,  [x, y, t, Ax>, Ay>, Az>, 0>, 1>>] )
-> (33) dContains = [true, false, false, false, true, true, false, true]



</PRE><nobr><a name="IsSimplifyZero"><font color="darkBlue"><font size=+1><b>IsSimplifyZero</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
IsSimplifyZero     (semi-experimental command)

 Purpose:  Determines whether a mathematical expression simplifies to zero
           (or within a numerical tolerance of zero).

Syntax 1:  IsSimplifyZero( expression )
Syntax 2:  IsSimplifyZero( expression,  absEpsilon )
Syntax 3:  IsSimplifyZero( expression,  absEpsilon, relEpsilon )

   Input:  expression -- a scalar, vector, tensor, or matrix expression.
           absEpsilon -- a real number r with   0  <=  r  < 0.5
           relEpsilon -- a real number r with   0  <=  r  < 0.5

Output 1:  true if expression simplifies to zero, otherwise false.
Output 2:  true if expression simplifies to zero after calling
           Epsilon( expression,  absEpsilon ).
Output 3:  true if expression simplifies to zero after calling
           Epsilon( expression,  absEpsilon, relEpsilon ).

  Remark:  Output is false if current simplification algorithms cannot simplify
           to zero (future simplification algorithms may change result).
           If output seems to improperly resolve to false, try:
           IsSimplifyZero( Expand(expression, 0:2) ).
  Remark:  To debug IsSimplifyZero, view the output produced by:
                    Expand(expression, 0:2)   and/or
           Epsilon( Expand(expression, 0:2),  absEpsilon, relEpsilon ).
  Remark:  The Epsilon command describes absEpsilon and relEpsilon.

 Related:  <a href="#IsSimplifyEqual"><b>IsSimplifyEqual</b></a>  <a href="#IsSimplifyZero"><b>IsSimplifyZero</b></a>  <a href="#IsSimplifyTrue"><b>IsSimplifyTrue</b></a>  <a href="#Strcmp"><b>Strcmp</b></a>  <a href="#Strcmp"><b>Strcmpi</b></a>
           <a href="#IsPositive"><b>IsNegative</b></a>  <a href="#IsPositive"><b>IsNegativeOr0</b></a>  <a href="#IsPositive"><b>IsPositiveOr0</b></a>  <a href="#IsPositive"><b>IsPositive</b></a>
           <a href="#Epsilon"><b>Epsilon</b></a>  <a href="#RoundDigits"><b>RoundDigits</b></a>  <a href="#Expand"><b>Expand</b></a>  <a href="#Explicit"><b>Explicit</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  IsSimplifyZero( scalarExpression )
   (3) %--------------------------------------------------------------------
   (4) isZeroA = IsSimplifyZero( 2 - 2 )
-> (5) isZeroA = true

   (6) isZeroB = IsSimplifyZero( 2 + 2 )
-> (7) isZeroB = false

   (8) isZeroC = IsSimplifyZero( 0.001,  0.002 )
-> (9) isZeroC = true

   (10) isZeroD = IsSimplifyZero( 0.003,  0.002 )
-> (11) isZeroD = false

   (12) isZeroE = IsSimplifyZero( sin(1.01*t) - sin(t),     0.02 )
-> (13) isZeroE = true

   (14) isZeroF = IsSimplifyZero( sin(1.03*t) - sin(t),     0.02 )
-> (15) isZeroF = false

   (16) isZeroG = IsSimplifyZero( sin(10.1*t) - sin(10*t),  0, 0.02 )
-> (17) isZeroG = true

   (18) isZeroH = IsSimplifyZero( sin(10.3*t) - sin(10*t),  0, 0.02 )
-> (19) isZeroH = false

   (20) isZeroI = IsSimplifyZero( t^7.33 - t^7.34,  0.02 )
-> (21) isZeroI = true

   (22) isZeroJ = IsSimplifyZero( t^7.33 - t^7.36,  0.02 )
-> (23) isZeroJ = false

   (24) isZeroK = IsSimplifyZero( t^10.1 - t^10,    0, 0.02 )
-> (25) isZeroK = true

   (26) isZeroL = IsSimplifyZero( t^10.3 - t^10,    0, 0.02 )
-> (27) isZeroL = false

   (28) isZeroM = IsSimplifyZero( t^10.3 - t^10.4,   0, 0.02 ) 
-> (29) isZeroM = false

   (30) isZeroN = IsSimplifyZero( t^10.3 - t^10.4,   0.02, 0 ) 
-> (31) isZeroN = false

   (32) %--------------------------------------------------------------------
   (33) % Example 2:  IsSimplifyZero( vectorExpression ) 
   (34) %--------------------------------------------------------------------
   (35) RigidBody  B
   (36) isZeroO = IsSimplifyZero( Bx> - Bx> )
-> (37) isZeroO = true

   (38) isZeroP = IsSimplifyZero( Bx> - By> )
-> (39) isZeroP = false

   (40) isZeroQ = IsSimplifyZero( Bx> - 1.01*Bx>,  0.02 )
-> (41) isZeroQ = true

   (42) isZeroR = IsSimplifyZero( Bx> - 0.03*Bx>,  0.02 )
-> (43) isZeroR = false

   (44) %--------------------------------------------------------------------
   (45) % Example 3:  IsSimplifyZero( matrixExpression ) 
   (46) %--------------------------------------------------------------------
   (47) isZeroS = IsSimplifyZero( [ 2-2,  Bx> - Bx>;  Bx>*By> - Bx>*By>,  0] )
-> (48) isZeroS = true



</PRE><nobr><a name="IsSimplifyTrue"><font color="darkBlue"><font size=+1><b>IsSimplifyTrue</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
IsSimplifyTrue     (semi-experimental command)

 Purpose:  Determines whether a mathematical expression simplifies to true
           (or within a numerical tolerance of zero).

Syntax 1:  IsSimplifyTrue( expression )
Syntax 2:  IsSimplifyTrue( expression,  absEpsilon )
Syntax 3:  IsSimplifyTrue( expression,  absEpsilon, relEpsilon )

   Input:  expression -- a scalar, vector, tensor, or matrix expression.
           absEpsilon -- a real number r with   0  <=  r  < 0.5
           relEpsilon -- a real number r with   0  <=  r  < 0.5

Output 1:  true if expression simplifies to true, otherwise false.
Output 2:  true if expression simplifies to true after calling
           Epsilon( expression,  absEpsilon ).
Output 3:  true if expression simplifies to zero after calling
           Epsilon( expression,  absEpsilon, relEpsilon ).

  Remark:  Output is false if current simplification algorithms cannot simplify
           to true (future simplification algorithms may change result).
  Remark:  The Epsilon command describes absEpsilon and relEpsilon.

 Related:  <a href="#IsSimplifyEqual"><b>IsSimplifyEqual</b></a>  <a href="#IsSimplifyZero"><b>IsSimplifyZero</b></a>  <a href="#IsSimplifyTrue"><b>IsSimplifyTrue</b></a>  <a href="#Strcmp"><b>Strcmp</b></a>  <a href="#Strcmp"><b>Strcmpi</b></a>
           <a href="#IsPositive"><b>IsNegative</b></a>  <a href="#IsPositive"><b>IsNegativeOr0</b></a>  <a href="#IsPositive"><b>IsPositiveOr0</b></a>  <a href="#IsPositive"><b>IsPositive</b></a>
           <a href="#Epsilon"><b>Epsilon</b></a>  <a href="#RoundDigits"><b>RoundDigits</b></a>  <a href="#Expand"><b>Expand</b></a>  <a href="#Explicit"><b>Explicit</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  IsSimplifyTrue( scalarExpression )
   (3) %--------------------------------------------------------------------
   (4) trueOrFalse = IsSimplifyEqual( sin(t)/cos(t), tan(t) )
-> (5) trueOrFalse = true

   (6) isTrueA = IsSimplifyTrue( trueOrFalse )
-> (7) isTrueA = true

   (8) %--------------------------------------------------------------------
   (9) % Example 2:  IsSimplifyZero( matrixExpression ) 
   (10) %--------------------------------------------------------------------
   (11) trueFalse[1] = IsSimplifyEqual( 9, 9 )
-> (12) trueFalse[1] = true

   (13) trueFalse[2] = IsSimplifyEqual( 1, sin(t)^2 + cos(t)^2 )
-> (14) trueFalse[2] = true

   (15) trueFalse[3] = IsSimplifyEqual( t^3/t, t^2 )
-> (16) trueFalse[3] = true

   (17) isTrueB = IsSimplifyTrue( trueFalse )
-> (18) isTrueB = true



</PRE><nobr><a name="IsSimplifyEqual"><font color="darkBlue"><font size=+1><b>IsSimplifyEqual</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
IsSimplifyEqual    (semi-experimental command)

 Purpose:  Determines whether two expressions simplify to the same result
           (or are within a numerical tolerance of the same result).

Syntax 1:  IsSimplifyEqual( mathA, mathB )
Syntax 2:  IsSimplfiyEqual( mathA, mathB,  absEpsilon )
Syntax 3:  IsSimplifyEqual( mathA, mathB,  absEpsilon, relEpsilon )

   Input:  mathA -- a scalar, vector, tensor, or matrix expression.
           mathB -- a scalar, vector, tensor, or matrix expression.
           absEpsilon -- a real number r with   0  <=  r  < 0.5
           relEpsilon -- a real number r with   0  <=  r  < 0.5

Output 1:  true if mathA == mathB  (with current simplification algorithms).
Output 2:  true if mathA == mathB  with given absEpsilon and relEpsilon = 0.
Output 3:  true if mathA == mathB  with given absEpsilon and relEpsilon.

  Remark:  IsSimplifyEqual( x, y ) is similar to IsSimplifyZero( x - y ).
           Read the help for IsSimplifyZero for useful debugging tips.

 Related:  <a href="#IsSimplifyEqual"><b>IsSimplifyEqual</b></a>  <a href="#IsSimplifyZero"><b>IsSimplifyZero</b></a>  <a href="#IsSimplifyTrue"><b>IsSimplifyTrue</b></a>  <a href="#Strcmp"><b>Strcmp</b></a>  <a href="#Strcmp"><b>Strcmpi</b></a>
           <a href="#IsPositive"><b>IsNegative</b></a>  <a href="#IsPositive"><b>IsNegativeOr0</b></a>  <a href="#IsPositive"><b>IsPositiveOr0</b></a>  <a href="#IsPositive"><b>IsPositive</b></a>
           <a href="#Epsilon"><b>Epsilon</b></a>  <a href="#RoundDigits"><b>RoundDigits</b></a>  <a href="#Expand"><b>Expand</b></a>  <a href="#Explicit"><b>Explicit</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  IsSimplifyEqual( scalarA, scalarB )
   (3) %--------------------------------------------------------------------
   (4) isEqualA = IsSimplifyEqual( 5,  5 )
-> (5) isEqualA = true

   (6) isEqualB = IsSimplifyEqual( 5, -5 )
-> (7) isEqualB = false

   (8) isEqualC = IsSimplifyEqual( 5, 5.01,  0.02 )
-> (9) isEqualC = true

   (10) isEqualD = IsSimplifyEqual( 5, 5.03,  0.02 )
-> (11) isEqualD = false

   (12) isEqualE = IsSimplifyEqual( sin(1.01*t), sin(t),     0.02 )
-> (13) isEqualE = true

   (14) isEqualF = IsSimplifyEqual( sin(1.03*t), sin(t),     0.02 )
-> (15) isEqualF = false

   (16) isEqualG = IsSimplifyEqual( sin(10.1*t), sin(10*t),  0, 0.02 )
-> (17) isEqualG = true

   (18) isEqualH = IsSimplifyEqual( sin(10.3*t), sin(10*t),  0, 0.02 )
-> (19) isEqualH = false

   (20) isEqualI = IsSimplifyEqual( t^7.33,  t^7.34,  0.02 )
-> (21) isEqualI = true

   (22) isEqualJ = IsSimplifyEqual( t^7.33,  t^7.36,  0.02 )
-> (23) isEqualJ = false

   (24) isEqualK = IsSimplifyEqual( t^10.1,  t^10,    0, 0.02 )
-> (25) isEqualK = true

   (26) isEqualL = IsSimplifyEqual( t^10.3,  t^10,    0, 0.02 )
-> (27) isEqualL = false

   (28) isEqualM = IsSimplifyEqual( t^10.3,  t^10.4,  0, 0.02 ) 
-> (29) isEqualM = false

   (30) isEqualN = IsSimplifyEqual( t^10.3,  t^10.4,  0.02, 0 ) 
-> (31) isEqualN = false

   (32) %--------------------------------------------------------------------
   (33) % Example 2:  IsSimplifyEqual( vectorA, vectorB ) 
   (34) %--------------------------------------------------------------------
   (35) RigidBody  B
   (36) isEqualO = IsSimplifyEqual( Bx>,  Bx> )
-> (37) isEqualO = true

   (38) isEqualP = IsSimplifyEqual( Bx>,  By> )
-> (39) isEqualP = false

   (40) isEqualQ = IsSimplifyEqual( Bx>,  8   )
-> (41) isEqualQ = false

   (42) isEqualR = IsSimplifyEqual( Bx>,  By>*Bz> )
-> (43) isEqualR = false

   (44) isEqualS = IsSimplifyEqual( Bx>,  1.01*Bx>,  0.02 )
-> (45) isEqualS = true

   (46) isEqualT = IsSimplifyEqual( Bx>,  0.03*Bx>,  0.02 )
-> (47) isEqualT = false

   (48) %--------------------------------------------------------------------
   (49) % Example 3:  IsSimplifyEqual( matrixA, matrixB ) 
   (50) %--------------------------------------------------------------------
   (51) isEqualU = IsSimplifyEqual( [2, Bx>,  Bx>*By>],  [2, Bx>, Bx>*By>] )
-> (52) isEqualU = true



</PRE><nobr><a name="Strcmp"><font color="darkBlue"><font size=+1><b>Strcmp</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Strcmp  Strcmpi

 Purpose:  Compares two strings and returns:
           -1  if stringA  <  stringB
            0  if stringA  =  stringB  (strings are regarded as equal)
            1  if stringA  >  stringB

Syntax 1:  Strcmp(  stringA, stringB )
Syntax 2:  Strcmpi( stringA, stringB )

   Input:  stringA -- a string which may be enclosed within quotes.
           stringB -- a string which may be enclosed within quotes.

Output 1:  -1, 0, or 1 from case sensitive comparison of stringA and stringB.
Output 2:  -1, 0, or 1 from case insensitive comparison of stringA and stringB.

  Remark:  Strcmp  is a case   sensitive string comparison.
           Strcmpi is a case insensitive string comparison.
           A string within quotes differs from a string without quotes.
           For example, "abc" is not the same as abc.

 Related:  <a href="#IsSimplifyEqual"><b>IsSimplifyEqual</b></a>  <a href="#IsSimplifyZero"><b>IsSimplifyZero</b></a>  <a href="#IsSimplifyTrue"><b>IsSimplifyTrue</b></a>  <a href="#Strcmp"><b>Strcmp</b></a>  <a href="#Strcmp"><b>Strcmpi</b></a>
           <a href="#IsPositive"><b>IsNegative</b></a>  <a href="#IsPositive"><b>IsNegativeOr0</b></a>  <a href="#IsPositive"><b>IsPositiveOr0</b></a>  <a href="#IsPositive"><b>IsPositive</b></a>
           <a href="#Epsilon"><b>Epsilon</b></a>  <a href="#RoundDigits"><b>RoundDigits</b></a>  <a href="#Expand"><b>Expand</b></a>  <a href="#Explicit"><b>Explicit</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  Strcmp
   (3) %--------------------------------------------------------------------
   (4) intA = Strcmp( "abc", "abc" )    % Identical.
-> (5) intA = 0

   (6) intB = Strcmp( "abc", "def" )    % Different letters.
-> (7) intB = -1

   (8) intC = Strcmp( "abc", "ABC" )    % Different (lower/upper) case.
-> (9) intC = 1

   (10) intD = Strcmp( "abc", "abc ")    % Extra space at end.
-> (11) intD = 1

   (12) intE = Strcmp( "abc",  abc  )    % Missing quotes "".
-> (13) intE = -1

   (14) %--------------------------------------------------------------------
   (15) % Example 2:  Strcmpi
   (16) %--------------------------------------------------------------------
   (17) intF = Strcmpi( "abc", "abc" )   % Identical.                   
-> (18) intF = 0

   (19) intG = Strcmpi( "abc", "def" )   % Different letters.           
-> (20) intG = -1

   (21) intH = Strcmpi( "abc", "ABC" )   % Different (lower/upper) case.
-> (22) intH = 0

   (23) intI = Strcmpi( "abc", "abc ")   % Extra space at end.          
-> (24) intI = 1

   (25) intJ = Strcmpi( "abc",  abc  )   % Missing quotes "".           
-> (26) intJ = -1

   (27) %--------------------------------------------------------------------


</PRE><nobr><a name="Kane"><font color="darkBlue"><font size=+1><b>Kane</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetStaticsKane  GetDynamicsKane

 Purpose:  Gets Kane's equations for statics or dynamics .

Syntax 1:  System.GetStaticsKane()
Syntax 2:  System.GetDynamicsKane()

Output 1:  Kane's statics  equations for the System.
Output 2:  Kane's dynamics equations for the System.

  Remark:  For Newton/Euler equations, type  Help Statics or Help Dynamics
           For Kane's       equations, type  Help Kane
           For Lagrange's   equations, type  Help Lagrange

 Related:  <a href="#AddForce"><b>AddForce</b></a>  <a href="#AddTorque"><b>AddTorque</b></a>  <a href="#SetMass"><b>SetMass</b></a>  <a href="#SetInertia"><b>SetInertia</b></a>  <a href="#Rotate"><b>Rotate</b></a>  <a href="#Translate"><b>Translate</b></a>
           <a href="#NewtonianFrame"><b>NewtonianFrame</b></a>  <a href="#Point"><b>Point</b></a>  <a href="#Particle"><b>Particle</b></a>  <a href="#RigidFrame"><b>RigidFrame</b></a>  <a href="#RigidBody"><b>RigidBody</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>
           <a href="#Constrain"><b>Constrain</b></a>  <a href="#SetGeneralizedSpeed"><b>SetGeneralizedCoordinate</b></a>  <a href="#SetGeneralizedSpeed"><b>SetGeneralizedSpeed</b></a>


</PRE><nobr><a name="Lagrange"><font color="darkBlue"><font size=+1><b>Lagrange</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetStaticsLagrange  GetDynamicsLagrange

 Purpose:  Gets Lagrange's equations for statics or dynamics.

Syntax 1:  System.GetStaticsLagrange(  SystemPotential = sysPotential )
           System.GetDynamicsLagrange( SystemPotential = sysPotential )
---------------------------------------------------------------------------
Syntax 2*: System.GetStaticsLagrange(     AddPotential = addPotential ) **
           System.GetDynamicsLagrange(    AddPotential = addPotential ) **
Syntax 3*: System.GetStaticsLagrange()  ** RESERVED SYNTAX, IN DEVELOPMENT.
           System.GetDynamicsLagrange() ** RESERVED SYNTAX, IN DEVELOPMENT.
---------------------------------------------------------------------------

   Input:  sysPotential -- system potential energy (all generalized forces).
           addPotential -- potential energy for forces not in the workspace.

Output 1:  Lagrange's statics or dynamics equations for the entire System.
           All generalized forces have a corresponding potential function.
Output 3:  Lagrange's statics or dynamics equations for the entire System.
           Generalized forces are formed via partial derivatives.

  Remark:  For Newton/Euler equations, type  Help Statics or Help Dynamics
           For Kane's       equations, type  Help Kane
           For Lagrange's   equations, type  Help Lagrange

 Related:  <a href="#AddForce"><b>AddForce</b></a>  <a href="#AddTorque"><b>AddTorque</b></a>  <a href="#SetMass"><b>SetMass</b></a>  <a href="#SetInertia"><b>SetInertia</b></a>  <a href="#Rotate"><b>Rotate</b></a>  <a href="#Translate"><b>Translate</b></a>
           <a href="#NewtonianFrame"><b>NewtonianFrame</b></a>  <a href="#Point"><b>Point</b></a>  <a href="#Particle"><b>Particle</b></a>  <a href="#RigidFrame"><b>RigidFrame</b></a>  <a href="#RigidBody"><b>RigidBody</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>
           <a href="#SetGeneralizedSpeed"><b>SetGeneralizedCoordinate</b></a>  <a href="#SetGeneralizedSpeed"><b>SetGeneralizedSpeed</b></a>


</PRE><nobr><a name="Newton"><font color="darkBlue"><font size=+1><b>Newton</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetStatics  GetDynamics

 Purpose:  Gets Newton/Euler statics or dynamics equations of motion.

Syntax 1:  Object.GetStatics()
Syntax 2:  Object.GetDynamics()

   Input:  Object -- Point, Particle, RigidBody, RigidFrame, or System.

Output 1:  Newton/Euler statics  equations for Object.
Output 2:  Newton/Euler dynamics equations for Object.

  Remark:  For Newton/Euler equations, type  Help Statics or Help Dynamics
           For Kane's       equations, type  Help Kane
           For Lagrange's   equations, type  Help Lagrange

 Related:  <a href="#AddForce"><b>AddForce</b></a>  <a href="#AddTorque"><b>AddTorque</b></a>  <a href="#SetMass"><b>SetMass</b></a>  <a href="#SetInertia"><b>SetInertia</b></a>  <a href="#Rotate"><b>Rotate</b></a>  <a href="#Translate"><b>Translate</b></a>
           <a href="#NewtonianFrame"><b>NewtonianFrame</b></a>  <a href="#Point"><b>Point</b></a>  <a href="#Particle"><b>Particle</b></a>  <a href="#RigidFrame"><b>RigidFrame</b></a>  <a href="#RigidBody"><b>RigidBody</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>
           <a href="#SetGeneralizedSpeed"><b>SetGeneralizedCoordinate</b></a>  <a href="#SetGeneralizedSpeed"><b>SetGeneralizedSpeed</b></a>


</PRE><nobr><a name="License"><font color="darkBlue"><font size=+1><b>License</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
License  LicenseNetwork  LicenseAgreement

Syntax 1:  License
           Displays information about the program's license on your computer.
           Asks if you would like to generate a license.

Syntax 2:  LicenseNetwork  or  LicenseServer
           Displays information about the program's license on your computer.
           Asks if you would like to generate a license for a network/server.

Syntax 3:  LicenseAgreement
           Displays the program's license agreement.

Remark:    End-user and/or computer/IT administrators are responsible for all
           computer security.  We recommend the software be installed on a
           computer/account with restricted privileges as all users who access
           the software may have privileges at least equal to the account under
           which the software is installed.  All users who access the software
           must have read/write privileges for the file MGLicense.txt.

Optional:  Instructions relevant only for a server/network license (rare).
           All users who access the software must have read/write privileges
           for the file MGLicense.txt.  If you have a server/network version,
           you need to change read/write permissions for MGLicense.txt.
           For example, from a MacOSX terminal, cd to the MotionGenesis folder
           and type the Unix command:  chmod a+x MGLicense.txt
           For PC/Windows, do something like the following:
        1. Navigate to C:\MotionGenesis (the folder containing MGLicense.txt).
        2. Right-click on MGLicense.txt and select "Properties".
        3. Click on the "Security" tab.
        4. Click on "Users" from the "Group or user names" section
           (if needed, press the "Edit" button to open "Edit Permissions").
        5. Check the "Allow" checkbox under the "Full Control" option to
           enable all users read/write access to the file MGLicense.txt.
        6. Press "OK" to save the changes.


</PRE><nobr><a name="List"><font color="darkBlue"><font size=+1><b>List</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
List

 Purpose:  Displays workspace contents on the screen.

Syntax 1:  List
Syntax 2:  List( startLineNumber )
Syntax 3:  List( startLineNumber:stopLineNumber )

   Input:  startLineNumber -- the first line number to be displayed.
           stopLineNumber  -- the  last line number to be displayed.

Output 1:  Displays all lines in the workspace.
Output 2:  Displays startLineNumber and all subsequent lines in the workspace.
Output 2:  Displays startLineNumber to stopLineNumber.

 Related:  <a href="#!"><b>!</b></a>  <a href="#%"><b>%</b></a>  <a href="#&"><b>&</b></a>  <a href="#Clear"><b>Clear</b></a>  <a href="#List"><b>List</b></a>  <a href="#Pause"><b>Pause</b></a>  <a href="#Quit"><b>Quit</b></a>  <a href="#Run"><b>Run</b></a>  <a href="#Save"><b>Save</b></a>  <a href="#GetDefaults"><b>GetDefaults</b></a>

--------------------------------------------------------------------
 Example:  List
--------------------------------------------------------------------
   (1) a = 2
-> (2) a = 2

   (3) b = 3
-> (4) b = 3

   (5) list 1:2

   (1) a = 2
-> (2) a = 2



</PRE><nobr><a name="log"><font color="darkBlue"><font size=+1><b>log</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
log or log10

 Purpose:  Returns the natural (base e) logarithm of a scalar expression.
           Returns the base 10 logarithm of a scalar expression.

 Syntax 1: log( scalarExpression )
 Syntax 2: log10( scalarExpression )

   Input:  scalarExpression -- a real or complex scalar expression.

Output 1:  Base e (2.71828...) logarithm of scalarExpression.
Output 2:  Base 10 logarithm of scalarExpression.

  Remark:  Use  log(r)/log(b)  to calculate the logarithm of the real
           positive number r to the real positive base b.

 Related:  <a href="#ImaginaryNumber"><b>ImaginaryNumber</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: log and log10   (real scalar expressions)
   (3) %--------------------------------------------------------------------
   (4) Ae = log( 2 ) 
-> (5) Ae = 0.6931472

   (6) Be = log(2*t)
-> (7) Be = 0.6931472 + log(t)

   (8) A10 = log10( 2 ) 
-> (9) A10 = 0.30103

   (10) B10 = log10(2*t)
-> (11) B10 = 0.30103 + log10(t)

   (12) C = log(1+2*t) + log10(1+2*t)
-> (13) C = log(1+2*t) + log10(1+2*t)

   (14) %--------------------------------------------------------------------
   (15) % Example 2: log and log10   (complex scalar expressions)
   (16) %--------------------------------------------------------------------
   (17) Ye = log( 2 + 3*GetImaginaryNumber() )
-> (18) Ye = 1.282475 + 0.9827937*imaginary

   (19) Y10 = log10( 2 + 3*GetImaginaryNumber() )
-> (20) Y10 = 0.5569717 + 0.4268219*imaginary

   (21) Z = log( 3*GetImaginaryNumber() + t ) + log10( 3*GetImaginaryNumber() + t )
-> (22) Z = log(3*imaginary+t) + log10(3*imaginary+t)



</PRE><nobr><a name="MathFunctions"><font color="darkBlue"><font size=+1><b>MathFunctions</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
MathFunctions

 Absolute value:           abs
 Exponential,logarithmic:  exp, log, log10
 factorial:                factorial
 Hyperbolic:               cosh, sinh, tanh
 Integer functions:        ceil, floor, int, round, sign, RandomInteger
 Inverse trigonometric:    acos, asin, atan, atan2, acosDegrees, ...
 Maximum, minimum:         max, min
 Square, square-root:      squared, sqrt
 Trigonometric:            cos, sin, tan, cosDegrees, sinDegrees, ...
 Related:                  <a href="#ImaginaryNumber"><b>ImaginaryNumber</b></a>

Type HELP NAME for help with NAME; e.g., HELP abs



</PRE><nobr><a name="Matrix"><font color="darkBlue"><font size=+1><b>Matrix</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Matrix

 Purpose:  Constructs a matrix from a vector, dyadic, ...

Syntax 1:  Matrix( A,  vector>    )  or  Vector( A,  vector>  )
Syntax 2:  Matrix( A,  dyadic>>   )  or  Dyadic( A,  dyadic>> )
Syntax 3:  Matrix( A,  triadic>>> )
Syntax 4:  Matrix( A,  [ v1>, ...  vn> ]  )

   Input:  A -- the name of a RigidFrame or RigidBody
           vector>    -- a vector  expression
           dyadic>>   -- a dyadic  expression
           triadic>>> -- a triadic expression
           [v1> ...  vn>] -- one dimensional (row or column) matrix of vectors

Output 1:  3 x 1 matrix whose elements are the Ax>, Ay>, Az>
           measures of vector>.

Output 2:  3 x 3 matrix whose elements are the Ai>*Aj> (i,j = x,y,z)
           measures of dyadic>>.

Output 3:  27 x 1 matrix whose elements are the Ai>*Aj>*Ak> (i,j,k = x,y,z)
           measures of triadic>>>.

Output 4:  n x 3  or  3 x n  matrix whose elements are the Ax>, Ay>, Az>
           measures of v1> ... vn>

  Remark:  To select one element of the matrix m, use e.g., m[ 2, 3 ].
           For a submatrix, use m[ 2:3, 1:5 ].  See HELP [].

 Related:  <a href="#Express"><b>Express</b></a>        <a href="#Vector"><b>Vector</b></a>          <a href="#Dyadic"><b>Dyadic</b></a>             <a href="#Matrix"><b>Matrix</b></a>  <a href="#SkewMatrix"><b>SkewMatrix</b></a>
           <a href="#GetColumns"><b>GetColumns</b></a>     <a href="#GetDeterminant"><b>GetDeterminant</b></a>  <a href="#GetDiagonalMatrix"><b>GetDiagonalMatrix</b></a>  <a href="#GetEigen"><b>GetEigen</b></a>
           <a href="#GetElement"><b>GetElement</b></a> <a href="#[]"><b>[]</b></a>  <a href="#GetInverse"><b>GetInverse</b></a>      <a href="#GetIdentityMatrix"><b>GetIdentityMatrix</b></a>  <a href="#GetNorm"><b>GetNorm</b></a>  <a href="#GetColumns"><b>GetRows</b></a>
           <a href="#GetTrace"><b>GetTrace</b></a>       <a href="#GetTranspose"><b>GetTranspose</b></a>    <a href="#GetIdentityMatrix"><b>GetZeroMatrix</b></a>      <a href="#Solve"><b>Solve</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: Matrix  (with vector argument)
   (3) %--------------------------------------------------------------------
   (4) RigidFrame A, B
   (5) Constant   x, y, z
   (6) B.SetRotationMatrixZ( A, t ) 
-> (7) B_A = [cos(t), sin(t), 0;  -sin(t), cos(t), 0;  0, 0, 1]

   (8) xyzA> = x*Ax> + y*Ay> + z*Az> 
-> (9) xyzA> = x*Ax> + y*Ay> + z*Az>

   (10) M1 = Matrix( A,  xyzA> )
-> (11) M1 = [x;  y;  z]

   (12) M2 = Matrix( B,  xyzA> )
-> (13) M2 = [x*cos(t) + y*sin(t);  y*cos(t) - x*sin(t);  z]

   (14) %--------------------------------------------------------------------
   (15) % Example: Matrix  (with dyadic argument)
   (16) %--------------------------------------------------------------------
   (17) M3 = Matrix( A,  x^2*Ax>*Ax> + y^2*Ay>*Ay> + x*y*Ax>*Ay> + x*y*Ay>*Ax> + z^2*Az>*Az> )
-> (18) M3 = [x^2, x*y, 0;  x*y, y^2, 0;  0, 0, z^2]

   (19) %--------------------------------------------------------------------
   (20) % Example: Matrix  (with dyadic in mixed bases)
   (21) %--------------------------------------------------------------------
   (22) M4 = Matrix( B,  Ax>*Bz> + 2*Ay>*Bz> + 3*Az>*Bx> + 4*Bz>*Bz> )
-> (23) M4 = [0, 0, cos(t) + 2*sin(t);  0, 0, 2*cos(t) - sin(t);  3, 0, 4]

   (24) %--------------------------------------------------------------------
   (25) % Example: Matrix  (1x2 row matrix of vectors produces 3x2 result)
   (26) %--------------------------------------------------------------------
   (27) M5 = Matrix( A,  [xyzA>,  7*Bx>] )
-> (28) M5 = [x, 7*cos(t);  y, 7*sin(t);  z, 0]

   (29) %--------------------------------------------------------------------
   (30) % Example: Matrix  (4x1 column matrix of vectors produces 4x3 result)
   (31) %--------------------------------------------------------------------
   (32) M6 = Matrix( A,  [xyzA>;  7*Bx>;  8*Ay>;  9*Az>] )
-> (33) M6 = [x, y, z;  7*cos(t), 7*sin(t), 0;  0, 8, 0;  0, 0, 9]



</PRE><nobr><a name="SkewMatrix"><font color="darkBlue"><font size=+1><b>SkewMatrix</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SkewMatrix

 Purpose:  Constructs a skew-symmetric matrix from a vector.

Syntax 1:  SkewMatrix( A, vector> )
Syntax 2:  SkewMatrix( vector> )

   Input:  A -- the name of a RigidFrame or RigidBody.
           vector> -- a vector expression.

Output 1:  3 x 3 skew-symmetric matrix whose off-diagonal elements are the
           Ax>, Ay>, Az> measures of vector>.  For example, if
           vector> = vx*Ax> + vy*Ay> + vz*Az>,  the output is
           [ 0,  -vz,   vy;
            vz,    0,  -vx;
           -vy,   vx,    0]

Output 2:  Same as Output 1 when vector> is expressed in terms of only unit
           vectors expressed in terms of the same RigidFrame or RigidBody A.

  Remark:  The output skew-symmetric matrix helps represent cross products
           through matrix multiplication and matrices.  For example,
           SkewMatrix( A, v1> ) * Matrix( A, v2> ) is a 3 x 1 column matrix
           representation of Cross( v1>, v2> ) expressed with Ax>, Ay>, Az>.

  Remark:  In general, a skew-symmetric matrix M is a square matrix with the
           property  Transpose(M) = -M.  Matrix M has zeros along its diagonal.
           The off-diagonal elements of M have the property Mji = -Mij.

 Related:  <a href="#Express"><b>Express</b></a>        <a href="#Vector"><b>Vector</b></a>          <a href="#Dyadic"><b>Dyadic</b></a>             <a href="#Matrix"><b>Matrix</b></a>  <a href="#SkewMatrix"><b>SkewMatrix</b></a>
           <a href="#GetColumns"><b>GetColumns</b></a>     <a href="#GetDeterminant"><b>GetDeterminant</b></a>  <a href="#GetDiagonalMatrix"><b>GetDiagonalMatrix</b></a>  <a href="#GetEigen"><b>GetEigen</b></a>
           <a href="#GetElement"><b>GetElement</b></a> <a href="#[]"><b>[]</b></a>  <a href="#GetInverse"><b>GetInverse</b></a>      <a href="#GetIdentityMatrix"><b>GetIdentityMatrix</b></a>  <a href="#GetNorm"><b>GetNorm</b></a>  <a href="#GetColumns"><b>GetRows</b></a>
           <a href="#GetTrace"><b>GetTrace</b></a>       <a href="#GetTranspose"><b>GetTranspose</b></a>    <a href="#GetIdentityMatrix"><b>GetZeroMatrix</b></a>      <a href="#Solve"><b>Solve</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: SkewMatrix  (with 2 arguments).
   (3) %--------------------------------------------------------------------
   (4) RigidFrame A
   (5) Constant   vx, vy, vz
   (6) v> = vx*Ax> + vy*Ay> + vz*Az> 
-> (7) v> = vx*Ax> + vy*Ay> + vz*Az>

   (8) vSkewA = SkewMatrix( A,  v> )
-> (9) vSkewA = [0, -vz, vy;  vz, 0, -vx;  -vy, vx, 0]

   (10) v234> = 2*Ax> + 3*Ay> + 4*Az>
-> (11) v234> = 2*Ax> + 3*Ay> + 4*Az>

   (12) crossProductMatrixA = vSkewA * Matrix( A, v234> )
-> (13) crossProductMatrixA = [4*vy - 3*vz;  2*vz - 4*vx;  3*vx - 2*vy]

   (14) crossProductVector> = Cross( v>, v234> )
-> (15) crossProductVector> = (4*vy-3*vz)*Ax> + (2*vz-4*vx)*Ay> + (3*vx-2*vy)*Az>

   (16) isEqual[1] = IsSimplifyEqual( Vector(A, crossProductMatrixA),  crossProductVector> )
-> (17) isEqual[1] = true

   (18) %--------------------------------------------------------------------
   (19) % Example 2: SkewMatrix  (with 1 argument since v> has a uniform basis).
   (20) %--------------------------------------------------------------------
   (21) vSkewA := SkewMatrix( v> )
-> (22) vSkewA = [0, -vz, vy;  vz, 0, -vx;  -vy, vx, 0]

   (23) %--------------------------------------------------------------------
   (24) % Example 3: SkewMatrix  (with 2 arguments and a mixed-basis vector).
   (25) %--------------------------------------------------------------------
   (26) RigidBody  B
   (27) Constant   theta
   (28) B.SetRotationMatrixZ( A, theta )
-> (29) B_A = [cos(theta), sin(theta), 0;  -sin(theta), cos(theta), 0;  0, 0, 1]

   (30) v> := vx*Ax> + vy*By> + vz*Bz>    % Mixed-basis vector v>.
-> (31) v> = vx*Ax> + vy*By> + vz*Bz>

   (32) vSkewA := SkewMatrix( A,  v> )
-> (33) vSkewA[1,1] = 0
-> (34) vSkewA[1,2] = -vz
-> (35) vSkewA[1,3] = vy*cos(theta)
-> (36) vSkewA[2,1] = vz
-> (37) vSkewA[2,2] = 0
-> (38) vSkewA[2,3] = vy*sin(theta) - vx
-> (39) vSkewA[3,1] = -vy*cos(theta)
-> (40) vSkewA[3,2] = vx - vy*sin(theta)
-> (41) vSkewA[3,3] = 0

   (42) vSkewB := SkewMatrix( B,  v> )
-> (43) vSkewB[1,1] = 0
-> (44) vSkewB[1,2] = -vz
-> (45) vSkewB[1,3] = vy - vx*sin(theta)
-> (46) vSkewB[2,1] = vz
-> (47) vSkewB[2,2] = 0
-> (48) vSkewB[2,3] = -vx*cos(theta)
-> (49) vSkewB[3,1] = vx*sin(theta) - vy
-> (50) vSkewB[3,2] = vx*cos(theta)
-> (51) vSkewB[3,3] = 0

   (52) isEqual[2] = IsSimplifyEqual( A_B * vSkewB * B_A, vSkewA ) 
-> (53) isEqual[2] = true

   (54) isEqual[3] = IsSimplifyEqual( B_A * vSkewA * A_B, vSkewB ) 
-> (55) isEqual[3] = true

   (56) %--------------------------------------------------------------------
   (57) % Example 4: SkewMatrix  (related to cross-product with unit dyadic).
   (58) %--------------------------------------------------------------------
   (59) v> := vx*Ax> + vy*Ay> + vz*Az> 
-> (60) v> = vx*Ax> + vy*Ay> + vz*Az>

   (61) vCrossUnitDyadic>> = Cross( v>,  1>> )
-> (62) vCrossUnitDyadic>> = -vz*Ax>*Ay> + vy*Ax>*Az> + vz*Ay>*Ax> - vx*Ay>*Az>
        - vy*Az>*Ax> + vx*Az>*Ay>

   (63) unitDyadicCrossV>> = Cross( 1>>,  v> )
-> (64) unitDyadicCrossV>> = -vz*Ax>*Ay> + vy*Ax>*Az> + vz*Ay>*Ax> - vx*Ay>*Az>
        - vy*Az>*Ax> + vx*Az>*Ay>

   (65) vCrossUnitDyadicSkewA = Matrix( A, vCrossUnitDyadic>> ) 
-> (66) vCrossUnitDyadicSkewA = [0, -vz, vy;  vz, 0, -vx;  -vy, vx, 0]

   (67) unitDyadicCrossVSkewA = Matrix( A, unitDyadicCrossV>> ) 
-> (68) unitDyadicCrossVSkewA = [0, -vz, vy;  vz, 0, -vx;  -vy, vx, 0]

   (69) vSkewMatrixA := SkewMatrix( A,  v> ) 
-> (70) vSkewMatrixA = [0, -vz, vy;  vz, 0, -vx;  -vy, vx, 0]

   (71) isEqual[4] = IsSimplifyEqual( vCrossUnitDyadicSkewA, unitDyadicCrossVSkewA ) 
-> (72) isEqual[4] = true

   (73) isEqual[5] = IsSimplifyEqual( vCrossUnitDyadicSkewA, vSkewMatrixA ) 
-> (74) isEqual[5] = true



</PRE><nobr><a name="min"><font color="darkBlue"><font size=+1><b>min</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
min  or  max

 Purpose:  Returns the smaller or larger of two real numbers.

Syntax 1:  min( x, y )
Syntax 2:  max( x, y )

   Input:  x -- an expression that resolves to a real number.
           y -- an expression that resolves to a real number.

Output 1:  Minimum of x and y.
Output 2:  Maximum of x and y.

 Related:  <a href="#ceil"><b>ceil</b></a>  <a href="#ceil"><b>floor</b></a>  <a href="#int"><b>int</b></a>  <a href="#min"><b>max</b></a>  <a href="#min"><b>min</b></a>  <a href="#round"><b>round</b></a>  <a href="#RoundDigits"><b>RoundDigits</b></a>  <a href="#sign"><b>sign</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: min 
   (3) %--------------------------------------------------------------------
   (4) A = min(  3,  5 ) 
-> (5) A = 3

   (6) B = min( -3, -5 ) 
-> (7) B = -5

   (8) C = 50
-> (9) C = 50

   (10) D = min( 3, C ) 
-> (11) D = 3

   (12) %--------------------------------------------------------------------
   (13) % Example: max 
   (14) %--------------------------------------------------------------------
   (15) E = max(  3,  5 ) 
-> (16) E = 5

   (17) F = max( -3, -5 ) 
-> (18) F = -3



</PRE><nobr><a name="NewtonianFrame"><font color="darkBlue"><font size=+1><b>NewtonianFrame</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
NewtonianFrame

 Purpose:  Declares a Newtonian (inertial) reference frame, which is
           a special RigidFrame in which  F = m*a  is valid.

Syntax 1:  NewtonianFrame N      (creates a Newtonian reference frame N)
Syntax 2:  NewtonianFrame        (displays the name of the NewtonianFrame)
Syntax 3:  #NewtonianFrame#      (string substitution with the NewtonianFrame)

   Input:  N -- name that starts with a letter, followed by a reasonable number
                of alphanumeric characters (e.g., less than 12 characters).

Output 1:  NewtonianFrame N   creates a special  RigidFrame N  and creates
           right-handed orthogonal unit vectors Nx>, Ny>, Nz> fixed in N and
           creates a point No (called N's origin) fixed in N (welded to N).

  Remark:  The NewtonianFrame may be changed anytime or reassigned
           to the name of an existing RigidFrame or RigidBody.
           It cannot be welded to another frame.

 Related:  <a href="#NewtonianFrame"><b>NewtonianFrame</b></a>  <a href="#Particle"><b>Particle</b></a>  <a href="#Point"><b>Point</b></a>  <a href="#RigidBody"><b>RigidBody</b></a>  <a href="#RigidFrame"><b>RigidFrame</b></a>  <a href="#System"><b>System</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: NewtonianFrame
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N
   (5) Particle  Q
   (6) Q.SetMass( m )
   (7) Q.SetVelocity( N,  2*Nx> + 4*Ny> )
-> (8) v_Q_N> = 2*Nx> + 4*Ny>

   (9) KE = Q.GetKineticEnergy()
-> (10) KE = 10*m

   (11) a_Q_#NewtonianFrame#> = Dt( Q.GetVelocity(#NewtonianFrame#), #NewtonianFrame# )
-> (12) a_Q_N> = 0>



</PRE><nobr><a name="numerator"><font color="darkBlue"><font size=+1><b>numerator</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
numerator  or  denominator  (experimental command -- subject to change).

 Purpose:  Returns the numerator or a denominator of a fraction.

Syntax 1:  numerator(   fractionExpression )
Syntax 2:  denominator( fractionExpression )

   Input:  fractionExpression -- an expression that resolves to fraction.

Output 1:  The numerator   of fractionExpression.
Output 2:  The denominator of fractionExpression.

 Related:  <a href="#MathFunctions"><b>MathFunctions</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: numerator or denominator
   (3) %--------------------------------------------------------------------
   (4) expression = 3*(2+t)/(5 + cos(t))
-> (5) expression = 3*(2+t)/(5+cos(t))

   (6) num = numerator( expression ) 
-> (7) num = 6 + 3*t

   (8) den = denominator( expression ) 
-> (9) den = 5 + cos(t)



</PRE><nobr><a name="ODE"><font color="darkBlue"><font size=+1><b>ODE</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
ODE

 Purpose:  Executes or writes a MATLAB, C, or Fortran program to solve
           ordinary differential or coupled differential/algebraic equations.

Syntax 1:  ODE()                             Filename.Ext
Syntax 2:  ODE( EqnsToSolve, x1, x2, ... )   Filename.Ext
Syntax 3:  ODE()                             Filename.Ext( Tx, Ty, Tz )
Syntax 4:  ODE() [A = Astart, Astop, Astep]  Filename.Ext
Note:      The various options in Syntax 1-4 can be used together.

   Input:  Filename -- a valid file name.  If no Filename is specified,
           the program solves the ODEs and puts results in the file ODE.i

           Ext -- nothing (immediate solution)
               -- .m    (produces MATLAB  code)
               -- .c    (produces C       code and input file Filename.in)
               -- .f    (produces FORTRAN code and input file Filename.in)
               -- .for  (same as .f except 72 character line length)

   Input:  EqnsToSolve -- matrix of (or single) scalar expressions that are
           LINEAR functions of x1, x2, ..., and regarded as equal to zero.
           Treated as:  EqnsToSolve[1] = 0,   EqnsToSolve[2] = 0, ...
           EqnsToSolve may have form EqnsToSolve = 0 or EqnsToSolve = Rhs.

           x1, x2 -- the names of scalars or a matrix of scalar names.

           Tx, Ty, Tz -- scalar names (maybe with units) that allow for
           passing command-line arguments to MATLAB or C programs.
           Example 1:  Filename.m( Tx N*m,  Ty N*cm,  Tz lbf*ft )
           Example 2:  Filename( Tx=2 N*m,  Ty=3 N*cm,  Tz = 5 )

           A = Astart, Astop, Astep -- A is the name (maybe with units) of a
           scalar quantity used as a loop index.  Astart, Astop, Astep are
           numerical values.  Example:  [A cm = 0, 100, 2]

Output 1:  Produces a program that solves the ordinary differential
           equations in the workspace, output their numerical results, and
           output numerical values of quantities named in OUTPUT statements.

Output 2:  Solves the set of simultaneous algebraic equations in EqnsToSolve
           for x1, x2, ...  at each time step while also solving the ODEs
           in the workspace and outputting relevant numerical results.

Output 3:  To run Filename.m, type  Filename( 12, 56, 87 )  at MATLAB prompt.
           To run Filename.c, type  Filename 12 56 87       from OS shell.

Output 4:  Incorporates Fortran DO-loops or C/MATLAB FOR-loops.
           To have multiple loops inside the program, use, e.g.,
           [ A = Astart, Astop, Astep;   B = Bstart, Bstop, Bstep; ... ]

  Remark:  Input values and units are named in INPUT statements.
           Output quantities and units are named in OUTPUT statements.

  Remark:  SetDigits sets the format of numbers output by programs created by
           the ODE command.  It does not affect calculation accuracy.

  Remark:  The solution is approximate and its accuracy tends to improve
           as the input value assigned to absError gets smaller.
           The default value of absError can be changed via the Input command:
           Input  absError = 1.0E-5 cm,  relError = 1.0E-7

  Remark:  Use the  .for  extension for FORTRAN whose line lengths cannot
           exceed 72 characters and which supports all line breaks.
           Use the  .f   extension for FORTRAN with lines less than 120
           characters and which cannot break lines in the middle of names.

 Related:  <a href="#ODE"><b>ODE</b></a>  <a href="#Solve"><b>Solve</b></a>  <a href="#Input"><b>Input</b></a>  <a href="#Output"><b>Output</b></a>  <a href="#Output"><b>OutputPlot</b></a>  <a href="#Plot"><b>Plot</b></a>  <a href="#Animate"><b>Animate</b></a>
           <a href="#ConvertUnits"><b>ConvertUnits</b></a>  <a href="#GetUnitSystem"><b>GetUnitSystem</b></a>  <a href="#SetUnitSystem"><b>SetUnitSystem</b></a>  <a href="#SetDigits"><b>SetDigits</b></a>  <a href="#SetLineWidth"><b>SetLineWidth</b></a>
           <a href="#t"><b>t</b></a>  <a href="#absError"><b>tInitial</b></a>  <a href="#absError"><b>tFinal</b></a>  <a href="#absError"><b>tStep</b></a>  <a href="#absError"><b>absError</b></a>  <a href="#absError"><b>printIntScreen</b></a>  <a href="#absError"><b>printIntFile</b></a>
           <a href="#Solve"><b>Solve</b></a>  <a href="#SolveDt"><b>SolveDt</b></a>  <a href="#SolveSetInput"><b>SolveSetInput</b></a>  <a href="#SolveSetInputDt"><b>SolveSetInputDt</b></a>  ...

   (1) %--------------------------------------------------------------------
   (2) % Example 1: ODE()      (1st-order ODE)
   (3) %--------------------------------------------------------------------
   (4) Variable x' = sin(t)
-> (5) x' = sin(t)

   (6) Input  x = 1 m,  tFinal=10 sec,  tStep=0.02 sec,  absError=1.0E-07
   (7) Output  t seconds,  x m,  x' m/sec
   (8) ODE()  FirstOrderODE

   (9) %--------------------------------------------------------------------
   (10) % Example 2: ODE()      (2nd-order ODE)
   (11) %--------------------------------------------------------------------
   (12) Variable  q'' = cos(t) - sin(q) 
-> (13) q'' = cos(t) - sin(q)

   (14) Input  q = 0 deg,  q' = 2 rad/sec
   (15) Output  t seconds,  q  degrees,  q' deg/sec,  q'' rad/sec^2
   (16) ODE()  SecondOrderODE

   (17) %--------------------------------------------------------------------
   (18) % Example 3: ODE()      (Pass arguments b and k to .m function) 
   (19) %--------------------------------------------------------------------
   (20) Constant m = 1 kg,  b,  k
   (21) Variable y'' = (-b*y' - k*y) / m
-> (22) y'' = -(k*y+b*y')/m

   (23) Input  y = 1 m,  y' = 0 m/sec
   (24) ODE()  HarmonicOscillator.m(  b N*s/m,  k N/cm ) 

   (25) %--------------------------------------------------------------------
   (26) % Example 4: ODE(...)   (Coupled 2rd-order ODEs - with plotting) 
   (27) %--------------------------------------------------------------------
   (28) Variable qA'', qB''
   (29) Eqn[1] = 10*sin(qA) + (21-sin(qB)^2)*qA'' - 2*sin(qB)*cos(qB)*qA'*qB' 
-> (30) Eqn[1] = 10*sin(qA) + (21-sin(qB)^2)*qA'' - 2*sin(qB)*cos(qB)*qA'*qB'

   (31) Eqn[2] = sin(qB)*cos(qB)*qA'^2 + qB''
-> (32) Eqn[2] = sin(qB)*cos(qB)*qA'^2 + qB''

   (33) Input  qA = 90 deg,  qB = 1.0 deg,  qA' = 0 rad/sec,  qB' = 0 rad/sec
   (34) OutputPlot  t sec,  qA degrees,  qB degrees
   (35) ODE( Eqn,  qA'',  qB'' )  CoupledSecondOrderODE.m 



</PRE><nobr><a name="Optimize"><font color="darkBlue"><font size=+1><b>Optimize</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Optimize

 Purpose:  Optimizes a function (e.g., finding a local minimum or maximum)
           with or without equality constraints, e.g., a combination of
           statics, dynamics, and/or geometry and motion constraints.

Syntax 1:  Optimize( CostFunction,  Constraints,  x1, x2, ...)
           Optimize( CostFunction,                x1, x2, ... )
Syntax 2:  Optimize( CostFunction,  Constraints,  x1=Guess1,  x2=Guess2,  ... )
           Optimize( CostFunction,                x1=Guess1,  x2=Guess2,  ... )
Syntax 3:  answer = Optimize( CostFunction, Constraints, x1=Guess1, x2=Guess2 )
           answer = Optimize( CostFunction,              x1=Guess1, x2=Guess2 )

   Input   CostFunction -- one scalar expression that depends on x1, x2, ...

           Constraints -- one or more scalar expressions (in a matrix) that
           are functions of x1, x2, ..., and regarded as equal to zero.
           Treated as:  Constraints[1] = 0,   Constraints[2] = 0,  ...

           x1, x2 -- the names of scalars or a matrix of scalar names.

           Guess1, Guess2 -- expressions that resolve to real numbers.

Output 1:  A matrix of scalar expression which are equal to zero, and which
           can be subsequently solved to determine values for x1, x2, ...,.
Output 2:  Solutions (real numbers) are assigned to x1, x2, ...
Output 3:  Solutions (real numbers) are returned in a matrix.
           Solutions are NOT assigned to x1, x2, ...

 Remark:   Depending on the CostFunction and Constraints, the matrix of
           returned equations may be linear or nonlinear in the unknowns.

 Remark:   CostFunction is a single (one) scalar expression.
           For least-square optimization of form  CostFunction = x1^2 + x2^2,
           if Constraints are linear in the x1, x2,  the returned
           matrix of equation(s) are linear in x1, x2, ...
           For convex optimization, e.g.,  CostFunction = x1^2 + x2^2  or
           CostFunction = x1^4 + x2^4,  there is one optimal solution.
           For non-convex optimization, the returned equations(s)
           may be nonlinear and there may be multiple solutions.

 Remark:   Providing Guess1, Guess2, ..., instructs Optimize to subsequently
           call  Solve  to produce a NUMERICAL solution for x1, x2, ...
           Type  Help Solve  for more information.

 Related:  <a href="#ODE"><b>ODE</b></a>  <a href="#Solve"><b>Solve</b></a>  <a href="#SolveDt"><b>SolveDt</b></a>  <a href="#SolveSetInput"><b>SolveSetInput</b></a>  <a href="#SolveSetInputDt"><b>SolveSetInputDt</b></a>  <a href="#Optimize"><b>Optimize</b></a> ...
           <a href="#GetPolynomialRoots"><b>GetPolynomial</b></a>  <a href="#GetPolynomialRoots"><b>GetPolynomialRoots</b></a>  <a href="#GetPolynomialRoots"><b>GetQuadraticRoots</b></a>  ...
           <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRoot</b></a>  <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRootDt</b></a>  ...
           <a href="#SetAutoDifferentiate"><b>SetAutoDifferentiate</b></a>  <a href="#SetAutoOverwrite"><b>SetAutoOverwrite</b></a>
           <a href="#SetDt"><b>SetDt</b></a>  <a href="#SetDt"><b>SetNoDt</b></a>   <a href="#="><b>=</b></a>   <a href="#="><b>:=</b></a>   <a href="#="><b>+=</b></a>   <a href="#="><b>*=</b></a>   <a href="#="><b>/=</b></a>   <a href="#="><b>^=</b></a>


</PRE><nobr><a name="Output"><font color="darkBlue"><font size=+1><b>Output</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Output  OutputPlot  OutputEncode

 Purpose:  Causes programs created by the ODE and Solve command to create
           output files containing designated quantities and units.
           Displays quantities listed in Output statements.

Syntax 1:  Output       x1 optionalUnits1, x2 optionalUnits2, ...
           OutputPlot   x1 optionalUnits1, x2 optionalUnits2, ...
           OutputEncode x1 optionalUnits1, x2 optionalUnits2, ...

   Input:  x1, x2, ... -- the names of scalars or matrices
           optionalUnits1, optionalUnits2 -- units associated with x1, x2, ...

 Purpose:  The values of x1 and x2 are calculated when a program produced
           by the ODE or Solve command is executed.

           OutputPlot will include statements in .m files to generate plots
           when a .m file is run - or immediately generate plots when
           an ODE() command is run with a Windows/PC computer.

           OutputEncode instructs programs to calculate output without writing
           to data files or displaying them on-screen.

 Remark:   In the event that x1, x2, ... is a matrix, the associated programs
           calculate the matrix elements, but do not display their values.

           If no units are assigned to x1, x2, ... in an Output statement,
           the units assigned to x1, x2, ... in an Input command will
           automatically be assigned to x1, x2, ...

           If no units are assigned in Input or Output statements to:
           t, tInitial, tFinal, tStep,  then the time unit designated
           by SetUnitSystem is assigned to these quantities automatically.

           Type  GetUnitSystem  for a list of units
--------------------------------------------------------------------
Syntax 2:  ClearOutput()       or ClearOutput(     startInteger : stopInteger)
           ClearOutputPlot()   or ClearOutputPlot( startInteger : stopInteger)
           ClearOutputEncode() or ClearOutputEncode(startInteger: stopInteger)

   Input:  startInteger -- the first output statement to be cleared.
           stopInteger  -- the last  output statement to be cleared.

 Purpose:  Clears the designated range (or all if no range is designated) of
           previously issued Output, OutputPlot, or OutputEncode statements.
--------------------------------------------------------------------
Syntax 3:  Output  or  OutputPlot  or  OutputEncode
           Displays a list of Output, OutputPlot, OutputEncode statements.
--------------------------------------------------------------------

 Related:  <a href="#ODE"><b>ODE</b></a>  <a href="#Input"><b>Input</b></a>  <a href="#Output"><b>Output</b></a>  <a href="#Output"><b>OutputPlot</b></a>  <a href="#Plot"><b>Plot</b></a>  <a href="#SetPlotInterface"><b>SetPlotInterface</b></a>  <a href="#Animate"><b>Animate</b></a>
           <a href="#ConvertUnits"><b>ConvertUnits</b></a>  <a href="#GetUnitSystem"><b>GetUnitSystem</b></a>  <a href="#SetUnitSystem"><b>SetUnitSystem</b></a>  <a href="#SetDigits"><b>SetDigits</b></a>
           <a href="#t"><b>t</b></a>  <a href="#absError"><b>tInitial</b></a>  <a href="#absError"><b>tFinal</b></a>  <a href="#absError"><b>tStep</b></a>  <a href="#absError"><b>absError</b></a>  <a href="#absError"><b>printIntScreen</b></a>  <a href="#absError"><b>printIntFile</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  Output
   (3) %--------------------------------------------------------------------
   (4) Variable  y' = cos(t)*y 
-> (5) y' = cos(t)*y

   (6) mat = [t, y, y';  y^2, abs(y), cos(t)]
-> (7) mat = [t, y, y';  y^2, abs(y), cos(t)]

   (8) Input  y = 22 cm,  tFinal = 5 sec,  tStep = 0.1 sec
   (9) Output        t sec,  y cm,  y inch,  y^2 m 
   (10) OutputPlot    t sec,  y m,   y' m/s 
   (11) OutputEncode  t sec,  mat noUnits
   (12) ODE() Test.m

   (13) %-------------------------------------------------------------------
   (14) % Running the MATLAB file Test.m produces: a plot, the data file Test.1
   (15) % and calculations for all the elements in the matrix mat.
   (16) %
   (17) % FILE: Test.1
   (18) %
   (19) %       t              y              y             y^2
   (20) %     (sec)          (cm)          (inch)           (m)
   (21) %
   (22) % 0.000000E+00   2.200000E+01   8.661417E+00   4.840000E-02 
   (23) % 1.000000E-01   2.430971E+01   9.570752E+00   5.909620E-02 
   (24) %      ...            ...           ...            ...
   (25) %
   (26) %--------------------------------------------------------------------
   (27) % Example 2: Typing OUTPUT causes the following to be displayed
   (28) %--------------------------------------------------------------------
   (29) % Output 1:  t sec, y cm, y inch, y^2 m


</PRE><nobr><a name="Particle"><font color="darkBlue"><font size=+1><b>Particle</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Particle

 Purpose:  Declares particles.

Syntax 1:  Particle Q1, Q2, ...          (creates particles Q1, Q2, ...)
Syntax 2:  Particle                      (displays names of all Particles)

   Input:  Q1 -- name that starts with a letter, followed by a reasonable
                 number of alphanumeric characters (similarly for Q2).

  Remark:  Particle Q{1:4}       is same as:  Particle Q1, Q2, Q3, Q4
           Particle Q{1:3}Ed     is same as:  Particle Q1Ed, Q2Ed, Q3Ed
           Particle Q{1:2}{2:3}  is same as:  Particle QB12, Q13, Q22, Q23

 Related:  <a href="#NewtonianFrame"><b>NewtonianFrame</b></a>  <a href="#Particle"><b>Particle</b></a>  <a href="#Point"><b>Point</b></a>  <a href="#RigidBody"><b>RigidBody</b></a>  <a href="#RigidFrame"><b>RigidFrame</b></a>  <a href="#System"><b>System</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: Particle
   (3) %--------------------------------------------------------------------
   (4) RigidBody B
   (5) Particle  Q
   (6) Particle  Q{1:4}
   (7) %--------------------------------------------------------------------
   (8) % Example 2: Particle  (typing PARTICLE displays the following)
   (9) %--------------------------------------------------------------------
   (10) % The following Particle have been declared:
   (11) %
   (12) % Q  Q1  Q2  Q3  Q4


</PRE><nobr><a name="PathToMotionGenesis"><font color="darkBlue"><font size=+1><b>PathToMotionGenesis</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
PathToMotionGenesis  (Unnecessary for regular program use).

 Purpose:  Specifies the operating system path to the MotionGenesis folder.
           This is the top-level directory (folder) for the program.
           Its sub-directories contains files used by the program.

  Windows 10:

           To permanently set the operating system environment variable
           1. Open the Start Search (click on the Windows key).
           2. Type env
           3. Choose Edit the system environment variables
           4. Click the Environment Variables ... button.
           5. Under the user variables panel, click on the New button.
           6. Enter the variable name  as  PathToMotionGenesis
           7. Enter the variable value as  pathToProgram
              where pathToProgram is something like C:\MotionGenesis

           To temporarily set this operating system environment variable
           1.  Open a operating system terminal window -- which can be done in
               many ways, e.g., browse to the MotionGenesis folder and click on
               the fileMotionGenesisTerminal.lnk.
           2.  At the terminal prompt, type the following where pathToProgram
               is the path to the MotionGenesis folder, e.g., C:\MotionGenesis

               SET PathToMotionGenesis=pathToProgram

  Unix and Macintosh OSX:

           To permanently set the environment variable, edit the file .cshrc
           and add the following line where pathToProgram is something like
           /applications/MotionGenesis

                setenv PathToMotionGenesis pathToProgram

           After editing the .cshrc file, type source .cshrc at the Unix prompt
           (or logout and login again)

  Remark:  Even if this environment variable is not set or is set improperly,
           the program searches and usually finds its associated files.

  Remark:  Before March 2020, PathToMotionGenesis was named MOTIONGENESISPATH

 Related:  <a href="#GetDefaults"><b>GetDefaults</b></a>  <a href="#SetWorkingDirectory"><b>GetWorkingDirectory</b></a>  <a href="#SetWorkingDirectory"><b>SetWorkingDirectory</b></a>
           <a href="#GetEnvironmentValue"><b>GetEnvironmentValue</b></a>   <a href="#SetScratchDirectory"><b>SetScratchDirectory</b></a>



</PRE><nobr><a name="Pause"><font color="darkBlue"><font size=+1><b>Pause</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Pause  or  Stop

 Purpose:  Suspends execution when running an input file.

Syntax 1:  Pause( )
Syntax 2:  Pause( numberOfSeconds )
Syntax 3:  Pause( WAIT )
Syntax 4:  Pause( STOP )   or   STOP

   Input:  numberOfSeconds -- an integer between 0 and 60, equal to the
           desired duration, in seconds, to pause program execution.
           Note: No pause occurs when numberOfSeconds is 0.

Output 1:  On-screen appearance of the following message:
           Press ENTER to resume execution.
           Press any other key to proceed interactively.

Output 2:  Suspends program execution for numberOfSeconds.
Output 3:  Suspends program execution until the user presses the ENTER key.
Output 4:  Stops reading from input file and proceeds interactively.

  Remark:  If reading from an input file stops, you may type RUN
           to resume execution from the input file.

 Related:  <a href="#!"><b>!</b></a>  <a href="#%"><b>%</b></a>  <a href="#&"><b>&</b></a>  <a href="#Clear"><b>Clear</b></a>  <a href="#List"><b>List</b></a>  <a href="#Pause"><b>Pause</b></a>  <a href="#Quit"><b>Quit</b></a>  <a href="#Run"><b>Run</b></a>  <a href="#Save"><b>Save</b></a>  <a href="#SetPauseOnWarning"><b>SetPauseOnWarning</b></a>



</PRE><nobr><a name="pi"><font color="darkBlue"><font size=+1><b>pi</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
pi

 Purpose:  Name assigned to the following ratio associated with a circle:
           pi = CircumferenceOfCircle / DiameterOfCircle.

  Syntax:  pi

  Value:   3.14159265358979323846264338327950288419716939937510582 ...

 Related:  <a href="#Constant"><b>Constant</b></a>  <a href="#ImaginaryNumber"><b>ImaginaryNumber</b></a>  <a href="#Specified"><b>Specified</b></a>  <a href="#Variable"><b>Variable</b></a>  <a href="#TrueFalse"><b>true</b></a> <a href="#TrueFalse"><b>false</b></a>
           <a href="#SetGeneralizedSpeed"><b>SetGeneralizedCoordinate</b></a>  <a href="#SetGeneralizedSpeed"><b>SetGeneralizedSpeed</b></a>  <a href="#t"><b>t</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: pi
   (3) %--------------------------------------------------------------------
   (4) a = sin(pi*t)
-> (5) a = sin(pi*t)

   (6) b = dt( a )
-> (7) b = pi*cos(pi*t)

   (8) c = 1.234*dt(a)
-> (9) c = 3.876725*cos(pi*t)



</PRE><nobr><a name="Plot"><font color="darkBlue"><font size=+1><b>Plot</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Plot       For PC/Windows and with proper install of Java JDK on Macintosh OS/X

 Purpose:  Invokes plotting program

Syntax 1:  Plot
Syntax 2:  Plot dataFile1
Syntax 3:  Plot dataFile1, dataFile2, dataFile3
Syntax 4:  Plot dataFile1 [1,2,3,4]  dataFile2 [1,4,3]
Syntax 5:  PlotTest

   Input:  dataFilei -- the name of a data file having columns of numbers.
           [1,2,3,4] -- designates the columns to be plotted, i.e.,
                        plots columns 2, 3, and 4 versus column 1.

Output 1:  Starts the interactive plotting program (graphical user interface).
Output 2:  Starts the plotting program and plots the data in dataFile1.
Output 3:  Plots the data in dataFile1, dataFiel2, dataFile3.
Output 4:  Plots columns 2 vs 1, 3 vs 1, 4 vs 1 in dataFile1.
           Plots columns 4 vs 1, 3 vs 1  in dataFile2.
Output 5:  Tests the plotting program by displaying a sample plot.

  Remark:  Alternatively, you can invoke the plotting program from the
           OS (operating system) command line by typing, e.g.,
           MotionGenesis  Plot  dataFile1
           MotionGenesis  Plot dataFile1, dataFile2, dataFile3
           MotionGenesis  Plot dataFile1 [1,2,3,4]  dataFile2 [1,4,3]

  Remark:  There are many ways to plot (with or without a license).
           At the operating system prompt, type:  MotionGenesis dataFile1
           PC/Windows: Drag and drop one or more data files onto the icon for
           MotionGenesis  or  MotionGenesisStartHere
           See more HELP (and many other options) after starting the Plot tool.

 Related:  <a href="#ODE"><b>ODE</b></a>  <a href="#Solve"><b>Solve</b></a>  <a href="#Input"><b>Input</b></a>  <a href="#Output"><b>Output</b></a>  <a href="#Output"><b>OutputPlot</b></a>  <a href="#Plot"><b>Plot</b></a>  <a href="#Animate"><b>Animate</b></a>
           <a href="#SetPlotInterface"><b>SetPlotInterface</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: Plot  
   (3) % Plot A:  x, x^2, x' versus t.  Uses data from file OdeData.1
   (4) % Plot B:  x, y       versus t.  Uses files OdeData.1, OdeData.2
   (5) %--------------------------------------------------------------------
   (6) Variable x' = sin(t)
-> (7) x' = sin(t)

   (8) Variable y' = cos(t)
-> (9) y' = cos(t)

   (10) Input   x = 0,  y = 0,  tFinal = 10
   (11) Output  t, x, x^2, x'
   (12) Output  t, y, y'
   (13) ODE()  OdeData

   (14) Plot   OdeData.1 [1, 2,3,4]  
   (15) Pause( 5 )
   (16) Plot   OdeData.1 [1,2]       OdeData.2 [1,2]


</PRE><nobr><a name="Point"><font color="darkBlue"><font size=+1><b>Point</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Point

 Purpose:  Declares points.  Welds a point to a RigidFrame or RigidBody.

Syntax 1:  Point P1, P2, ...         (creates points P1, P2, ...)
Syntax 2:  Point P()                 (creates point P, not welded to an object)
Syntax 3:  Point Q( B )              (creates point Q welded to B)
Syntax 4:  Point                     (displays names of all Points)

   Input:  P1 -- name that starts with a letter, followed by a reasonable
                 number of alphanumeric characters (similarly for P2, etc).

           B -- the name of a RigidFrame or RigidBody.

Output 2:  Point P()  creates a point Q that is purposely not attached to a
           RigidBody or RigidFrame (suppressing related notes/warnings).

Output 3:  Creates point Q of RigidFrame or RigidBody B  (welds Q to B).
           Sets Q's velocity and acceleration in B  to 0>.
           Propagates forces on Q to resultant forces and moments on B.

  Remark:  Point P{1:4}        is same as:   Point P1, P2, P3, P4
           Point P{1:3}Ed      is same as:   Point P1Ed, P2Ed, P3Ed
           Point P{1:2}{2:3}   is same as:   Point P12, P13, P22, P23

  Remark:  The declaration  RigidFrame A  or  RigidBody A  automatically
           creates a point Ao (called A's origin) that is fixed on A.

           The declaration  RigidBody B  automatically creates a
           point Bcm (B's center of mass) that is fixed on B.

 Related:  <a href="#NewtonianFrame"><b>NewtonianFrame</b></a>  <a href="#Particle"><b>Particle</b></a>  <a href="#Point"><b>Point</b></a>  <a href="#RigidBody"><b>RigidBody</b></a>  <a href="#RigidFrame"><b>RigidFrame</b></a>  <a href="#System"><b>System</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: Point
   (3) %--------------------------------------------------------------------
   (4) RigidBody  B
   (5) Point P
   (6) Point P{1:4}
   (7) Point Q(B)
   (8) %--------------------------------------------------------------------
   (9) % Example 2: Point  (typing POINT displays the following)
   (10) %--------------------------------------------------------------------
   (11) % The following Point have been declared:
   (12) %
   (13) % Bo  P  P1  P2  P3  P4  Q(B), Bcm


</PRE><nobr><a name="Quit"><font color="darkBlue"><font size=+1><b>Quit</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Quit  or  QuitExit

 Purpose:  Quits (exits) the program.

Syntax 1:  Quit
Syntax 2:  QuitExit

  Remark:  Quit will prompt the user if information has not been saved.
           QuitExit will quit (exit) without prompting the user to save.

 Related:  <a href="#!"><b>!</b></a>  <a href="#%"><b>%</b></a>  <a href="#&"><b>&</b></a>  <a href="#Clear"><b>Clear</b></a>  <a href="#List"><b>List</b></a>  <a href="#Pause"><b>Pause</b></a>  <a href="#Quit"><b>Quit</b></a>  <a href="#Run"><b>Run</b></a>  <a href="#Save"><b>Save</b></a>  <a href="#GetDefaults"><b>GetDefaults</b></a>



</PRE><nobr><a name="RandomInteger"><font color="darkBlue"><font size=+1><b>RandomInteger</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
RandomInteger

 Purpose:  Returns a random positive integer.

  Syntax:  RandomInteger()

  Output:  Random integer that is greater than or equal to 0 and less
           than or equal to a machine specific number (e.g., 32767).

 Related:  <a href="#ceil"><b>ceil</b></a>  <a href="#ceil"><b>floor</b></a>  <a href="#int"><b>int</b></a>  <a href="#min"><b>max</b></a>  <a href="#min"><b>min</b></a>  <a href="#round"><b>round</b></a>  <a href="#RoundDigits"><b>RoundDigits</b></a>  <a href="#sign"><b>sign</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: RandomInteger   
   (3) %--------------------------------------------------------------------
   (4) randomIntegerA = RandomInteger() 
-> (5) randomIntegerA = 9396

   (6) randomIntegerB = RandomInteger() 
-> (7) randomIntegerB = 9930

   (8) randomIntegerC = RandomInteger() 
-> (9) randomIntegerC = 20325



</PRE><nobr><a name="ReplaceString"><font color="darkBlue"><font size=+1><b>ReplaceString</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
ReplaceString

 Purpose:  Replaces strings in an expression with new strings.
           Truncates numbers in an expression (possibly simplifying it) by
           using the number of significant digits determined by SetDigits.

Syntax 1:  ReplaceString( mathExpression )
Syntax 2:  ReplaceString( mathExpression, string1=rhs1, string2=rhs2, ... )
Syntax 3:  QueryReplaceString( mathExpression, string1=rhs1, string2=rhs2 )

   Input:  mathExpression -- A scalar, vector, dyadic or matrix expression.
           stringi -- A string of characters appearing in mathExpression.
           rhsi -- An expression to substitute for stringi. (i=1, 2, ...)

Output 1:  Returns mathExpression with numbers rounded to the number
           of digits used for display which is determined by SetDigits
           (generally, less precise numbers are displayed than stored).

Output 2:  Returns mathExpression with stringi replaced by rhsi
           wherever stringi appears in mathExpression.
           Numbers are also truncated as described above.

Output 3:  Similar to Output 2 except that for each occurrence of stringi
           in mathExpression, queries whether or not replacement should occur.

  Remark:  The  ReplaceString  command  uses a string replacement
           which ignores mathematical rules as shown in Example 1:

  Remark:  Also see RoundDigits.

 Related:  <a href="#Epsilon"><b>Epsilon</b></a>  <a href="#Evaluate"><b>Evaluate</b></a>  <a href="#Expand"><b>Expand</b></a>  <a href="#Explicit"><b>Explicit</b></a>
           <a href="#Factor"><b>Factor</b></a>  <a href="#FactorLinear"><b>FactorLinear</b></a>  <a href="#FactorLinear"><b>FactorQuadratic</b></a>  <a href="#ReplaceString"><b>ReplaceString</b></a>  <a href="#RoundDigits"><b>RoundDigits</b></a>
           <a href="#GetRhs"><b>GetRhs</b></a>  <a href="#SetAutoRhs"><b>SetAutoRhs</b></a>  <a href="#SetDigits"><b>SetDigits</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: ReplaceString   (scalar expression)
   (3) %--------------------------------------------------------------------
   (4) Constant  a, x, y, z
   (5) s = x^2*cos(y) - sin(t)
-> (6) s = x^2*cos(y) - sin(t)

   (7) s1 = ReplaceString( s,  2*cos(y) = z )
-> (8) s1 = x^z - sin(t)

   (9) s2 = ReplaceString( s,  x^2*cos(y) = z )
-> (10) s2 = z - sin(t)

   (11) se = ReplaceString( s,  x^2*cos(y) - sin(t) = 3*z )
-> (12) se = 3*z

   (13) %--------------------------------------------------------------------
   (14) % Example 2: ReplaceString  (vector expression)
   (15) %--------------------------------------------------------------------
   (16) RigidBody   B
   (17) v> = Vector( B, (1.0000000000004)*x, (1.0000004)*x*y, (1.0004)*x*y*z )
-> (18) v> = 1*x*Bx> + 1*x*y*By> + 1.0004*x*y*z*Bz>

   (19) v1> = ReplaceString( v> )
-> (20) v1> = x*Bx> + x*y*By> + 1.0004*x*y*z*Bz>

   (21) v2> = ReplaceString( v>,  x*y = z )
-> (22) v2> = x*Bx> + z*By> + 1.0004*z^2*Bz>

   (23) %--------------------------------------------------------------------
   (24) % Example 3: ReplaceString   (matrix expression)
   (25) %--------------------------------------------------------------------
   (26) matrixA = [ v>;   x*y - z ]
-> (27) matrixA = [1*x*Bx> + 1*x*y*By> + 1.0004*x*y*z*Bz>;  x*y - z]

   (28) matrixB = ReplaceString( matrixA,  x*y - z = 5 )
-> (29) matrixB = [x*Bx> + x*y*By> + 1.0004*x*y*z*Bz>;  5]

   (30) %--------------------------------------------------------------------
   (31) % Example 4: QueryReplaceString
   (32) %--------------------------------------------------------------------
   (33) q = QueryReplaceString( t + t^2 + sin(t) + cos(t),  t^2 = 9, cos(t) = exp(t) )
-> (34) q = 9 + t + sin(t) + exp(t)



</PRE><nobr><a name="RigidBody"><font color="darkBlue"><font size=+1><b>RigidBody</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
RigidBody

 Purpose:  Declares rigid bodies.

Syntax 1:  RigidBody  A, B, ...     (creates rigid bodies A, B, ...)
Syntax 2:  RigidBody                (displays all names declared as RigidBody)

   Input:  A -- name that starts with a letter, followed by a reasonable
                number of alphanumeric characters (similarly for B).

Output 1:  The declaration  RigidBody B  automatically creates right-handed
           orthogonal unit vectors Bx>, By>, Bz>  fixed in B and creates a
           point Bcm (B's center of mass) that is fixed in B and creates a
           point Bo  (called B's origin)  that is fixed in B (welded to B).

  Remark:  RigidBody B{1:4}       is same as  RigidBody B1, B2, B3, B4
           RigidBody B{1:3}Ed     is same as  RigidBody B1Ed, B2Ed, B3Ed
           RigidBody B{1:2}{2:3}  is same as  RigidBody B12, B13, B22, B23

  Remark:  The declaration  Point P(B)       welds point P to rigid body B.
           The declaration  RigidFrame F(B)  welds F to rigid body B.

 Related:  <a href="#NewtonianFrame"><b>NewtonianFrame</b></a>  <a href="#Particle"><b>Particle</b></a>  <a href="#Point"><b>Point</b></a>  <a href="#RigidBody"><b>RigidBody</b></a>  <a href="#RigidFrame"><b>RigidFrame</b></a>  <a href="#System"><b>System</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: RigidBody
   (3) %--------------------------------------------------------------------
   (4) RigidBody A
   (5) RigidBody B, C
   (6) RigidBody G{2:5}Ed
   (7) %--------------------------------------------------------------------
   (8) % Example 2: RigidBody  (typing RigidBody displays the following)
   (9) %--------------------------------------------------------------------
   (10) % The following have been declared RigidBody:
   (11) %
   (12) % A  B  C  G2Ed  G3Ed  G4Ed  G5Ed


</PRE><nobr><a name="RigidFrame"><font color="darkBlue"><font size=+1><b>RigidFrame</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
RigidFrame

 Purpose:  Declares a rigid frame (reference frame).
           Welds a rigid frame to a RigidBody or another RigidFrame.

Syntax 1:  RigidFrame  A, B, ...    (creates rigid frames A, B, ...)
Syntax 2:  RigidFrame  B( D )       (creates rigid frame B welded to D)
Syntax 3:  RigidFrame               (displays names of all RigidFrames)

   Input:  A -- name that starts with a letter, followed by a reasonable
                number of alphanumeric characters (similarly for B).

           D -- name of a RigidFrame or RigidBody.

Output 1:  The declaration  RigidFrame A  automatically creates right-handed
           orthogonal unit vectors Ax>, Ay>, Az>  fixed in A and creates a
           point Ao  (called A's origin)  that is fixed in A (welded to A).

Output 2:  Creates RigidFrame B and welds it to RigidBody or RigidFrame D.
           Sets  B's  angular velocity/acceleration in D to 0>.
           Sets  point Bo's  velocity/acceleration  in D to 0>.
           Propagates force/torques on B to resultant forces/moments on D.

           RigidFrame B{1:4}       is same as  RigidFrame B1, B2, B3, B4
           RigidFrame B{1:3}Ed     is same as  RigidFrame B1Ed, B2Ed, B3Ed
           RigidFrame B{1:2}{2:3}  is same as  RigidFrame B12, B13, B22, B23

  Remark:  The NewtonianFrame is a special RigidFrame.

  Remark:  The declaration  Point P(B)  welds point P to RigidFrame B.

 Related:  <a href="#NewtonianFrame"><b>NewtonianFrame</b></a>  <a href="#Particle"><b>Particle</b></a>  <a href="#Point"><b>Point</b></a>  <a href="#RigidBody"><b>RigidBody</b></a>  <a href="#RigidFrame"><b>RigidFrame</b></a>  <a href="#System"><b>System</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: RigidFrame
   (3) %--------------------------------------------------------------------
   (4) RigidFrame A, D
   (5) RigidFrame B( D )
   (6) RigidFrame G{3:5}Ed
   (7) %--------------------------------------------------------------------
   (8) % Example 2: RigidFrame  (typing RigidFrame displays the following)
   (9) %--------------------------------------------------------------------
   (10) % The following have been declared RigidFrame:
   (11) %
   (12) % A  B(D)  D  G3Ed  G4Ed  G5Ed


</PRE><nobr><a name="Round"><font color="darkBlue"><font size=+1><b>Round</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Round

 Purpose:  Returns the integer nearest to a real number.

  Syntax:  Round( realScalarExpression )

   Input:  realScalarExpression -- a real scalar expression.

  Output:  Integer nearest to realScalarExpression.
           Positive numbers with a fractional part of 0.5 round up whereas
           negative numbers with a fractional part of -0.5 round down.

  Remark:  Also see RoundDigits.

 Related:  <a href="#ceil"><b>ceil</b></a>  <a href="#ceil"><b>floor</b></a>  <a href="#int"><b>int</b></a>  <a href="#min"><b>max</b></a>  <a href="#min"><b>min</b></a>  <a href="#round"><b>round</b></a>  <a href="#RoundDigits"><b>RoundDigits</b></a>  <a href="#sign"><b>sign</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: Round 
   (3) %--------------------------------------------------------------------
   (4) A = Round( 2.991 ) 
-> (5) A = 3

   (6) B = Round( 3.001 ) 
-> (7) B = 3

   (8) C = Round( -2.991 ) 
-> (9) C = -3

   (10) D = Round( -3.001 ) 
-> (11) D = -3

   (12) E = Round( 2.9 + t ) 
-> (13) E = round(2.9+t)

   (14) F = Round(  2.499999999 )
-> (15) F = 2

   (16) G = Round( -2.499999999 )
-> (17) G = -2

   (18) H = Round(  3.5 )
-> (19) H = 4

   (20) I = Round( -3.5 )
-> (21) I = -4



</PRE><nobr><a name="RoundDigits"><font color="darkBlue"><font size=+1><b>RoundDigits</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
RoundDigits

 Purpose:  Truncates numbers in an expression to a number of significant digits.

  Syntax:  RoundDigits( expression, n )

   Input:  expression -- a scalar, vector, dyadic, or matrix expression.
           n -- a positive integer less than or equal to 16.

  Output:  An approximation of expression in which all its numbers are
           truncated to n significant digits.

  Remark:  Also see Epsilon and ReplaceString.

 Related:  <a href="#Epsilon"><b>Epsilon</b></a>  <a href="#Evaluate"><b>Evaluate</b></a>  <a href="#Expand"><b>Expand</b></a>  <a href="#Explicit"><b>Explicit</b></a>
           <a href="#Factor"><b>Factor</b></a>  <a href="#FactorLinear"><b>FactorLinear</b></a>  <a href="#FactorLinear"><b>FactorQuadratic</b></a>  <a href="#ReplaceString"><b>ReplaceString</b></a>  <a href="#RoundDigits"><b>RoundDigits</b></a>
           <a href="#GetRhs"><b>GetRhs</b></a>  <a href="#SetAutoRhs"><b>SetAutoRhs</b></a>  <a href="#SetDigits"><b>SetDigits</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  RoundDigits  (scalar expression)
   (3) %--------------------------------------------------------------------
   (4) s = 2E-11 + 1.00007*t + (9876 + 5E-8)*sin(t)
-> (5) s = 2E-11 + 1.00007*t + 9876*sin(t)

   (6) s1 = RoundDigits( s,  1 ) 
-> (7) s1 = 2E-11 + t + 10000*sin(t)

   (8) s2 = RoundDigits( s,  2 )
-> (9) s2 = 2E-11 + t + 9900*sin(t)

   (10) s3 = RoundDigits( s,  3 )
-> (11) s3 = 2E-11 + t + 9880*sin(t)

   (12) s4 = RoundDigits( s,  4 )
-> (13) s4 = 2E-11 + t + 9876*sin(t)

   (14) %--------------------------------------------------------------------
   (15) % Example 2:  RoundDigits  (vector expression)
   (16) %--------------------------------------------------------------------
   (17) RigidFrame  N
   (18) v> = Vector( N,  2E-11, 1.00007*t, (9876 + 5E-8)*sin(t) )
-> (19) v> = 2E-11*Nx> + 1.00007*t*Ny> + 9876*sin(t)*Nz>

   (20) v1> = RoundDigits( v>,  1 )
-> (21) v1> = 2E-11*Nx> + t*Ny> + 10000*sin(t)*Nz>

   (22) v2> = RoundDigits( v>,  2 )
-> (23) v2> = 2E-11*Nx> + t*Ny> + 9900*sin(t)*Nz>

   (24) %--------------------------------------------------------------------
   (25) % Example 3:  RoundDigits  (matrix expression) 
   (26) %--------------------------------------------------------------------
   (27) m = [s; v>]
-> (28) m = [s;  2E-11*Nx> + 1.00007*t*Ny> + 9876*sin(t)*Nz>]

   (29) m1 = RoundDigits( m,  3 ) 
-> (30) m1 = [s;  2E-11*Nx> + t*Ny> + 9880*sin(t)*Nz>]

   (31) m2 = RoundDigits( m,  4 )
-> (32) m2 = [s;  2E-11*Nx> + t*Ny> + 9876*sin(t)*Nz>]



</PRE><nobr><a name="Rotate"><font color="darkBlue"><font size=+1><b>Rotate</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Rotate

 Purpose:  Sets the rotation matrix (direction cosine matrix) associated
           with the right-handed rotation of a rigid basis (e.g., B) in
           another rigid basis (e.g., A).  Tries to form B's angular
           velocity/acceleration in A and in the NewtonianFrame.

Syntax 1:  B.Rotate( A, matrix33 )
Syntax 2:  B.Rotate( A, aboutUnitVector, theta )
Syntax 3:  B.Rotate( A, SequenceIJK, q1, q2, q3 )
Syntax 4:  B.Rotate( A, EulerParameters, e0, e1, e2, e3 )
           B.Rotate( A, Quaternion,      e0, e1, e2, e3 )
Syntax 5:  B.Rotate( A, RodriguesParameters, rho1, rho2, rho3 )
Syntax 6:  B.RotateX( A, theta )     B.RotateNegativeX( A, theta )
           B.RotateY( A, theta )     B.RotateNegativeY( A, theta )
           B.RotateZ( A, theta )     B.RotateNegativeZ( A, theta )
           Type  HELP RotateX  for examples.

   Input:  B, A -- names of a RigidFrame or RigidBody.

           matrix33 -- 3x3 rotation matrix (direction cosine matrix).

           theta, q1, q2, q3 -- angles (scalar expressions).

           e0, e1, e2, e3 -- expressions for Euler parameters (quaternion).

           rho1, rho2, rho3 -- expressions for Rodrigues parameters.

           aboutUnitVector -- unit vector that can be expressed in terms of
                              either  Ax>, Ay>, Az>  or  Bx>, By>, Bz>.

           SequenceIJK -- BodyIJK or SpaceIJK, e.g., of the form:
                   BodyXYZ,  BodyYZX,  BodyZXY,  BodyXZY,  BodyYXZ,  BodyZYX
                   BodyXYX,  BodyXZX,  BodyYXY,  BodyYZY,  BodyZXZ,  BodyZYZ
                  SpaceXYZ, SpaceYZX, SpaceZXY, SpaceXZY, SpaceYXZ, SpaceZYX
                  SpaceXYX, SpaceXZX, SpaceYXY, SpaceYZY, SpaceZXZ, SpaceZYZ

  Output:  Sets and returns the rotation matrix B_A that is associated with
           right-handed rotations of B relative to A.  This rotation matrix
           relates unit vectors Bx>, By>, Bz>  to  Ax>, Ay>, Az>.

           B's angular velocity and angular acceleration in A are also
           formed if rotation matrix can be time-differentiated.

           B's angular velocity and angular acceleration in the
           NewtonianFrame are also formed if a NewtonianFrame was
           declared and the angular velocity and angular acceleration
           of A in the NewtonianFrame is in the workspace.

  Remark:  Definitions of orientation angles, Euler parameters (quaternion),
           Rodrigues parameters and direction cosines are in
           Kane, T. R.,  Likins, P. W.,  and Levinson D. A.,
           Spacecraft Dynamics, McGraw-Hill, 1983, Ch. 1., and
           Mitiguy, Paul, Advanced Dynamics for Professional
           Mechanical, Aerospace, and BioMechanical Engineers.

  Remark:  The command SetRotationMatrixODE also forms ODEs for the
           associated variables, e.g., the angles, or quaternion or ...

 Related:  <a href="#Rotate"><b>Rotate</b></a>  <a href="#RotateX"><b>RotateX</b></a>  <a href="#RotateY"><b>RotateY</b></a>  <a href="#RotateZ"><b>RotateZ</b></a>
           <a href="#RotateX"><b>RotateNegativeX</b></a>  <a href="#RotateY"><b>RotateNegativeY</b></a>  <a href="#RotateZ"><b>RotateNegativeZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixY</b></a>  <a href="#SetRotationMatrixZ"><b>SetRotationMatrixZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixNegativeX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixNegativeY</b></a>  ...
           <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>  <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>  <a href="#SetAngularAcceleration"><b>SetAngularAcceleration</b></a>
           <a href="#GetRotationMatrix"><b>GetRotationMatrix</b></a>  <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>  <a href="#GetAngularAcceleration"><b>GetAngularAcceleration</b></a>
           <a href="#SetRotationMatrixODE"><b>SetRotationMatrixODE</b></a>

   (1) RigidFrame A, B, C, D, E, F, G
   (2) %--------------------------------------------------------------------
   (3) % Example 1: Rotate (from rotation matrix).
   (4) %--------------------------------------------------------------------
   (5) Variable  R{1:3}{1:3}
   (6) B.Rotate( A, [R11,R12,R13; R21,R22,R23; R31,R32,R33] )
-> (7) B_A = [R11, R12, R13;  R21, R22, R23;  R31, R32, R33]

   (8) %--------------------------------------------------------------------
   (9) % Example 2: Rotate (simple rotation about a unit vector).
   (10) %--------------------------------------------------------------------
   (11) Variable   theta''
   (12) C.Rotate( B, GetUnitVector( Bx> + By> ),  theta )
-> (13) C_B[1,1] = 0.5 + 0.5*cos(theta)
-> (14) C_B[1,2] = 0.5 - 0.5*cos(theta)
-> (15) C_B[1,3] = -0.7071068*sin(theta)
-> (16) C_B[2,1] = 0.5 - 0.5*cos(theta)
-> (17) C_B[2,2] = 0.5 + 0.5*cos(theta)
-> (18) C_B[2,3] = 0.7071068*sin(theta)
-> (19) C_B[3,1] = 0.7071068*sin(theta)
-> (20) C_B[3,2] = -0.7071068*sin(theta)
-> (21) C_B[3,3] = cos(theta)
-> (22) w_C_B> = 0.7071068*theta'*Bx> + 0.7071068*theta'*By>
-> (23) alf_C_B> = 0.7071068*theta''*Bx> + 0.7071068*theta''*By>

   (24) %--------------------------------------------------------------------
   (25) % Example 3: Rotate (successive Body-fixed rotations with 3 angles).
   (26) %--------------------------------------------------------------------
   (27) Variable   q1'', q2'', q3''
   (28) D.Rotate( C, BodyXYZ,   q1, q2, q3 )                 
-> (29) D_C[1,1] = cos(q2)*cos(q3)
-> (30) D_C[1,2] = sin(q3)*cos(q1) + sin(q1)*sin(q2)*cos(q3)
-> (31) D_C[1,3] = sin(q1)*sin(q3) - sin(q2)*cos(q1)*cos(q3)
-> (32) D_C[2,1] = -sin(q3)*cos(q2)
-> (33) D_C[2,2] = cos(q1)*cos(q3) - sin(q1)*sin(q2)*sin(q3)
-> (34) D_C[2,3] = sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1)
-> (35) D_C[3,1] = sin(q2)
-> (36) D_C[3,2] = -sin(q1)*cos(q2)
-> (37) D_C[3,3] = cos(q1)*cos(q2)
-> (38) w_D_C> = (sin(q3)*q2'+cos(q2)*cos(q3)*q1')*Dx> + (cos(q3)*q2'-sin(q3)*
        cos(q2)*q1')*Dy> + (q3'+sin(q2)*q1')*Dz>

-> (39) alf_D_C> = (cos(q3)*q2'*q3'+sin(q3)*q2''+cos(q2)*cos(q3)*q1''-sin(q2)*
        cos(q3)*q1'*q2'-sin(q3)*cos(q2)*q1'*q3')*Dx> + (sin(q2)*sin(q3)*q1'*q2'
        +cos(q3)*q2''-sin(q3)*q2'*q3'-cos(q2)*cos(q3)*q1'*q3'-sin(q3)*cos(q2)*
        q1'')*Dy> + (cos(q2)*q1'*q2'+q3''+sin(q2)*q1'')*Dz>

   (40) %--------------------------------------------------------------------
   (41) % Example 4: Rotate (Euler parameters / quaternions).
   (42) %--------------------------------------------------------------------
   (43) Variable  e0'', e1'', e2'', e3''
   (44) E.Rotate( D,  EulerParameters, e0, e1, e2, e3 )
-> (45) E_D[1,1] = -1 + 2*e0^2 + 2*e1^2
-> (46) E_D[1,2] = 2*e0*e3 + 2*e1*e2
-> (47) E_D[1,3] = 2*e1*e3 - 2*e0*e2
-> (48) E_D[2,1] = 2*e1*e2 - 2*e0*e3
-> (49) E_D[2,2] = -1 + 2*e0^2 + 2*e2^2
-> (50) E_D[2,3] = 2*e0*e1 + 2*e2*e3
-> (51) E_D[3,1] = 2*e0*e2 + 2*e1*e3
-> (52) E_D[3,2] = 2*e2*e3 - 2*e0*e1
-> (53) E_D[3,3] = -1 + 2*e0^2 + 2*e3^2
-> (54) w_E_D> = (2*e0*e1'+2*e3*e2'-2*e1*e0'-2*e2*e3')*Ex> + (2*e0*e2'+2*e1*e3'
        -2*e2*e0'-2*e3*e1')*Ey> + (2*e0*e3'+2*e2*e1'-2*e1*e2'-2*e3*e0')*Ez>

-> (55) alf_E_D> = (2*e0*e1''+2*e3*e2''-2*e1*e0''-2*e2*e3'')*Ex> + (2*e0*e2''+2
        *e1*e3''-2*e2*e0''-2*e3*e1'')*Ey> + (2*e0*e3''+2*e2*e1''-2*e1*e2''-2*
        e3*e0'')*Ez>

   (56) %--------------------------------------------------------------------
   (57) % Example 5: Rotate (Rodrigues parameters / Gibbs vector).
   (58) %--------------------------------------------------------------------
   (59) Variable  rho0'', rho1'', rho2''
   (60) F.Rotate( E,  RodriguesParameters, rho0, rho1, rho2 )
-> (61) F_E[1,1] = (1+rho0^2-rho1^2-rho2^2)/(1+rho0^2+rho1^2+rho2^2)
-> (62) F_E[1,2] = 2*(rho2+rho0*rho1)/(1+rho0^2+rho1^2+rho2^2)
-> (63) F_E[1,3] = -2*(rho1-rho0*rho2)/(1+rho0^2+rho1^2+rho2^2)
-> (64) F_E[2,1] = -2*(rho2-rho0*rho1)/(1+rho0^2+rho1^2+rho2^2)
-> (65) F_E[2,2] = (1+rho1^2-rho0^2-rho2^2)/(1+rho0^2+rho1^2+rho2^2)
-> (66) F_E[2,3] = 2*(rho0+rho1*rho2)/(1+rho0^2+rho1^2+rho2^2)
-> (67) F_E[3,1] = 2*(rho1+rho0*rho2)/(1+rho0^2+rho1^2+rho2^2)
-> (68) F_E[3,2] = -2*(rho0-rho1*rho2)/(1+rho0^2+rho1^2+rho2^2)
-> (69) F_E[3,3] = -(-1+rho0^2+rho1^2-rho2^2)/(1+rho0^2+rho1^2+rho2^2)
-> (70) w_F_E> = -2*(rho1*rho2'-rho0'-rho2*rho1')/(1+rho0^2+rho1^2+rho2^2)*Fx>
        + 2*(rho1'+rho0*rho2'-rho2*rho0')/(1+rho0^2+rho1^2+rho2^2)*Fy> - 2*(rh
        o0*rho1'-rho2'-rho1*rho0')/(1+rho0^2+rho1^2+rho2^2)*Fz>

-> (71) alf_F_E> = 2*(2*(rho0*rho0'+rho1*rho1'+rho2*rho2')*(rho1*rho2'-rho0'-
        rho2*rho1')-(1+rho0^2+rho1^2+rho2^2)*(rho1*rho2''-rho0''-rho2*rho1''))/
        (1+rho0^2+rho1^2+rho2^2)^2*Fx> - 2*(2*(rho0*rho0'+rho1*rho1'+rho2*rho2')
        *(rho1'+rho0*rho2'-rho2*rho0')-(1+rho0^2+rho1^2+rho2^2)*(rho1''+rho0*
        rho2''-rho2*rho0''))/(1+rho0^2+rho1^2+rho2^2)^2*Fy> + 2*(2*(rho0*rho0'+
        rho1*rho1'+rho2*rho2')*(rho0*rho1'-rho2'-rho1*rho0')-(1+rho0^2+rho1^2+rho2^2)
        *(rho0*rho1''-rho2''-rho1*rho0''))/(1+rho0^2+rho1^2+rho2^2)^2*Fz>

   (72) %--------------------------------------------------------------------
   (73) % Example 6: RotateX (simple rotation about Gx> = Fx>).
   (74) %--------------------------------------------------------------------
   (75) G.RotateX( F,  theta )
-> (76) G_F = [1, 0, 0;  0, cos(theta), sin(theta);  0, -sin(theta), cos(theta)]
-> (77) w_G_F> = theta'*Gx>
-> (78) alf_G_F> = theta''*Gx>

   (79) %--------------------------------------------------------------------
   (80) % Note: For more HELP, try:   RotateX   RotateY   RotateZ


</PRE><nobr><a name="RotateX"><font color="darkBlue"><font size=+1><b>RotateX</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
RotateX    RotateNegativeX      (RotatePositiveX is identical to RotateX)

 Purpose:  Forms the rotation matrix (direction cosine matrix) associated
           with the right-handed rotation of a rigid basis (e.g., B) in
           another rigid basis (e.g., A).  Tries to form B's angular
           velocity/acceleration in A and in the NewtonianFrame.

Syntax 1:  B.RotateX( A, q )
Syntax 2:  B.RotateX( A, q, u )
Syntax 3:  B.RotateNegativeX( A, q )
Syntax 4:  B.RotateNegativeX( A, q, u )

   Input:  B, A -- name of a RigidFrame or RigidBody.
           q -- expression for an angle.
           u -- name of an angular velocity variable.

Output 1:  Sets and returns the B_A rotation matrix formed by a right-handed
           rotation of B relative to A about  Ax> = Bx>  by the angle q.

           B's angular velocity and angular acceleration in A
           are also formed if q can be time differentiated.

           B's angular velocity and angular acceleration in the NewtonianFrame
           are also formed if a NewtonianFrame was declared and A's angular
           velocity/acceleration in the NewtonianFrame are in the workspace.

Output 2:  Same as Output 1, except tries to form an ODE relating q' to u that
           allows for more efficient angular velocity/acceleration expressions.

Output 3:  Same as Output 1, except B rotates about  -Ax> = -Bx>.

 Related:  <a href="#Rotate"><b>Rotate</b></a>  <a href="#RotateX"><b>RotateX</b></a>  <a href="#RotateY"><b>RotateY</b></a>  <a href="#RotateZ"><b>RotateZ</b></a>
           <a href="#RotateX"><b>RotateNegativeX</b></a>  <a href="#RotateY"><b>RotateNegativeY</b></a>  <a href="#RotateZ"><b>RotateNegativeZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixY</b></a>  <a href="#SetRotationMatrixZ"><b>SetRotationMatrixZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixNegativeX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixNegativeY</b></a>  ...
           <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>  <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>  <a href="#SetAngularAcceleration"><b>SetAngularAcceleration</b></a>
           <a href="#GetRotationMatrix"><b>GetRotationMatrix</b></a>  <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>  <a href="#GetAngularAcceleration"><b>GetAngularAcceleration</b></a>
           <a href="#SetRotationMatrixODE"><b>SetRotationMatrixODE</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  RotateX   (with angle)
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N
   (5) RigidFrame     A
   (6) Variable       qA''
   (7) A.RotateX( N, qA )
-> (8) A_N = [1, 0, 0;  0, cos(qA), sin(qA);  0, -sin(qA), cos(qA)]
-> (9) w_A_N> = qA'*Ax>
-> (10) alf_A_N> = qA''*Ax>

   (11) %--------------------------------------------------------------------
   (12) % Example 2:  RotateNegativeX   (with angle and rate)
   (13) %--------------------------------------------------------------------
   (14) RigidFrame    B
   (15) Variable      qB'', wB'
   (16) B.RotateNegativeX( A, qB, wB )
-> (17) B_A = [1, 0, 0;  0, cos(qB), -sin(qB);  0, sin(qB), cos(qB)]
-> (18) qB' = wB + qA'
-> (19) w_B_A> = -qB'*Bx>
-> (20) w_B_N> = -wB*Ax>
-> (21) qB'' = wB' + qA''
-> (22) alf_B_A> = -qB''*Bx>
-> (23) alf_B_N> = -wB'*Bx>

   (24) %--------------------------------------------------------------------
   (25) % Note: For more HELP, try:   Rotate   RotateX   RotateY   RotateZ


</PRE><nobr><a name="RotateY"><font color="darkBlue"><font size=+1><b>RotateY</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
RotateY    RotateNegativeY      (RotatePositiveY is identical to RotateY)

 Purpose:  Forms the rotation matrix (direction cosine matrix) associated
           with the right-handed rotation of a rigid basis (e.g., B) in
           another rigid basis (e.g., A).  Tries to form B's angular
           velocity/acceleration in A and in the NewtonianFrame.

Syntax 1:  B.RotateY( A, q )
Syntax 2:  B.RotateY( A, q, u )
Syntax 3:  B.RotateNegativeY( A, q )
Syntax 4:  B.RotateNegativeY( A, q, u )

   Input:  B, A -- name of a RigidFrame or RigidBody.
           q -- expression for an angle.
           u -- name of an angular velocity variable.

Output 1:  Sets and returns the B_A rotation matrix formed by a right-handed
           rotation of B relative to A about  Ay> = By>  by the angle q.

           B's angular velocity and angular acceleration in A
           are also formed if q can be time differentiated.

           B's angular velocity and angular acceleration in the NewtonianFrame
           are also formed if a NewtonianFrame was declared and A's angular
           velocity/acceleration in the NewtonianFrame are in the workspace.

Output 2:  Same as Output 1, except tries to form an ODE relating q' to u that
           allows for more efficient angular velocity/acceleration expressions.

Output 3:  Same as Output 1, except B rotates about  -Ay> = -By>.

 Related:  <a href="#Rotate"><b>Rotate</b></a>  <a href="#RotateX"><b>RotateX</b></a>  <a href="#RotateY"><b>RotateY</b></a>  <a href="#RotateZ"><b>RotateZ</b></a>
           <a href="#RotateX"><b>RotateNegativeX</b></a>  <a href="#RotateY"><b>RotateNegativeY</b></a>  <a href="#RotateZ"><b>RotateNegativeZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixY</b></a>  <a href="#SetRotationMatrixZ"><b>SetRotationMatrixZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixNegativeX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixNegativeY</b></a>  ...
           <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>  <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>  <a href="#SetAngularAcceleration"><b>SetAngularAcceleration</b></a>
           <a href="#GetRotationMatrix"><b>GetRotationMatrix</b></a>  <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>  <a href="#GetAngularAcceleration"><b>GetAngularAcceleration</b></a>
           <a href="#SetRotationMatrixODE"><b>SetRotationMatrixODE</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  RotateY   (with angle)
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N
   (5) RigidFrame     A
   (6) Variable       qA''
   (7) A.RotateY( N, qA )
-> (8) A_N = [cos(qA), 0, -sin(qA);  0, 1, 0;  sin(qA), 0, cos(qA)]
-> (9) w_A_N> = qA'*Ay>
-> (10) alf_A_N> = qA''*Ay>

   (11) %--------------------------------------------------------------------
   (12) % Example 2:  RotateNegativeY   (with angle and rate)
   (13) %--------------------------------------------------------------------
   (14) RigidFrame    B
   (15) Variable      qB'', wB'
   (16) B.RotateNegativeY( A, qB, wB )
-> (17) B_A = [cos(qB), 0, sin(qB);  0, 1, 0;  -sin(qB), 0, cos(qB)]
-> (18) qB' = wB + qA'
-> (19) w_B_A> = -qB'*By>
-> (20) w_B_N> = -wB*Ay>
-> (21) qB'' = wB' + qA''
-> (22) alf_B_A> = -qB''*By>
-> (23) alf_B_N> = -wB'*By>

   (24) %--------------------------------------------------------------------
   (25) % Note: For more HELP, try:   Rotate   RotateX   RotateY   RotateZ


</PRE><nobr><a name="RotateZ"><font color="darkBlue"><font size=+1><b>RotateZ</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
RotateZ    RotateNegativeZ      (RotatePositiveZ is identical to RotateZ)

 Purpose:  Forms the rotation matrix (direction cosine matrix) associated
           with the right-handed rotation of a rigid basis (e.g., B) in
           another rigid basis (e.g., A).  Tries to form B's angular
           velocity/acceleration in A and in the NewtonianFrame.

Syntax 1:  B.RotateZ( A, q )
Syntax 2:  B.RotateZ( A, q, u )
Syntax 3:  B.RotateNegativeZ( A, q )
Syntax 4:  B.RotateNegativeZ( A, q, u )

   Input:  B, A -- name of a RigidFrame or RigidBody.
           q -- expression for an angle.
           u -- name of an angular velocity variable.

Output 1:  Sets and returns the B_A rotation matrix formed by a right-handed
           rotation of B relative to A about  Az> = Bz>  by the angle q.

           B's angular velocity and angular acceleration in A
           are also formed if q can be time differentiated.

           B's angular velocity and angular acceleration in the NewtonianFrame
           are also formed if a NewtonianFrame was declared and A's angular
           velocity/acceleration in the NewtonianFrame are in the workspace.

Output 2:  Same as Output 1, except tries to form an ODE relating q' to u that
           allows for more efficient angular velocity/acceleration expressions.

Output 3:  Same as Output 1, except B rotates about  -Az> = -Bz>.

 Related:  <a href="#Rotate"><b>Rotate</b></a>  <a href="#RotateX"><b>RotateX</b></a>  <a href="#RotateY"><b>RotateY</b></a>  <a href="#RotateZ"><b>RotateZ</b></a>
           <a href="#RotateX"><b>RotateNegativeX</b></a>  <a href="#RotateY"><b>RotateNegativeY</b></a>  <a href="#RotateZ"><b>RotateNegativeZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixY</b></a>  <a href="#SetRotationMatrixZ"><b>SetRotationMatrixZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixNegativeX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixNegativeY</b></a>  ...
           <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>  <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>  <a href="#SetAngularAcceleration"><b>SetAngularAcceleration</b></a>
           <a href="#GetRotationMatrix"><b>GetRotationMatrix</b></a>  <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>  <a href="#GetAngularAcceleration"><b>GetAngularAcceleration</b></a>
           <a href="#SetRotationMatrixODE"><b>SetRotationMatrixODE</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  RotateZ   (with angle)
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N
   (5) RigidFrame     A
   (6) Variable       qA''
   (7) A.RotateZ( N, qA )
-> (8) A_N = [cos(qA), sin(qA), 0;  -sin(qA), cos(qA), 0;  0, 0, 1]
-> (9) w_A_N> = qA'*Az>
-> (10) alf_A_N> = qA''*Az>

   (11) %--------------------------------------------------------------------
   (12) % Example 2:  RotateNegativeZ   (with angle and rate)
   (13) %--------------------------------------------------------------------
   (14) RigidFrame    B
   (15) Variable      qB'', wB'
   (16) B.RotateNegativeZ( A, qB, wB )
-> (17) B_A = [cos(qB), -sin(qB), 0;  sin(qB), cos(qB), 0;  0, 0, 1]
-> (18) qB' = wB + qA'
-> (19) w_B_A> = -qB'*Bz>
-> (20) w_B_N> = -wB*Az>
-> (21) qB'' = wB' + qA''
-> (22) alf_B_A> = -qB''*Bz>
-> (23) alf_B_N> = -wB'*Bz>

   (24) %--------------------------------------------------------------------
   (25) % Note: For more HELP, try:   Rotate   RotateX   RotateY   RotateZ


</PRE><nobr><a name="Run"><font color="darkBlue"><font size=+1><b>Run</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Run

 Purpose:  Reads (loads) a file containing a sequence of program commands.

Syntax 1:  Run FileName.txt
Syntax 2:  Run

Output 1:  Execution of commands in the file named FileName.txt
           The file name extension should be  .txt  or  .al

Output 2:  Continued execution of lines in a command file that follow
           a line or error that previously caused execution to halt.

  Remark:  FileName.txt is the name of a command file located in the:
           (a) Current working directory
           (b) Directory specified via a relative path
           (c) Directory specified via an absolute path

           For example, valid commands include:
           Run Pendulum.txt
           Run ..\PendulumDirectory\Pendulum.txt   (PC/Windows)
           Run ../PendulumDirectory/Pendulum.txt   (Unix/Macintosh)
           Run \PendulumDirectory\Pendulum.txt     (PC/Windows)
           Run /PendulumDirectory/Pendulum.txt     (Unix/Macintosh)

  Remark:  Command files should be named with the extension  .txt  or  .al
           Just typing  FileName.txt   is identical to   Run FileName.txt

  Remark:  The Run command can be used within one command file to start
           execution of other command files.

  Remark:  Command files are ASCII text files with line breaks.
           Use a text editor or do a proper Save-As in a word processor.

 Related:  <a href="#!"><b>!</b></a>  <a href="#%"><b>%</b></a>  <a href="#&"><b>&</b></a>  <a href="#Clear"><b>Clear</b></a>  <a href="#Save"><b>Save</b></a>  <a href="#Run"><b>Run</b></a>  <a href="#Quit"><b>Quit</b></a>  <a href="#if"><b>if</b></a>  <a href="#if"><b>else</b></a>  <a href="#if"><b>elseif</b></a>

--------------------------------------------------------------------
 Example:  Prepare the file "Test.txt" in ASCII text format as follows.
--------------------------------------------------------------------
          % Test.txt
          a = 1 + 2 + pi + 3*t + 4*t

--------------------------------------------------------------------
 At the MotionGenesis command prompt, type:  Run Test.txt
--------------------------------------------------------------------

   (1) % Run.al
   (2) a = 1 + 2 + pi + 3*t + 4*t 
-> (3) a = 6.141593 + 7*t



</PRE><nobr><a name="Save"><font color="darkBlue"><font size=+1><b>Save</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Save  SaveOverwrite  (or Print)

 Purpose:  Creates a text file containing input or input and output.
           To print the file, open it with a text editor and print.

Syntax 1:  Save FileName.txt
           Save FileName.txt,  m
           Save FileName.txt,  m:n
Syntax 2:  Save FileName.all
Syntax 3:  Save FileName.html
           Save FileName.html,  m
           Save FileName.html,  m:n

   Input:  FileName.txt  -- a file whose extension is .txt or .al
           FileName.all  -- a file whose extension is .all
           FileName.html -- a file whose extension is .html or .htm

           m -- the line number of the first line to be saved
           n -- the line number of the last  line to be saved
                the default value for n is the last line.

Output 1:  Creates a text file containing input lines only.
Output 2:  Creates a text file containing input and program responses.
Output 3:  Creates a html file containing input and program responses.

  Remark:  SaveOverwrite abc.html  overwrites abc.html (no prompt to user).

   Print:  To print a text file, open the file in a text editor
           (e.g., NotePad, TextWrangler, TextEdit, SimpleText, Emacs)
           or word-processor with Courier font (e.g., Microsoft Word)
           and print the file from within that program.

  Remark:  It is usually more efficient to use a text editor to
           create a command file and then use the Run command.

           If you instead choose to enter commands at the program prompt,
           save your commands with Save FileName.txt (not FileName.html).

  Remark:  FileName.txt is the name of a file to be located in the:
           (a) Current working directory
           (b) Directory specified via a relative path
           (c) Directory specified via an absolute path

           For example, valid commands include:
           Save Pendulum.txt
           Save ..\PendulumDirectory\Pendulum.txt   (PC/Windows)
           Save C:\PendulumDirectory\Pendulum.txt   (PC/Windows)
           Save ../PendulumDirectory/Pendulum.txt   (Unix/Macintosh)
           Save /PendulumDirectory/Pendulum.txt     (Unix/Macintosh)

 Related:  <a href="#!"><b>!</b></a>  <a href="#%"><b>%</b></a>  <a href="#&"><b>&</b></a>  <a href="#Clear"><b>Clear</b></a>  <a href="#Save"><b>Save</b></a>  <a href="#Save"><b>Print</b></a>  <a href="#Run"><b>Run</b></a>  <a href="#Quit"><b>Quit</b></a>

--------------------------------------------------------------------
 Example:  Type the following commands at the program prompt.
--------------------------------------------------------------------
 a = 2 + 2
 b = 3 + 3
 Save SaveExample.txt
 Save SaveExample.all
 Save SaveExample.html
 Quit
--------------------------------------------------------------------
 SaveExample.txt contains the following:
--------------------------------------------------------------------
 a = 2 + 2
 b = 3 + 3
--------------------------------------------------------------------
 SaveExample.all and SaveExample.html contain the following:
--------------------------------------------------------------------
    (1) a = 2 + 2
 -> (2) a = 4

    (3) b = 3 + 3
 -> (4) b = 6



</PRE><nobr><a name="SetScratchDirectory"><font color="darkBlue"><font size=+1><b>SetScratchDirectory</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetScratchDirectory

 Purpose:  Specifies the operating system path to the directory
           used by the program for scratch files.

           PC/Windows:
           SetScratchDirectory C:\TempFolder

           MAC/Unix:
           SetScratchDirectory /TempFolder

  Remark:  To set the scratch directory, edit the MGDefaultPreferences.txt
           file that resides in the MotionGenesis MGToolbox folder.
           The previous examples show how to specify an existing folder
           on the computer's (hard) drive as the scratch directory.

  Remark:  If the scratch directory is not set (or is set improperly),
           scratch files are written to the current working directory.

  Remark:  The comment symbol % should not appear after SetScratchDirectory.

 Related:  <a href="#GetDefaults"><b>GetDefaults</b></a>  <a href="#SetWorkingDirectory"><b>GetWorkingDirectory</b></a>  <a href="#SetWorkingDirectory"><b>SetWorkingDirectory</b></a>
           <a href="#GetEnvironmentValue"><b>GetEnvironmentValue</b></a>   <a href="#SetScratchDirectory"><b>SetScratchDirectory</b></a>



</PRE><nobr><a name="SetWorkingDirectory"><font color="darkBlue"><font size=+1><b>SetWorkingDirectory</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetWorkingDirectory   GetWorkingDirectory

 Purpose:  Specifies the operating system path to write files.

Syntax 1:  SetWorkingDirectory( pathToFolder )
Syntax 2:  GetWorkingDirectory()

           PC/Windows:
           SetWorkingDirectory( C:\MotionGenesis )
           SetWorkingDirectory( "C:\Documents and Settings\Paul" )

           MAC/Unix:
           SetWorkingDirectory( /MotionGenesis )
           SetWorkingDirectory( /Paul/Mechanics/Simulations )

  Remark:  The syntax for pathToFolder depends on the operating system.
           The previous examples show how to specify an existing folder
           on the computer's (hard) drive as the working directory.

  Remark:  Alternately, edit the file  MGDefaultPreferences.txt
           that resides in the MotionGenesis MGToolbox folder.

 Related:  <a href="#GetDefaults"><b>GetDefaults</b></a>  <a href="#SetWorkingDirectory"><b>GetWorkingDirectory</b></a>  <a href="#SetWorkingDirectory"><b>SetWorkingDirectory</b></a>
           <a href="#GetEnvironmentValue"><b>GetEnvironmentValue</b></a>   <a href="#SetScratchDirectory"><b>SetScratchDirectory</b></a>



</PRE><nobr><a name="SetAcceleration"><font color="darkBlue"><font size=+1><b>SetAcceleration</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetAcceleration

 Purpose:  Sets a point's acceleration in a reference frame.

Syntax 1:  Q.SetAcceleration( N, fromPoint )
Syntax 2:  Q.SetAcceleration( N, fromPoint, BFixed )
Syntax 3:  Q.SetAcceleration( N, fromPoint, BFrame, BQ )
Syntax 4:  Q.SetAcceleration( N, accelerationVector )

   Input:  Q -- name of a Point.
           N -- name of a RigidFrame or RigidBody.

           fromPoint -- Point whose velocity in N is already known.

           BFixed -- Rigid frame/body on which fromPoint and Q  are fixed.
           BFrame -- Rigid frame/body on which fromPoint and BQ are fixed.
                     Q is moving on BFrame.

           BQ -- Point of BFrame that is coincident with Q.

           accelerationVector -- an acceleration vector.

  Output:  Sets and returns Q's acceleration in N.

  Remark:  Syntax 2 may also set the following (if not in workspace):
             fromPoint's velocity and acceleration in BFixed to 0>
             Q's         velocity and acceleration in BFixed to 0>

           Syntax 3 may also set the following (if not in workspace):
             fromPoint's velocity and acceleration in BFrame to 0>
             BQ          may be defined as a physical point of BFrame
             BQ's        velocity and acceleration in BFrame to 0>
             BQ's        position from fromPoint
             Q's         velocity in BFrame (via Q' position vector fromPoint)
             Q's         acceleration in BFrame (via differentiation)

  Remark:  Q's position vector fromPoint is used by this command.

  Remark:  If Q is welded to rigid frame/body B, declare it:  Point Q(B).
           Alternately, if Q does not move on B (but is not welded or a
           physical point of B), use Q.SetVelocityAcceleration( B, 0> )

 Related:  <a href="#Translate"><b>Translate</b></a>        <a href="#SetPositionVelocity"><b>SetPositionVelocity</b></a>   <a href="#SetVelocityAcceleration"><b>SetVelocityAcceleration</b></a>
           <a href="#SetPosition"><b>SetPosition</b></a>      <a href="#GetPosition"><b>GetPosition</b></a>   <a href="#GetDistance"><b>GetDistance</b></a>  <a href="#GetDistance"><b>GetDistanceSquared</b></a>
           <a href="#SetVelocity"><b>SetVelocity</b></a>      <a href="#GetVelocity"><b>GetVelocity</b></a>   <a href="#GetSpeed"><b>GetSpeed</b></a>     <a href="#GetElongation"><b>GetElongation</b></a>
           <a href="#SetAcceleration"><b>SetAcceleration</b></a>  <a href="#GetAcceleration"><b>GetAcceleration</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: SetAcceleration 
   (3) % Set Q1's acceleration in N by differentiation.  Uses No fixed on N 
   (4) %--------------------------------------------------------------------
   (5) RigidFrame N             
   (6) Point      Q1            
   (7) Variable   x1'', y1''           
   (8) Q1.SetPosition( No,  x1*Nx> + y1*Ny> )
-> (9) p_No_Q1> = x1*Nx> + y1*Ny>

   (10) Q1.SetAcceleration( N, No )   
-> (11) a_Q1_N> = x1''*Nx> + y1''*Ny>

   (12) %--------------------------------------------------------------------
   (13) % Example 2: SetAcceleration 
   (14) % Set Q2's acceleration in N by differentiation and Q1's acceleration
   (15) %--------------------------------------------------------------------
   (16) Point     Q2            
   (17) Variable  x2'', y2''  
   (18) Q2.SetPosition( Q1,  x2*Nx> + y2*Ny> )
-> (19) p_Q1_Q2> = x2*Nx> + y2*Ny>

   (20) Q2.SetAcceleration( N, Q1 )     
-> (21) a_Q2_N> = (x1''+x2'')*Nx> + (y1''+y2'')*Ny>

   (22) %--------------------------------------------------------------------
   (23) % Example 3: SetAcceleration
   (24) % Set Q3's acceleration in N via two points (Q3 and Bo) fixed on B.
   (25) %--------------------------------------------------------------------
   (26) RigidBody B                  % Body B translates and rotates in N.
   (27) Point     Q3( B )            % Q3 is a point fixed on B.
   (28) Constant  L                  % Distance between Bo and Q3.
   (29) Variable  wB'                % Angular rate and its time-derivative.
   (30) B.SetAngularVelocityAcceleration( N,  wB*Bz> )
-> (31) w_B_N> = wB*Bz>
-> (32) alf_B_N> = wB'*Bz>

   (33) Bo.SetAcceleration( N,  t*Nx> )
-> (34) a_Bo_N> = t*Nx>

   (35) Q3.SetPosition( Bo,  L*Bx> )
-> (36) p_Bo_Q3> = L*Bx>

   (37) Q3.SetAcceleration( N, Bo, B )  
-> (38) a_Q3_N> = -L*wB^2*Bx> + L*wB'*By> + t*Nx>

   (39) %--------------------------------------------------------------------
   (40) % Example 4: SetAcceleration
   (41) % Set Q4's acceleration in N via one point (Q4) moving on rigid-body B
   (42) %--------------------------------------------------------------------
   (43) Point      Q4,  BQ4( B )     % BQ4 is point of B coincident with Q4.
   (44) Variable   x4''  
   (45) Q4.SetPosition( Bo,  x4*Bx> )
-> (46) p_Bo_Q4> = x4*Bx>

   (47) Q4.SetAcceleration( N, Bo, B, BQ4 )    
-> (48) p_Bo_BQ4> = x4*Bx>
-> (49) a_BQ4_N> = -x4*wB^2*Bx> + x4*wB'*By> + t*Nx>
-> (50) v_Q4_B> = x4'*Bx>
-> (51) a_Q4_B> = x4''*Bx>
-> (52) a_Q4_N> = (x4''-x4*wB^2)*Bx> + (x4*wB'+2*wB*x4')*By> + t*Nx>



</PRE><nobr><a name="SetAngularAcceleration"><font color="darkBlue"><font size=+1><b>SetAngularAcceleration</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetAngularAcceleration

 Purpose:  Sets a reference frame's angular acceleration.

Syntax 1:  B.SetAngularAcceleration( N, angularAccelerationVector )
Syntax 2:  B.SetAngularAcceleration( N )

   Input:  B, N -- name of a RigidFrame or RigidBody.
           angularAccelerationVector -- an angular acceleration vector.

Output 1:  Sets and returns B's angular acceleration in N.
Output 2:  Calculates, sets and returns B's angular acceleration in N.

 Related:  <a href="#GetAngularAcceleration"><b>GetAngularAcceleration</b></a>  <a href="#Rotate"><b>Rotate</b></a>  <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>  <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: SetAngularAcceleration.al 
   (3) %--------------------------------------------------------------------
   (4) RigidFrame N             
   (5) RigidBody  A, B
   (6) Variable   wx', wy', wz',  w1', w2', w3'
   (7) A.SetAngularVelocityAcceleration( N, wx*Ax> + wy*Ay> + wz*Az> )
-> (8) w_A_N> = wx*Ax> + wy*Ay> + wz*Az>
-> (9) alf_A_N> = wx'*Ax> + wy'*Ay> + wz'*Az>

   (10) B.SetAngularVelocityAcceleration( A, w1*Ax> + w2*Ay> + w3*Az> )
-> (11) w_B_A> = w1*Ax> + w2*Ay> + w3*Az>
-> (12) alf_B_A> = w1'*Ax> + w2'*Ay> + w3'*Az>

   (13) B.SetAngularAcceleration( N )
-> (14) alf_B_N> = (w3*wy+w1'+wx'-w2*wz)*Ax> + (w1*wz+w2'+wy'-w3*wx)*Ay> + (w2*
        wx+w3'+wz'-w1*wy)*Az>



</PRE><nobr><a name="SetAngularVelocity"><font color="darkBlue"><font size=+1><b>SetAngularVelocity</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetAngularVelocity

 Purpose:  Sets a reference frame's angular velocity.

Syntax 1:  B.SetAngularVelocity( N, angularVelocityVector )
Syntax 2:  B.SetAngularVelocity( A, SequenceI,   q1 )
Syntax 3:  B.SetAngularVelocity( A, SequenceIJ,  q1, q2 )
Syntax 4:  B.SetAngularVelocity( A, SequenceIJK, q1, q2, q3 )
Syntax 5:  B.SetAngularVelocity( A, EulerParameters, e0, e1, e2, e3 )
           B.SetAngularVelocity( A, Quaternion,      e0, e1, e2, e3 )
Syntax 6:  B.SetAngularVelocity( A, RodriguesParameters, rho1, rho2, rho3 )
Syntax 7:  B.SetAngularVelocity( A, matrix33 )
Syntax 8:  B.SetAngularVelocityFromRotationMatrix( N )
Syntax 9:  B.SetAngularVelocity( N )

   Input:  B, N -- name of a RigidFrame or RigidBody.

           angularVelocityVector -- an angular velocity vector.

           q1, q2, q3 -- angles (scalar expressions).

           SequenceI -- BodyI or SpaceI where I is X, -X, Y, -Y, Z, -Z, e.g.,
                          BodyX,  BodyY,  BodyZ,  -BodyX,  Body-Y, etc.
                         SpaceX, SpaceY, SpaceZ, -SpaceX, Space-Y, etc.

           SequenceIJ -- BodyIJ or Space IJ where I and J are appropriate
                         combinations of X, -X, Y, -Y, Z, -Z, e.g.,
                         BodyXY,  BodyXZ,  BodyYX,  BodyYZ,  BodyZX,  BodyZY
                        SpaceXY, SpaceXZ, SpaceYX, SpaceYZ, SpaceZX, SpaceZY
                        Body-XY,  BodyX-Z,  Body-Y-X, Space-XY, etc.

           SequenceIJK -- BodyIJK or SpaceIJK where I, J, K are appropriate
                          combinations of X, -X, Y, -Y, Z, -Z, e.g.,
                   BodyXYZ,  BodyYZX,  BodyZXY,  BodyXZY,  BodyYXZ,  BodyZYX
                   BodyXYX,  BodyXZX,  BodyYXY,  BodyYZY,  BodyZXZ,  BodyZYZ
                  SpaceXYZ, SpaceYZX, SpaceZXY, SpaceXZY, SpaceYXZ, SpaceZYX
                  SpaceXYX, SpaceXZX, SpaceYXY, SpaceYZY, SpaceZXZ, SpaceZYZ
                  Body-XYZ, BodyX-YZ, BodyXY-Z, Body-X-YZ,  Space-X-Y-Z, etc.

           e0, e1, e2, e3 -- expressions for Euler parameters (quaternion).

           rho1, rho2, rho3 -- expressions for Rodrigues parameters.

           Rxx,Rxy,Rxz, Ryx,Ryy,Ryz, Rzx,Rzy,Rzz - expressions for elements.

           matrix33 -- 3x3 rotation matrix (direction cosine matrix).

 Output:   Calculates, sets, and returns B's angular velocity in N.
 Output 8: Calculates the B_N rotation matrix and calls Syntax 7.
 Output 9: Calculates B's angular velocity in N by the angular velocity addition
           theorem and/or time-derivatives of rotation matrices.

  Remark:  Definitions of orientation angles, Euler parameters (quaternion),
           Rodrigues parameters, and direction cosines are in
           Kane, T. R.,  Likins, P. W.,  and Levinson D. A.,
           Spacecraft Dynamics, McGraw-Hill, 1983, Ch. 1., and
           Mitiguy, Paul, Advanced Dynamics for Professional
           Mechanical, Aerospace, and BioMechanical Engineers.

 Related:  <a href="#Rotate"><b>Rotate</b></a>  <a href="#RotateX"><b>RotateX</b></a>  <a href="#RotateY"><b>RotateY</b></a>  <a href="#RotateZ"><b>RotateZ</b></a>
           <a href="#RotateX"><b>RotateNegativeX</b></a>  <a href="#RotateY"><b>RotateNegativeY</b></a>  <a href="#RotateZ"><b>RotateNegativeZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixY</b></a>  <a href="#SetRotationMatrixZ"><b>SetRotationMatrixZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixNegativeX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixNegativeY</b></a>  ...
           <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>  <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>  <a href="#SetAngularAcceleration"><b>SetAngularAcceleration</b></a>
           <a href="#GetRotationMatrix"><b>GetRotationMatrix</b></a>  <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>  <a href="#GetAngularAcceleration"><b>GetAngularAcceleration</b></a>
           <a href="#SetRotationMatrixODE"><b>SetRotationMatrixODE</b></a>   <a href="#SetRigidTransform"><b>SetRigidTransform</b></a>
           <a href="#SetAngularVelocityAcceleration"><b>SetAngularVelocityAcceleration</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: SetAngularVelocity 
   (3) %--------------------------------------------------------------------
   (4) RigidFrame N             
   (5) RigidBody  A, B
   (6) Variable   wx, wy, wz,  w1, w2, w3
   (7) A.SetAngularVelocity( N, wx*Ax> + wy*Ay> + wz*Az> )
-> (8) w_A_N> = wx*Ax> + wy*Ay> + wz*Az>

   (9) B.SetAngularVelocity( A, w1*Bx> + w2*By> + w3*Bz> )
-> (10) w_B_A> = w1*Bx> + w2*By> + w3*Bz>

   (11) B.SetAngularVelocity( N )
-> (12) w_B_N> = wx*Ax> + wy*Ay> + wz*Az> + w1*Bx> + w2*By> + w3*Bz>



</PRE><nobr><a name="SetAngularVelocityAcceleration"><font color="darkBlue"><font size=+1><b>SetAngularVelocityAcceleration</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetAngularVelocityAcceleration

 Purpose:  Sets a reference frame's angular velocity and angular acceleration.

  Syntax:  B.SetAngularVelocityAcceleration( A, angularVelocityVector )

   Input:  B, A -- name of a RigidFrame or RigidBody.
           angularVelocityVector -- an angular velocity vector.

  Output:  Sets B's angular velocity in A and B's angular acceleration in A.
           If possible, sets B's angular velocity in the NewtonianFrame.
           If possible, sets B's angular acceleration in NewtonianFrame.

 Related:  <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>  <a href="#Rotate"><b>Rotate</b></a>  <a href="#SetAngularAcceleration"><b>SetAngularAcceleration</b></a>  <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: SetAngularVelocityAcceleration 
   (3) % Set A's angular velocity and acceleration in N. 
   (4) %--------------------------------------------------------------------
   (5) NewtonianFrame N             
   (6) RigidFrame     A
   (7) Variable       wx', wy', wz'
   (8) A.SetAngularVelocityAcceleration( N, wx*Ax> + wy*Ay> + wz*Az> )
-> (9) w_A_N> = wx*Ax> + wy*Ay> + wz*Az>
-> (10) alf_A_N> = wx'*Ax> + wy'*Ay> + wz'*Az>

   (11) %--------------------------------------------------------------------
   (12) % Example 2: SetAngularVelocityAcceleration 
   (13) % Set B's angular velocity and acceleration in both A and N. 
   (14) %--------------------------------------------------------------------
   (15) RigidFrame    B
   (16) Variable      wBA'
   (17) B.SetAngularVelocityAcceleration( A, wBA*Az> )
-> (18) w_B_A> = wBA*Az>
-> (19) w_B_N> = wx*Ax> + wy*Ay> + (wBA+wz)*Az>
-> (20) alf_B_A> = wBA'*Az>
-> (21) alf_B_N> = (wBA*wy+wx')*Ax> + (wy'-wBA*wx)*Ay> + (wBA'+wz')*Az>



</PRE><nobr><a name="SetAutoDifferentiate"><font color="darkBlue"><font size=+1><b>SetAutoDifferentiate</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetAutoDifferentiate

 Purpose:  Controls whether or not ordinary derivatives of quantities
           declared as a Variable or Specified are automatically calculated.
           In other words, controls whether or not y', y'', y''', etc.,
           are automatically calculated and assigned when y is assigned.

  Syntax:  SetAutoDifferentiate( SETTING )

   Input:  SETTING -- ON or OFF

  Output:  When SETTING is ON, the ordinary derivatives of y are
           automatically assigned when y is assigned, e.g.,
           y', y'', and y''' are assigned when y is assigned.

  Remark:  Program default is SetAutoDifferentiate( OFF ).

 Related:  <a href="#GetDefaults"><b>GetDefaults</b></a>   <a href="#SetAutoDifferentiate"><b>SetAutoDifferentiate</b></a>  <a href="#SetAutoOverwrite"><b>SetAutoOverwrite</b></a>
           <a href="#Solve"><b>Solve</b></a>  <a href="#SolveDt"><b>SolveDt</b></a>  <a href="#SolveSetInput"><b>SolveSetInput</b></a>  <a href="#SolveSetInputDt"><b>SolveSetInputDt</b></a>  ...
           <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRoot</b></a>  <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRootDt</b></a>  ...
           <a href="#SetDt"><b>SetDt</b></a>  <a href="#SetDt"><b>SetNoDt</b></a>   <a href="#="><b>=</b></a>   <a href="#="><b>:=</b></a>   <a href="#="><b>+=</b></a>   <a href="#="><b>*=</b></a>   <a href="#="><b>/=</b></a>   <a href="#="><b>^=</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  No automatic differentiation 
   (3) %--------------------------------------------------------------------
   (4) Variable  x'
   (5) SetAutoDifferentiate( OFF )
   (6) x = sin(t)
-> (7) x = sin(t)

   (8) SetDt( x = cos(t) )  
-> (9) x = cos(t)
-> (10) x' = -sin(t)

   (11) %--------------------------------------------------------------------
   (12) % Example 2:  Auto-differentiates y to assign  y'  and  y''
   (13) %--------------------------------------------------------------------
   (14) Variable  y''
   (15) SetAutoDifferentiate( ON )
   (16) y = t^3
-> (17) y = t^3
-> (18) y' = 3*t^2
-> (19) y'' = 6*t



</PRE><nobr><a name="SetAutoEpsilon"><font color="darkBlue"><font size=+1><b>SetAutoEpsilon</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetAutoEpsilon

 Purpose:  In every expression, rounds numbers suitably close to an integer.

Syntax 1:  SetAutoEpsilon( absEpsilon )
Syntax 2:  SetAutoEpsilon( absEpsilon, relEpsilon )
Syntax 3:  GetAutoEpsilonAbsolute()
Syntax 4:  GetAutoEpsilonRelative()

   Input:  absEpsilon a real number r such that:   0  <=  r  < 0.5
           relEpsilon a real number r such that:   0  <=  r  < 0.5

Output 1:  In expressions, rounds any number that is within absEpsilon of
           an integer to that integer.  For a number of the form  x.y,  no
           rounding occurs if  absEpsilon <  abs(0.y)  <  1 - absEpsilon

Output 2:  Rounds any number d within abs( d * relEpsilon) of an integer to
           that integer.  Also does the rounding described by Output 1.

Output 3:  The first argument previously set by SetAutoEpsilon (or 0).
Output 4:  The second argument previously set by SetAutoEpsilon (or 0).

  Remark:  Program default is SetAutoEpsilon( 0, 0 ), i.e., no rounding.
  Remark:  Use with caution.  AutoEpsilon has simplification side-effects.
           SetAutoEpsilon( 1.0E-14 )
           Expand( 2E-15 * t * (sin(t) + 3E+15 * t) )  simplifies to  6*t^2
                   2E-15 * t * (sin(t) + 3E+15 * t)    simplifies to  0.

 Related:  <a href="#Epsilon"><b>Epsilon</b></a>  <a href="#SetAutoEpsilon"><b>SetAutoEpsilon</b></a>  <a href="#SetDigits"><b>SetDigits</b></a>  <a href="#RoundDigits"><b>RoundDigits</b></a>  <a href="#GetDefaults"><b>GetDefaults</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Examples:  SetAutoEpsilon  
   (3) %--------------------------------------------------------------------
   (4) SetDigits 16
   (5) SetAutoEpsilon( 1.0E-14 )       % Absolute = 1.0E-14,  Relative = 0
   (6) v = 2E-11 + 1.00007*t + (9876 + 5E-8)*sin(t)
-> (7) v = 2E-11 + 1.00007*t + 9876.00000005*sin(t)

   (8) %--------------------------------------------------------------------
   (9) SetAutoEpsilon( 1.0E-10 )       % Absolute = 1.0E-10,  Relative = 0
   (10) w = 2E-11 + 1.00007*t + (9876 + 5E-8)*sin(t)
-> (11) w = 1.00007*t + 9876.00000005*sin(t)

   (12) %--------------------------------------------------------------------
   (13) SetAutoEpsilon( 0.0001 )        % Absolute = 1.0E-4,   Relative = 0
   (14) x = 2E-11 + 1.00007*t + (9876 + 5E-8)*sin(t)
-> (15) x = t + 9876*sin(t)

   (16) %--------------------------------------------------------------------
   (17) SetAutoEpsilon( 0, 1E-7 )       % Absolute = 0,       Relative = 1E-7
   (18) y = 2E-11 + 1.00007*t + (9876 + 5E-8)*sin(t)
-> (19) y = 2E-11 + 1.00007*t + 9876*sin(t)

   (20) %--------------------------------------------------------------------
   (21) SetAutoEpsilon( 0, 0.0001 )     % Absolute = 0,       Relative = 1E-4
   (22) z = 2E-11 + 1.00007*t + (9876 + 5E-8)*sin(t)
-> (23) z = 2E-11 + t + 9876*sin(t)

   (24) %--------------------------------------------------------------------
   (25) % Note: AutoEpsilon has side-effects due to simplification.
   (26) SetAutoEpsilon( 1.0E-14 )       % Absolute = 1.0E-14,  Relative = 0
   (27) a = Expand( 2E-15 * t * (sin(t) + 3E+15 * t) )
-> (28) a = 6*t^2

   (29) b =         2E-15 * t * (sin(t) + 3E+15 * t) 
-> (30) b = 0



</PRE><nobr><a name="SetAutoExpress"><font color="darkBlue"><font size=+1><b>SetAutoExpress</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetAutoExpress

 Purpose:  For each rigid body, determines whether the body's angular velocity
           and angular acceleration in the NewtonianFrame are automatically
           expressed in terms of the body's unit vectors or in terms of
           unit vectors associated with the body's inertia dyadic.

  Syntax:  SetAutoExpress( SETTING )

   Input:  SETTING -- ON or OFF

  Remark:  For a RigidBody B,  SetAutoExpress( ON )  affects B's angular
           velocity and angular acceleration in the NewtonianFrame
           only if B's central inertia dyadic has been set.

  Remark:  Program default is SetAutoExpress( ON ).

 Related:  <a href="#Express"><b>Express</b></a>  <a href="#GetDefaults"><b>GetDefaults</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  SetAutoExpress( OFF )
   (3) %--------------------------------------------------------------------
   (4) SetAutoExpress( OFF )
   (5) NewtonianFrame N
   (6) RigidBody B
   (7) Variable  qB''
   (8) B.SetRotationMatrixX( N, qB )
-> (9) B_N = [1, 0, 0;  0, cos(qB), sin(qB);  0, -sin(qB), cos(qB)]

   (10) B.SetAngularVelocityAcceleration( N, qB'*Nx> )
-> (11) w_B_N> = qB'*Nx>
-> (12) alf_B_N> = qB''*Nx>

   (13) %--------------------------------------------------------------------
   (14) % Example 2:  SetAutoExpress( ON )
   (15) %--------------------------------------------------------------------
   (16) SetAutoExpress( ON )
   (17) RigidBody C
   (18) Variable  qC''
   (19) C.SetInertia( Ccm, 3, 2, 1 )
   (20) C.SetRotationMatrixX( N, qC )
-> (21) C_N = [1, 0, 0;  0, cos(qC), sin(qC);  0, -sin(qC), cos(qC)]

   (22) C.SetAngularVelocityAcceleration( N, qC'*Nx> )
-> (23) w_C_N> = qC'*Cx>
-> (24) alf_C_N> = qC''*Cx>



</PRE><nobr><a name="SetAutoFactor"><font color="darkBlue"><font size=+1><b>SetAutoFactor</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetAutoFactor

 Purpose:  Determines whether or not to automatically factor expressions.

  Syntax:  SetAutoFactor( SETTING )

   Input:  SETTING -- ON or OFF

  Remark:  Program default is SetAutoFactor( ON ).

 Related:  <a href="#Factor"><b>Factor</b></a>  <a href="#GetDefaults"><b>GetDefaults</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  SetAutoFactor( OFF )
   (3) %--------------------------------------------------------------------
   (4) Constant  A,B,C
   (5) SetAutoFactor( OFF )
   (6) x = A*B + A*C + A*(B+C)^2
-> (7) x = A*B + A*C + A*(B+C)^2

   (8) %--------------------------------------------------------------------
   (9) % Example 2:  SetAutoFactor( ON )
   (10) %--------------------------------------------------------------------
   (11) SetAutoFactor( ON )
   (12) y = A*B + A*C + A*(B+C)^2
-> (13) y = A*(B+C+(B+C)^2)



</PRE><nobr><a name="SetAutoOverWrite"><font color="darkBlue"><font size=+1><b>SetAutoOverWrite</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetAutoOverWrite

 Purpose:  Determines whether to overwrite automatically or only
           when the user has responded affirmatively to a prompt.

  Syntax:  SetAutoOverWrite( SETTING )

   Input:  SETTING -- ON, OFF, or ALL

  Output:  SETTING  |  When prompt is issued:
           ---------------------------------------------------
           OFF      |  Before symbols or files are overwritten
                    |
           ON       |  Before files are overwritten
                    |
           ALL      |  Never (use with caution!)
           ---------------------------------------------------

  Remark:  Use  :=  to assign and overwrite without query.
           Use  +=  to accumulate sums.
           Similarly for  -=  *=  /=

  Remark:  Program default is SetAutoOverwrite( OFF ).

 Related:  <a href="#GetDefaults"><b>GetDefaults</b></a>   <a href="#SetAutoDifferentiate"><b>SetAutoDifferentiate</b></a>  <a href="#SetAutoOverwrite"><b>SetAutoOverwrite</b></a>
           <a href="#Solve"><b>Solve</b></a>  <a href="#SolveDt"><b>SolveDt</b></a>  <a href="#SolveSetInput"><b>SolveSetInput</b></a>  <a href="#SolveSetInputDt"><b>SolveSetInputDt</b></a>  ...
           <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRoot</b></a>  <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRootDt</b></a>  ...
           <a href="#SetDt"><b>SetDt</b></a>  <a href="#SetDt"><b>SetNoDt</b></a>   <a href="#="><b>=</b></a>   <a href="#="><b>:=</b></a>   <a href="#="><b>+=</b></a>   <a href="#="><b>*=</b></a>   <a href="#="><b>/=</b></a>   <a href="#="><b>^=</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  SetAutoOverwrite( OFF )
   (3) %--------------------------------------------------------------------
   (4) Variable y = sin(t)
-> (5) y = sin(t)

   (6) y := t^2     % Use  :=  to  overwrite without query. 
-> (7) y = t^2

   (8) %--------------------------------------------------------------------
   (9) % Example 2:  SetAutoOverwrite( ON )
   (10) %--------------------------------------------------------------------
   (11) SetAutoOverWrite( ON )
   (12) y = 351
-> (13) y = 351

   (14) Solve( y - exp(t), y )
-> (15) y = exp(t)



</PRE><nobr><a name="SetAutoRhs"><font color="darkBlue"><font size=+1><b>SetAutoRhs</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetAutoRhs

 Purpose:  Determines whether or not to replace symbols appearing
           on  the  left-hand  sides of equations with the right-
           hand  sides  of  the  equations when these symbols are
           used in expressions.

  Syntax:  SetAutoRhs( SETTING )

   Input:  SETTING -- ON, OFF, or ALL

  Output:  SETTING  |  When a symbol is replaced by its right-hand-side:
           -------------------------------------------------------------
           OFF      |  The name of a user-defined matrix.
                    |  The name of a user-defined vector or dyadic.
                    |
           ON       |  Symbols  replaced when SETTING is OFF
                    |  are also replaced when SETTING is ON.
                    |  In addition, certain other symbols that
                    |  have "small" right-hand-sides are replaced.
                    |
           ALL      |  Any symbol that has a right-hand-side.
           -------------------------------------------------------------

  Remark:  Program default is SetAutoRhs( ON ).

 Related:  <a href="#Evaluate"><b>Evaluate</b></a>  <a href="#Explicit"><b>Explicit</b></a>  <a href="#GetDefaults"><b>GetDefaults</b></a>  <a href="#GetRhs"><b>GetRhs</b></a>  <a href="#ReplaceString"><b>ReplaceString</b></a>  <a href="#SetAutoRhs"><b>SetAutoRhs</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  SetAutoRhs( OFF )
   (3) %--------------------------------------------------------------------
   (4) SetAutoRhs( OFF )
   (5) a = 3
-> (6) a = 3

   (7) b = 2 + a
-> (8) b = 2 + a

   (9) %--------------------------------------------------------------------
   (10) % Example 2:  SetAutoRhs( ON )
   (11) %--------------------------------------------------------------------
   (12) SetAutoRhs( ON )
   (13) c = 2 + a
-> (14) c = 5

   (15) d = cos(t) + c*sin(t) 
-> (16) d = cos(t) + 5*sin(t)

   (17) e = abs(t) + d
-> (18) e = abs(t) + d

   (19) %--------------------------------------------------------------------
   (20) % Example 3:  SetAutoRhs( ALL )
   (21) %--------------------------------------------------------------------
   (22) SetAutoRhs( ALL )
   (23) f = abs(t) + d
-> (24) f = abs(t) + cos(t) + 5*sin(t)



</PRE><nobr><a name="SetAutoSimplify"><font color="darkBlue"><font size=+1><b>SetAutoSimplify</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetAutoSimplify

 Purpose:  Determines whether or not to automatically simplify
           certain mathematical expressions.

  Syntax:  SetAutoSimplify( ACOS=SETTING, ASIN=SETTING, ATAN=SETTING )

   Input:  SETTING -- ON or OFF

  Output:  When SETTING is ON, replaces

           Acos( cos(X) )  with  X
           Asin( sin(X) )  with  X
           Atan( tan(X) )  with  X

           where  X  is any symbolic (non-numeric) expression.

  Remark:  The proper range for x for each simplification is:
           Acos( cos(X) ) =  X        when      0 <= X <= pi
           Asin( sin(X) ) =  X        when  -pi/2 <= X <= pi/2
           Atan( tan(X) ) =  X        when  -pi/2 <= X <= pi/2
           Acos( sin(X) ) = -X+pi/2   when  -pi/2 <= X <= pi/2
           Asin( cos(X) ) = -X+pi/2   when      0 <= X <= pi

  Remark:  Program default is SetAutoSimplify( ACOS=OFF, ASIN=OFF, ATAN=OFF ).

 Related:  <a href="#GetDefaults"><b>GetDefaults</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example:  SetAutoSimplify
   (3) %--------------------------------------------------------------------
   (4) SetAutoSimplify( ACOS=ON, ASIN=ON, ATAN=OFF )
   (5) a = Acos( cos(t^3) )
-> (6) a = t^3

   (7) b = Asin( sin(t^3) )
-> (8) b = t^3

   (9) c = Atan( tan(t^3) )
-> (10) c = atan(tan(t^3))

   (11) d = Atan( tan(3) )
-> (12) d = -0.1415927



</PRE><nobr><a name="SetAutoTaylorSeries"><font color="darkBlue"><font size=+1><b>SetAutoTaylorSeries</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetAutoLinearize   SetAutoTaylorSeries

 Purpose:  Automatically expands all expressions in Taylor series.

Syntax 1:  SetAutoLinearize(           arg1, arg2, ... )
Syntax 2:  SetAutoTaylorSeries( Range, arg1, arg2, ... )
Syntax 3:  SetAutoLinearize(    SETTING )
Syntax 4:  SetAutoTaylorSeries( SETTING )

   Input:  Range -- n or n:m, where n and m are positive integers with n < m.
           Range -- 0:1  for SetAutoLinearize.

           argi -- the scalar name Ci (e.g., a constant or variable) or
                   the equation Ci = D (D is a scalar expression); or
                   the equation Ci = D:P, where P is a scalar name.

           SETTING -- ON or OFF

  Output:  The following table applies to the output expression F
           (F may be a scalar, vector, dyadic, or matrix expression).

           Range|    argi    |              Output
           -----|------------|-----------------------------------
             n  |  Ci        |  nth term of the Taylor series
                |            |  expansion of F about Ci = 0.
                |            |
             n  |  Ci = D    |  nth term of the Taylor series
                |            |  expansion of F about Ci = D.
                |            |
             n  |  Ci = D:P  |  nth term of the Taylor series
                |            |  expansion of F about Ci = D,
                |            |  with P in place of Ci - D.
                |            |
            n:m |  Ci        |  nth  through  mth  terms of Taylor
                |            |  expansion of F about Ci = 0.
                |            |
            n:m |  Ci = D    |  nth  through  mth  terms of Taylor
                |            |  expansion of F about Ci = D.
                |            |
            n:m |  Ci = D:P  |  nth  through  mth  terms of Taylor
                |            |  expansion of F about Ei = D,
                |            |  with P in place of Ci - D.

  Remark:  Syntax 1 and 2 automatically turns SETTING ON.
           Syntax 3 and 4 are useful only after using Syntax 1 or 2 and
           for subsequently turning SETTING OFF (and perhaps ON later).

  Remark:  Due to numerical round-off in Taylor series expansions, consider
           issuing an "epsilon" command  SetAutoEpsilon( 1.0E-13 ).

 Related:  <a href="#GetDefaults"><b>GetDefaults</b></a>  <a href="#SetAutoZee"><b>SetAutoZee</b></a>
           <a href="#GetTaylorSeries"><b>GetTaylorSeries</b></a>  <a href="#Linearize"><b>Linearize</b></a>  <a href="#SetAutoTaylorSeries"><b>SetAutoLinearize</b></a>  <a href="#SetAutoTaylorSeries"><b>SetAutoTaylorSeries</b></a>


</PRE><nobr><a name="SetAutoZee"><font color="darkBlue"><font size=+1><b>SetAutoZee</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetAutoZee

 Purpose:  Determines whether or not Zs are to automatically created.

  Syntax:  SetAutoZee( SETTING )

   Input:  SETTING -- OFF, ON, or AUTO

  Output:  When SETTING is ON, introduces, in selected expressions,
           Z1, Z2, ... as names for sub-expressions, and makes
           corresponding replacements.

           When SETTING is OFF, no Zs are automatically created.

           When SETTING is AUTO, no Zs are automatically created
           until a long expression is encountered, at which time,
           SETTING is turned ON.

  Remark:  Specific names can be excluded from Zs, provided the
           names occur only linearly in expressions.
           To this end, enter   SetNoZeeSymbol( M ),  where M is
           a name to be excluded or a matrix of names to be excluded.

  Remark:  The command SetAutoZee is not available with demonstration and
           certain educational and other licenses.

  Remark:  This command helps produce efficient equations and codes.

  Remark:  Program default is SetAutoZee( AUTO ).

 Related:  <a href="#GetDefaults"><b>GetDefaults</b></a>  <a href="#SetAutoTaylorSeries"><b>SetAutoLinearize</b></a>  <a href="#SetAutoTaylorSeries"><b>SetAutoTaylorSeries</b></a>  <a href="#SetAutoZee"><b>SetAutoZee</b></a>
           <a href="#Zee"><b>Zee</b></a>  <a href="#SetNoZeeSymbol"><b>SetNoZeeSymbol</b></a>  <a href="#SetNoZeeSymbol"><b>ResetNoZeeSymbol</b></a>  <a href="#SetNoZeeSymbol"><b>GetNoZeeSymbol</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  SetAutoZee( OFF )
   (3) %--------------------------------------------------------------------
   (4) SetAutoZee( OFF )
   (5) NewtonianFrame  N
   (6) RigidBody A
   (7) Variable qA''
   (8) A.RotateX( N, qA )
-> (9) A_N = [1, 0, 0;  0, cos(qA), sin(qA);  0, -sin(qA), cos(qA)]
-> (10) w_A_N> = qA'*Ax>
-> (11) alf_A_N> = qA''*Ax>

   (12) %--------------------------------------------------------------------
   (13) % Example 2:  SetAutoZee( ON )
   (14) %--------------------------------------------------------------------
   (15) SetAutoZee( ON )
   (16) RigidBody B
   (17) Variable qB''
   (18) B.RotateX( N, qB )
-> (19) z1 = cos(qB)
-> (20) z2 = sin(qB)
-> (21) B_N = [1, 0, 0;  0, z1, z2;  0, -z2, z1]
-> (22) w_B_N> = qB'*Bx>
-> (23) alf_B_N> = qB''*Bx>



</PRE><nobr><a name="SetBasisSubscripts"><font color="darkBlue"><font size=+1><b>SetBasisSubscripts</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetBasisSubscripts

 Purpose:  Designates the last alphanumeric character in the name of
           right-handed orthogonal, unit vectors created when a
           RigidBody, RigidFrame, or NewtonianFrame is declared.

  Syntax:  SetBasisSubscripts( x,y,z )

   Input:  x,y,z -- three distinct, comma delimited, alphabetic
           characters (letters) or the numbers 1,2,3

  Output:  SetBasisSubscripts( x,y,z )  creates right-handed orthogonal
           unit vectors Bx>, By>, Bz>  fixed in B when:  RigidBody B,
           RigidFrame B,  or  NewtonianFrame B  is issued.

  Remark:  Program default is SetBasisSubscripts( x, y, z ).
           Basis subscripts may be changed at anytime.

 Related:  <a href="#GetBasisVector"><b>GetBasisVector</b></a>  <a href="#GetDefaults"><b>GetDefaults</b></a>  <a href="#SetBasisSubscripts"><b>SetBasisSubscripts</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  SetBasisSubscripts (default basis subscripts)
   (3) %--------------------------------------------------------------------
   (4) RigidBody A
   (5) v> = Vector( A, 10, 20, 30 )
-> (6) v> = 10*Ax> + 20*Ay> + 30*Az>

   (7) %--------------------------------------------------------------------
   (8) % Example 2:  SetBasisSubscripts (vary basis subscripts)
   (9) %--------------------------------------------------------------------
   (10) SetBasisSubscripts( 1,2,3 )
   (11) w> = Vector( A, 10, 20, 30 )
-> (12) w> = 10*A1> + 20*A2> + 30*A3>

   (13) vChangesToo> = v>
-> (14) vChangesToo> = 10*A1> + 20*A2> + 30*A3>

   (15) %--------------------------------------------------------------------
   (16) % Example 3:  SetBasisSubscripts (vary basis subscripts again)
   (17) %--------------------------------------------------------------------
   (18) SetBasisSubscripts( i,j,k )
   (19) x> = Vector( A, 10, 20, 30 )
-> (20) x> = 10*Ai> + 20*Aj> + 30*Ak>

   (21) sum> = v> + w>
-> (22) sum> = 20*Ai> + 40*Aj> + 60*Ak>



</PRE><nobr><a name="SetBeepSoundOnError"><font color="darkBlue"><font size=+1><b>SetBeepSoundOnError</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetBeepSoundOnError

 Purpose:  Determines whether or not to issue an audible beep
           sound when a warning or error message is issued.

  Syntax:  SetBeepSoundOnError( SETTING )

   Input:  SETTING -- ON or OFF

  Remark:  Program default is SetBeepSoundOnError( OFF ).

 Related:  <a href="#GetDefaults"><b>GetDefaults</b></a>



</PRE><nobr><a name="SetCharge"><font color="darkBlue"><font size=+1><b>SetCharge</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetCharge

 Purpose:  Sets and returns the charge on a point or Particle.

Syntax 1:  Q.SetCharge( qCharge )
Syntax 2:  Q.SetCharge( expression )
Syntax 3:  Q.SetCharge( qCharge = expression )

   Input:  Q -- The name of a point or Particle.
           qCharge -- The name of a scalar
           expression - A scalar expression, e.g., sin(t).

Output 1:  Sets Q's charge to qCharge and returns qCharge.
           If not yet declared, qCharge is declared as a constant.

Output 2:  Sets Q's charge to expression and returns expression.

Output 3:  Sets Q's charge to qCharge.  Assigns qCharge to expression.
           Returns qCharge or expression.

 Related:  <a href="#GetCharge"><b>GetCharge</b></a>  <a href="#GetMass"><b>GetMass</b></a>  <a href="#SetCharge"><b>SetCharge</b></a>  <a href="#SetMass"><b>SetMass</b></a>
           <a href="#AddForceElectrostatic"><b>AddForceElectrostatic</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: SetCharge 
   (3) %--------------------------------------------------------------------
   (4) Point      P, Q
   (5) Particle   R, S            
   (6) Variable   cS'
   (7) P.SetCharge( 17 )   
   (8) Q.SetCharge( cQ )               % Declares cQ as a constant.
   (9) R.SetCharge( cR = 3 Coulombs )  % Declares cR and sets it INPUT to 3 Coulombs
   (10) S.SetCharge( cS )               % cS may be governed by an ODE or equation


</PRE><nobr><a name="SetCMSymbol"><font color="darkBlue"><font size=+1><b>SetCMSymbol</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetCMSymbol

 Purpose:  Designates the symbol for the center of mass of bodies.

  Syntax:  SetCMSymbol( cm )

   Input:  cm -- alphanumeric  string with 10 or fewer characters
           used to identify the center of mass of bodies.

  Remark:  The SetCMSymbol command must be issued before any body is declared.

  Remark:  Program default is SetCMSymbol( cm ).

 Related:  <a href="#GetDefaults"><b>GetDefaults</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example:  SetCMSymbol 
   (3) %--------------------------------------------------------------------
   (4) SetCMSymbol( cm )
   (5) NewtonianFrame N
   (6) RigidBody B
   (7) B.SetMass( m )
   (8) Bcm.Translate( No, t^3*Nx> + sin(t)*Ny> )
-> (9) p_No_Bcm> = t^3*Nx> + sin(t)*Ny>
-> (10) v_Bcm_N> = 3*t^2*Nx> + cos(t)*Ny>
-> (11) a_Bcm_N> = 6*t*Nx> - sin(t)*Ny>

   (12) LinearMomentum> = B.GetLinearMomentum()
-> (13) LinearMomentum> = 3*m*t^2*Nx> + m*cos(t)*Ny>

   (14) B.SetAngularVelocity( N, 0> )
-> (15) w_B_N> = 0>

   (16) AngularMomentumAboutNo> = B.GetAngularMomentum( No )
-> (17) AngularMomentumAboutNo> = -m*t^2*(3*sin(t)-t*cos(t))*Nz>

   (18) KinetEnergy = B.GetKineticEnergy()
-> (19) KinetEnergy = 0.5*m*(9*t^4+cos(t)^2)



</PRE><nobr><a name="SetComplex"><font color="darkBlue"><font size=+1><b>SetComplex</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetComplex

 Purpose:  Determines whether to treat scalars as real or complex.

  Syntax:  SetComplex( SETTING )

   Input:  SETTING -- ON, OFF, or AUTO

  Remark:  SetComplex( Setting ) affects simplification.
           When Setting is OFF or AUTO, simplifications may assume that
           names declared by Constant, Specified, Variable, etc., are
           real (not imaginary or complex).

  Remark:  Expressions involving only real quantities are simplified
           maximally when SETTING is OFF, whereas expressions involving
           complex quantities are simplified maximally when SETTING is ON.
           When SETTING is AUTO, simplifications are made as if SETTING
           were OFF until the first imaginary number is encountered,
           at which time, SETTING is automatically changed to ON.

  Remark:  Program default is SetComplex( AUTO ).

 Related:  <a href="#GetDefaults"><b>GetDefaults</b></a>  <a href="#ImaginaryNumber"><b>ImaginaryNumber</b></a>
           <a href="#Constant"><b>Constant</b></a>  <a href="#Specified"><b>Specified</b></a>  <a href="#Variable"><b>Variable</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  SetComplex( OFF )
   (3) %--------------------------------------------------------------------
   (4) Variable x
   (5) SetComplex( OFF )
   (6) a = sqrt(x^2)
-> (7) a = abs(x)

   (8) b = Evaluate( a, x = 2 + GetImaginaryNumber() )  
-> (9) b = abs(2+imaginary)

   (10) c = Exp( GetImaginaryNumber() * x )
-> (11) c = exp(imaginary*x)

   (12) %--------------------------------------------------------------------
   (13) % Example 2:  SetComplex( ON )
   (14) %--------------------------------------------------------------------
   (15) SetComplex( ON )
   (16) d = sqrt(x^2)  
-> (17) d = sqrt(x^2)

   (18) e = Evaluate(   a,  x = 2 + GetImaginaryNumber() )  
-> (19) e = 2.236068

   (20) f = Evaluate( x^2,  x = 2 + GetImaginaryNumber() )  
-> (21) f = 3 + 4*imaginary

   (22) g = Evaluate(   d,  x = 2 + GetImaginaryNumber() )  
-> (23) g = 2 + 1*imaginary

   (24) h = Exp( GetImaginaryNumber() * x )
-> (25) h = cos(x) + imaginary*sin(x)

   (26) %--------------------------------------------------------------------
   (27) % Example 3:  SetComplex( AUTO )
   (28) %--------------------------------------------------------------------
   (29) SetComplex( AUTO )
   (30) k = sqrt(x^2)                                 % Complex if OFF
-> (31) k = abs(x)

   (32) L = Evaluate( a, x = 2+GetImaginaryNumber() ) % Complex turns ON
-> (33) L = 2.236068

   (34) m = Exp( GetImaginaryNumber() * x )           % Complex is ON
-> (35) m = cos(x) + imaginary*sin(x)



</PRE><nobr><a name="SetDigits"><font color="darkBlue"><font size=+1><b>SetDigits</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetDigits   GetDigits

 Purpose:  Sets an upper limit on the number of digits displayed on
           the screen when numerical values are reported.
           Governs the format and number of digits displayed in output
           files created in response to the ODE and Solve commands.

Syntax 1:  SetDigits( n )
Syntax 2:  GetDigits( )

   Input:  n -- a positive integer less than or equal to 16.
           expression -- a scalar, vector, dyadic, or matrix expression.

Output 2:  Returns the number  n  previously set in a SetDigits command.

  Remark:  Regardless of the value of n, all computations are performed
           in double precision and to machine accuracy.

  Remark:  Program default is SetDigits( 7 ).

 Related:  <a href="#ODE"><b>ODE</b></a>  <a href="#Solve"><b>Solve</b></a>  <a href="#Input"><b>Input</b></a>  <a href="#Output"><b>Output</b></a>  <a href="#Output"><b>OutputPlot</b></a>  <a href="#Plot"><b>Plot</b></a>  <a href="#Animate"><b>Animate</b></a>
           <a href="#SetDigits"><b>SetDigits</b></a>  <a href="#SetAutoEpsilon"><b>SetAutoEpsilon</b></a>  <a href="#Epsilon"><b>Epsilon</b></a>  <a href="#GetDefaults"><b>GetDefaults</b></a>  <a href="#ReplaceString"><b>ReplaceString</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  SetDigits (default number of displayed digits)
   (3) %--------------------------------------------------------------------
   (4) x = exp(2)
-> (5) x = 7.389056

   (6) %--------------------------------------------------------------------
   (7) % Example 2:  SetDigits (vary the number of displayed digits)
   (8) %--------------------------------------------------------------------
   (9) SetDigits( 12 )
   (10) y = x
-> (11) y = 7.38905609893

   (12) SetDigits( 3 )
   (13) z = x
-> (14) z = 7.39

   (15) numberOfDigits = GetDigits()
-> (16) numberOfDigits = 3



</PRE><nobr><a name="SetDt"><font color="darkBlue"><font size=+1><b>SetDt</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetDt  or   SetNoDt

 Purpose:  Assigns a scalar quantity and its ordinary derivatives.

Syntax 1:  SetDt(   x = scalarExpression )
Syntax 2:  SetNoDt( x = scalarExpression )

   Input:  x -- a scalar name (e.g., a Variable or Specified).
           scalarExpression -- a differentiable scalar expression.

Output 1:  Assigns x   to       scalarExpression.
           Assigns x'  to   Dt( scalarExpression )
           Assigns x'' to DtDt( scalarExpression ) if x'' exists, etc.
           Returns x.

Output 2:  Assigns x to scalarExpression and returns x.
           x', x'', etc., are not assigned.

  Remark:  SetDt will assign x and as many ordinary derivatives
           of x as exist, e.g., x', x'', x''', etc.

  Remark:  SetNoDt will not set x' and will skip warning
           messages about the possible use of SetDt.

 Related:  <a href="#D"><b>D</b></a>  <a href="#Dt"><b>Dt</b></a>  <a href="#Dt"><b>DtDt</b></a>  <a href="#Integrate"><b>Integrate</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>
           <a href="#SetDt"><b>SetDt</b></a>  <a href="#Solve"><b>Solve</b></a>  <a href="#SolveDt"><b>SolveDt</b></a>  <a href="#SolveSetInput"><b>SolveSetInput</b></a>  <a href="#SolveSetInputDt"><b>SolveSetInputDt</b></a>  ...
           <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRoot</b></a>  <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRootDt</b></a>  ...

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  SetDt( ... )
   (3) %--------------------------------------------------------------------
   (4) Variable  x'
   (5) SetDt( x = sin(t) )
-> (6) x = sin(t)
-> (7) x' = cos(t)

   (8) %--------------------------------------------------------------------
   (9) % Example 2:  SetDt( ... )
   (10) %--------------------------------------------------------------------
   (11) Specified y''
   (12) SetDt( y = t^3 )
-> (13) y = t^3
-> (14) y' = 3*t^2
-> (15) y'' = 6*t

   (16) %--------------------------------------------------------------------
   (17) % Example 3:  SetNoDt( ... )
   (18) %--------------------------------------------------------------------
   (19) SetNoDt( y = cos(t) )
-> (20) y = cos(t)



</PRE><nobr><a name="SetGeneralizedSpeed"><font color="darkBlue"><font size=+1><b>SetGeneralizedSpeed</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetGeneralizedSpeed       ResetGeneralizedSpeed       GetGeneralizedSpeed
SetGeneralizedCoordinate  ResetGeneralizedCoordinate  GetGeneralizedCoordinate

  Purpose: Names generalized speeds for Kane's method.
           Names generalized coordinates for Lagrange and Kane methods and for
           calculating generalized forces associated with potential energy.
           Returns a column matrix of generalized speeds or coordinates.

Syntax 1:  GetGeneralizedSpeed()
           GetGeneralizedCoordinate()
Syntax 2:  SetGeneralizedSpeed( qA', qB', wz )
           SetGeneralizedCoordinate( x, y, theta )
Syntax 3:  ResetGeneralizedSpeed( wx, wy )
           ResetGeneralizedCoordinate( x, y )
Syntax 4:  ResetGeneralizedSpeed()
           ResetGeneralizedCoordinate()

   Input:  qA', qB', wz, x, y, theta -- names that start with a letter
           followed by a reasonable number of alphanumeric characters,
           Generalized speeds may end with one or more prime symbols '.

Output 1:  Gets the column matrix of names declared as generalized speeds or
           gets the column matrix of names declared as generalized coordinates.
Output 2:  Appends qA', qB', wz to the matrix of generalized speeds or
           appends x, y, theta  to the matrix of generalized coordinates.
           Returns the matrix described by Output 1.
Output 3:  Resets generalized speeds to just wx, wy and returns [wx;  wy]  or
           resets generalized coordinates to just x, y and returns [x;  y].
Output 4:  Resets to no generalized speeds and returns [0] or
           resets to no generalized coordinates and returns [0].

 Related:  <a href="#Constant"><b>Constant</b></a>  <a href="#ImaginaryNumber"><b>ImaginaryNumber</b></a>  <a href="#Specified"><b>Specified</b></a>  <a href="#Variable"><b>Variable</b></a>
           <a href="#SetGeneralizedSpeed"><b>SetGeneralizedCoordinate</b></a>  <a href="#SetGeneralizedSpeed"><b>SetGeneralizedSpeed</b></a>
           <a href="#GetStatics"><b>GetStatics</b></a>   <a href="#Kane"><b>GetStaticsKane</b></a>   <a href="#Lagrange"><b>GetStaticsLagrange</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#Lagrange"><b>GetDynamicsLagrange</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: SetGeneralizedSpeed  (Projectile motion)
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N
   (5) Particle P
   (6) P.SetMass( m = 1 kg )
   (7) Constant  g = 9.8 m/s^2
   (8) Variable  x'', y''
   (9) SetGeneralizedSpeed( x', y' )
   (10) P.Translate( No, x*Nx> + y*Ny> )
-> (11) p_No_P> = x*Nx> + y*Ny>
-> (12) v_P_N> = x'*Nx> + y'*Ny>
-> (13) a_P_N> = x''*Nx> + y''*Ny>

   (14) P.AddForce( -m*g*Ny> )
-> (15) Force_P> = -m*g*Ny>

   (16) KaneDynamics = System.GetDynamicsKane()
-> (17) KaneDynamics = [m*x'';  m*(g+y'')]

   (18) Solve( KaneDynamics = 0,  Dt(GetGeneralizedSpeeds()) )
-> (19) x'' = 0
-> (20) y'' = -g

   (21) %--------------------------------------------------------------------
   (22) % Example 2: GetGeneralizedSpeed 
   (23) %--------------------------------------------------------------------
   (24) speeds = GetGeneralizedSpeed()
-> (25) speeds = [x';  y']

   (26) %--------------------------------------------------------------------
   (27) % Example 3: ResetGeneralizedSpeed 
   (28) %--------------------------------------------------------------------
   (29) speeds := ResetGeneralizedSpeed()
-> (30) speeds = [0]



</PRE><nobr><a name="SetNoZeeSymbol"><font color="darkBlue"><font size=+1><b>SetNoZeeSymbol</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetNoZeeSymbol  ResetNoZeeSymbol   GetNoZeeSymbol

 Purpose:  Identifies scalar quantities that are to be excluded from Zs.

Syntax 1:  SetNoZeeSymbol( x, y, z )
Syntax 2:  ResetNoZeeSymbol( )
Syntax 3:  ResetNoZeeSymbol( x, y )
Syntax 4:  GetNoZeeSymbol( )

   Input:  x, y, z -- names of a scalar symbol (e.g., a constant or variable)
                      or a matrix of scalar names.

Output 1:  Appends x, y, z to the matrix of names to be excluded from Zs.
           Returns the matrix of all names to be excluded from Zs.

Output 2:  Removes all names to be excluded from Zs.
           Returns 1x1 zero matrix.

Output 3:  Removes all names to be excluded from Zs.
           Appends x, y to the matrix of names to be excluded from Zs.
           Returns the 2x1 matrix [x; y] -- names to be excluded from Zs.

Output 4:  Returns the matrix of all names to be excluded from Zs.

  Remark:  Names can be excluded from Zs provided that occur only linearly.

 Related:  <a href="#Explicit"><b>Explicit</b></a>  <a href="#Zee"><b>Zee</b></a>  <a href="#GetRhs"><b>GetRhs</b></a>  <a href="#SetAutoRhs"><b>SetAutoRhs</b></a>
           <a href="#SetNoZeeSymbol"><b>SetNoZeeSymbol</b></a>  <a href="#SetNoZeeSymbol"><b>ResetNoZeeSymbol</b></a>  <a href="#SetNoZeeSymbol"><b>GetNoZeeSymbol</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: SetNoZeeSymbol  (with scalar expressions)
   (3) %--------------------------------------------------------------------
   (4) Constant   a, b, c
   (5) ScalarExpression = (a-b)*cos(t) + (b-c)*sin(t)
-> (6) ScalarExpression = (a-b)*cos(t) + (b-c)*sin(t)

   (7) SetNoZeeSymbol( a )
   (8) testA = Zee( ScalarExpression )
-> (9) z1 = cos(t)
-> (10) z2 = sin(t)
-> (11) z3 = b - c
-> (12) z4 = z3*z2 - b*z1
-> (13) testA = z4 + a*z1

   (14) SetNoZeeSymbol( b )
   (15) testB = Zee( ScalarExpression )
-> (16) z5 = z2 - z1
-> (17) z6 = c*z2
-> (18) testB = a*z1 + b*z5 - z6

   (19) ResetNoZeeSymbol()
   (20) testC = Zee( ScalarExpression )
-> (21) z7 = a - b
-> (22) z8 = z3*z2 + z7*z1
-> (23) testC = z8

   (24) %--------------------------------------------------------------------
   (25) % Example 2: SetNoZeeSymbol  (with matrix expressions)
   (26) %--------------------------------------------------------------------
   (27) Variable x, y
   (28) matrix[1] = 10 + a + b + c + abs(t)*x + sin(t)*exp(t)*cos(t^2)*y
-> (29) matrix[1] = 10 + a + b + c + abs(t)*x + sin(t)*exp(t)*cos(t^2)*y

   (30) matrix[2] = 10 + a^2 + cos(b+c)*tan(t)*x
-> (31) matrix[2] = 10 + a^2 + cos(b+c)*tan(t)*x

   (32) SetNoZeeSymbol( x, y )
   (33) testD = Zee( matrix )
-> (34) z9 = abs(t)
-> (35) z10 = exp(t)
-> (36) z11 = cos(t^2)
-> (37) z12 = z2*z10*z11
-> (38) z13 = 10 + a + b + c
-> (39) z14 = cos(b+c)
-> (40) z15 = tan(t)
-> (41) z16 = z14*z15
-> (42) z17 = 10 + a^2
-> (43) testD = [z13 + z9*x + z12*y;  z17 + z16*x]

   (44) noZeeSymbols = GetNoZeeSymbol()
-> (45) noZeeSymbols = [x;  y]



</PRE><nobr><a name="SetLineSpacing"><font color="darkBlue"><font size=+1><b>SetLineSpacing</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetLineSpacing

 Purpose:  Sets output line spacing.

  Syntax:  SetLineSpacing( n )

   Input:  n -- 0 or 1 or 2 or a positive integer (e.g., less than 10).

  Remark:  When n = 0, input lines follow each other without
           intervening blank lines, and an input line that
           follows a response line is preceded by a blank line.
           When n > 0, n-1 blank lines follow each input line
           and each response line.

  Remark:  Program default is SetLineSpacing( 0 ).

 Related:  <a href="#GetDefaults"><b>GetDefaults</b></a>  <a href="#SetLineStepping"><b>SetLineStepping</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: SetLineSpacing (uses the default value 0)
   (3) %--------------------------------------------------------------------
   (4) SetLineSpacing( 0 )
   (5) A = t^2
-> (6) A = t^2

   (7) B = t^2
-> (8) B = t^2

   (9) %--------------------------------------------------------------------
   (10) % Example 2: SetLineSpacing (single spacing)
   (11) %--------------------------------------------------------------------
   (12) SetLineSpacing( 1 )
   (13) A := t^2
-> (14) A = t^2
   (15) B := t^2
-> (16) B = t^2
   (17) %--------------------------------------------------------------------
   (18) % Example 3: SetLineSpacing (double spacing)
   (19) %--------------------------------------------------------------------
   (20) SetLineSpacing( 2 )

   (21) A := t^2

-> (22) A = t^2

   (23) B := t^2

-> (24) B = t^2



</PRE><nobr><a name="SetLineStepping"><font color="darkBlue"><font size=+1><b>SetLineStepping</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetLineStepping

 Purpose:  Runs an input file one line at a time.

  Syntax:  SetLineStepping( SETTING )

   Input:  SETTING -- ON or OFF

  Remark:  When running an input file with SETTING is ON, the cursor
           appears near a question mark to prompt the user.
           Pressing  Enter  causes the next input line to appear on
           the screen or causes all response lines corresponding to
           an input line to be displayed.

           When SETTING is ON, pressing the  Esc  key and pressing
           Enter causes any input lines that were read to be processed,
           causes the question mark to disappear, suspends running
           the input file, and enables normal operation.
           Subsequently, typing  RUN  at a line prompt runs the
           input file with the question mark and line stepping ON.

  Remark:  Program default is SetLineStepping( OFF ).

 Related:  <a href="#GetDefaults"><b>GetDefaults</b></a>  <a href="#Run"><b>Run</b></a>  <a href="#SetLineStepping"><b>SetLineStepping</b></a>

--------------------------------------------------------------------
 Example:  SetLineStepping
--------------------------------------------------------------------

   (1) SetLineStepping( ON )
   (2) Run( TESTFILE )
   (2) ?



</PRE><nobr><a name="SetLineWidth"><font color="darkBlue"><font size=+1><b>SetLineWidth</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetLineWidth

 Purpose:  Sets the line width for writing output to .all or .html files
           (in conjunction with the SAVE command) or in writing C, Fortran,
           MATLAB(R) codes (in conjunction with the CODE or ODE commands).

  Syntax:  SetLineWidth( lineWidth )

   Input:  lineWidth -- 0 or a positive integer less than 65536.

  Remark:  If lineWidth = 0, the following program defaults are used:
           -------------------------------------------------------
            File type |  Line width |  Strict limit |  Use
           -------------------------------------------------------
           .all       |  80         |  No           |  Text file
           .html      |  80         |  No           |  Browser
           .m         |  128        |  No           |  MATLAB(R)
           .c         |  128        |  No           |  C
           .f         |  120        |  No           |  FORTRAN
           .for       |  72         |  Yes          |  FORTRAN 77

 Related:  <a href="#Save"><b>Save</b></a>  <a href="#Code"><b>Code</b></a>  <a href="#ODE"><b>ODE</b></a>

--------------------------------------------------------------------
 Example:  SetLineWidth  (tests SetLineWidth function)
--------------------------------------------------------------------
 x = expand( (t+cos(t))^24,  0:24 )
 SetLineWidth( 150 )
 y = expand( (t+cos(t))^24,  0:24 )
 Save  SetLineWidth.html

 Input  t = 0.25
 OutputEncode  x, y
 CODE Algebraic() SetLineWidth.m



</PRE><nobr><a name="SetMass"><font color="darkBlue"><font size=+1><b>SetMass</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetMass

 Purpose:  Sets and returns the mass of a Particle or RigidBody.

Syntax 1:  B.SetMass( mB )
Syntax 2:  B.SetMass( expression )
Syntax 3:  B.SetMass( mB = expression )
Syntax 4:  B.SetMass( mB = 10 kg )

   Input:   B -- The name of a Particle or RigidBody.
           mB -- The name of a scalar.
           expression -- Scalar expression, e.g., sin(t).

Output 1:  Sets B's mass to mB and returns mB.
           Declares mB as a non-negative constant (if not yet declared).

Output 2:  Sets B's mass to expression and returns expression.

Output 3:  Sets B's mass to mB.  Assigns mB to expression.
           Returns mB or expression.

Output 4:  Sets B's mass to mB.  Assigns the input value of mB to 10 kg.
           Returns mB.

 Related:  <a href="#SetMass"><b>SetMass</b></a>          <a href="#GetMass"><b>GetMass</b></a>         <a href="#SetInertia"><b>SetInertia</b></a>
           <a href="#GetCMPosition"><b>GetCMPosition</b></a>    <a href="#GetCMVelocity"><b>GetCmVelocity</b></a>   <a href="#GetCMAcceleration"><b>GetCmAcceleration</b></a>
           <a href="#GetInertiaDyadic"><b>GetInertiaDyadic</b></a>  <a href="#GetInertiaMatrix"><b>GetInertiaMatrix</b></a>  <a href="#GetMomentOfInertia"><b>GetMomentOfInertia</b></a>
           <a href="#GetProductOfInertia"><b>GetProductOfInertia</b></a>  <a href="#GetRadiusOfGyration"><b>GetRadiusOfGyration</b></a>  <a href="#GetInertiaVector"><b>GetInertiaVector</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: SetMass 
   (3) %--------------------------------------------------------------------
   (4) Particle   P, Q, R, S            
   (5) RigidBody  B
   (6) Variable   mS'
   (7) P.SetMass( 17 )   
   (8) Q.SetMass( mQ )         % Declares mQ as a non-negative constant
   (9) R.SetMass( mR = 3 kg )  % Declares mR and sets its INPUT value to 3 kg
   (10) S.SetMass( mS )         % mS may be governed by an ODE or equation
   (11) B.SetMass( mB )         % Declares mB as a non-negative constant
   (12) mSystem= System.GetMass()    
-> (13) mSystem = 17 + mB + mQ + mR + mS



</PRE><nobr><a name="SetMassInertia"><font color="darkBlue"><font size=+1><b>SetMassInertia</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetMassInertia   (also see SetMass and SetInertia)

 Purpose:  Sets a RigidBody's mass and inertia about its center of mass.
           Returns the associated inertia dyadic.

Syntax 1:  B.SetMassInertia( mB, IBxx, IByy, IBzz )
Syntax 2:  B.SetMassInertia( mB, IBxx, IByy, IBzz, IBxy, IByz, IBzx )
Syntax 3:  B.SetMassInertia( mB, aboutPoint, A, I11, I22, I33 )
Syntax 4:  B.SetMassInertia( mB, aboutPoint, A, I11, I22, I33, I12, I23, I31 )
Syntax 5:  B.SetMassInertia( mB, aboutPoint, symmetricInertiaDyadic )
Syntax 6:  B.SetMassInertia( mB, aboutPoint, threeElementMatrix )
Syntax 7:  B.SetMassInertia( mB, aboutPoint, 3x3symmetricMatrix  )

   Input:  B -- The name of a RigidBody.

           mB -- The mass of B.  This argument can be an expression such as
                 mB = sin(t) or set an input value with mB = 10 kg.

           aboutPoint -- The name of a point (typically fixed on B).

           IBxx, IByy, IBzz -- B's moments  of inertia about aboutPoint
                               for Bx>, By>, and Bz>, respectively.

           IBxy, IByz, IBzx -- B's products of inertia about aboutPoint
                               for  Bx>*By>,  By>*Bz>,  and  Bz>*Bx>.

           A -- The name of a RigidBody or RigidFrame.

           I11, I22, I33 -- B's moments  of inertia about aboutPoint
                            for Ax>, Ay>, and Az>, respectively.

           I12, I23, I31 -- B's products of inertia about aboutPoint
                            for  Ax>*Ay>,  Ay>*Az>,  and  Az>*Ax>.
                            Note the cyclical permutation ordering.

           symmetricInertiaDyadic -- A symmetric inertia dyadic.

           threeElementMatrix -- 3 x 1  or  1 x 3  matrix of real scalars.

           3x3symmetricMatrix -- 3 x 3  symmetric matrix of real scalars.

 Outputs:  In each case, sets and returns B's inertia dyadic about aboutPoint.

Output:    Calls:  B.SetMass( mB )   then subsequently returns the following
Output 1:  B.SetInertia( Bcm, IBxx, IByy, IBzz )
Output 2:  B.SetInertia( Bcm, IBxx, IByy, IBzz, IBxy, IByz, IBzx )
Output 3:  B.SetMassInertia( aboutPoint, I11, I22, I33 )
Output i:  Corresponding  B.SetInertia( .... )  commands  (i = 4, 5, 6).

  Remark:  Declares  mB, IBxx, IByy, IBzz  as non-negative constants or
           IBxy, IByz, IBzx as constants (if not yet declared).  Alternately,
           the inertia scalars IBxx, IByy, ... can be an expression such as
           Ixy = -m*x*y or a number with units, e.g.,  Ixy = -6 kg*m^2.

  Remark:  Products of inertia adhere to the "negative sign convention".
           Example: For a 1 kg particle whose position from a point P is
           2*Nx> + 3*Ny>, the product of inertia Ixy = -m*x*y = -6 kg*m^2.

 Related:  <a href="#SetMass"><b>SetMass</b></a>              <a href="#GetMass"><b>GetMass</b></a>              <a href="#SetInertia"><b>SetInertia</b></a>
           <a href="#GetCMPosition"><b>GetCMPosition</b></a>        <a href="#GetCMVelocity"><b>GetCmVelocity</b></a>        <a href="#GetCMAcceleration"><b>GetCmAcceleration</b></a>
           <a href="#GetInertiaDyadic"><b>GetInertiaDyadic</b></a>     <a href="#GetInertiaMatrix"><b>GetInertiaMatrix</b></a>     <a href="#GetMomentOfInertia"><b>GetMomentOfInertia</b></a>
           <a href="#GetProductOfInertia"><b>GetProductOfInertia</b></a>  <a href="#GetRadiusOfGyration"><b>GetRadiusOfGyration</b></a>  <a href="#GetInertiaVector"><b>GetInertiaVector</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: SetMassInertia 
   (3) %--------------------------------------------------------------------
   (4) RigidFrame N   
   (5) RigidBody  A, B, C, D, E, F
   (6) A.SetMassInertia( m, IAxx, IAyy, IAzz )  
   (7) B.SetMassInertia( m, IBxx, IByy, IBzz, IBxy, IByz, IBzx ) 
   (8) C.SetMassInertia( m, Ccm, N, I11, I22, I33 )
   (9) D.SetMassInertia( m, Dcm, 5*1>> )
   (10) E.SetMassInertia( m, Eo, [2, 3, 4] )
   (11) F.SetMassInertia( m, Fo, [2, -0.1, 0;  -0.1, 3, 0;  0, 0, 4] )
   (12) %--------------------------------------------------------------------
   (13) AInertiaAboutAcm>> = A.GetInertia( Acm )
-> (14) AInertiaAboutAcm>> = IAxx*Ax>*Ax> + IAyy*Ay>*Ay> + IAzz*Az>*Az>

   (15) DInertiaAboutDcm>> = D.GetInertia( Dcm )
-> (16) DInertiaAboutDcm>> = 5*1>>

   (17) EInertiaAboutEo>> = E.GetInertia( Eo )
-> (18) EInertiaAboutEo>> = 2*Ex>*Ex> + 3*Ey>*Ey> + 4*Ez>*Ez>



</PRE><nobr><a name="SetInertia"><font color="darkBlue"><font size=+1><b>SetInertia</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetInertia

 Purpose:  Sets and returns a RigidBody's inertia dyadic about a point.

Syntax 1:  B.SetInertia( aboutPoint, IBxx, IByy, IBzz )
Syntax 2:  B.SetInertia( aboutPoint, IBxx, IByy, IBzz, IBxy, IByz, IBzx )
Syntax 3:  B.SetInertia( aboutPoint, A, I11, I22, I33 )
Syntax 4:  B.SetInertia( aboutPoint, A, I11, I22, I33, I12, I23, I31 )
Syntax 5:  B.SetInertia( aboutPoint, symmetricInertiaDyadic )
Syntax 6:  B.SetInertia( aboutPoint, threeElementMatrix )
Syntax 7:  B.SetInertia( aboutPoint, 3x3symmetricMatrix  )

   Input:  B -- The name of a RigidBody.

           aboutPoint -- The name of a point (typically fixed on B).

           IBxx, IByy, IBzz -- B's moments  of inertia about aboutPoint
                               for Bx>, By>, and Bz>, respectively.

           IBxy, IByz, IBzx -- B's products of inertia about aboutPoint
                               for  Bx>*By>,  By>*Bz>,  and  Bz>*Bx>.
                               Note the cyclical permutation ordering.

           A -- The name of a RigidBody or RigidFrame.

           I11, I22, I33 -- B's moments  of inertia about aboutPoint
                            for Ax>, Ay>, and Az>, respectively.

           I12, I23, I31 -- B's products of inertia about aboutPoint
                            for  Ax>*Ay>,  Ay>*Az>,  and  Az>*Ax>.
                            Note the cyclical permutation ordering.

           symmetricInertiaDyadic -- A symmetric inertia dyadic.

           threeElementMatrix -- 3 x 1  or  1 x 3  matrix of real scalars.

           3x3symmetricMatrix -- 3 x 3  symmetric matrix of real scalars.

 Outputs:  In each case, sets and returns B's inertia dyadic about aboutPoint.

Output 1:  Sets and returns IBxx*Bx>*Bx> + IByy*By>*By> + IBzz*Bz>*Bz>

Output 2:  Sets and returns IBxx*Bx>*Bx> + IBxy*Bx>*By> + IBzx*Bx>*Bz> +
                            IBxy*By>*Bx> + IByy*By>*By> + IByz*By>*Bz> +
                            IBzx*Bz>*Bx> + IByz*Bz>*Bx> + IBzz*Bz>*Bz>

Output 3:  Sets and returns I11*Ax>*Ax> + I22*Ay>*Ay> + I33*Az>*Az>

Output 4:  Sets and returns I11*Ax>*Ax> + I12*Ax>*Ay> + I31*Ax>*Az> +
                            I12*Ay>*Ax> + I22*Ay>*Ay> + I23*Ay>*Az> +
                            I31*Az>*Ax> + I23*Az>*Ax> + I33*Az>*Az>

Output 5:  Sets and returns symmetricInertiaDyadic.

Output 6:  When threeElementMatrix is the 3x1 matrix m,
           sets and returns m[1]*Bx>*Bx> + m[2]*By>*By> + m[3]*Bz>*Bz>

Output 7:  When 3x3symmetricMatrix is the matrix I,
           Sets and returns I[1,1]*Bx>*Bx> + I[1,2]*Bx>*By> + I[1,3]*Bx>*Bz> +
                            I[2,1]*By>*Bx> + I[2,2]*By>*By> + I[2,3]*By>*Bz> +
                            I[3,1]*Bz>*Bx> + I[3,2]*Bz>*Bx> + I[3,3]*Bz>*Bz>

  Remark:  If moments of inertia such as IBxx are not already declared,
           they are declared as non-negative constants.

           If products of inertia such as IBxy are not already declared,
           they are declared as constants.

           IBij (i,j=x,y,z) can be an expression such as IBxx = m*r^2/2

  Remark:  Products of inertia adhere to the "negative sign convention".
           Example: For a 1 kg particle whose position from a point P is
           2*Nx> + 3*Ny>, the product of inertia Ixy = -m*x*y = -6 kg*m^2.

 Related:  <a href="#SetMass"><b>SetMass</b></a>          <a href="#GetMass"><b>GetMass</b></a>         <a href="#SetInertia"><b>SetInertia</b></a>
           <a href="#GetCMPosition"><b>GetCMPosition</b></a>    <a href="#GetCMVelocity"><b>GetCmVelocity</b></a>   <a href="#GetCMAcceleration"><b>GetCmAcceleration</b></a>
           <a href="#GetInertiaDyadic"><b>GetInertiaDyadic</b></a>  <a href="#GetInertiaMatrix"><b>GetInertiaMatrix</b></a>  <a href="#GetMomentOfInertia"><b>GetMomentOfInertia</b></a>
           <a href="#GetProductOfInertia"><b>GetProductOfInertia</b></a>  <a href="#GetRadiusOfGyration"><b>GetRadiusOfGyration</b></a>  <a href="#GetInertiaVector"><b>GetInertiaVector</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: SetInertia 
   (3) %--------------------------------------------------------------------
   (4) RigidFrame N   
   (5) RigidBody  A, B, C, D, E, F
   (6) A.SetInertia( Acm, IAxx, IAyy, IAzz )  
   (7) B.SetInertia( Bcm, IBxx, IByy, IBzz, IBxy, IByz, IBzx ) 
   (8) C.SetInertia( Ccm, N, I11, I22, I33 )
   (9) D.SetInertia( Dcm, 5*1>> )
   (10) E.SetInertia( Eo, [2, 3, 4] )
   (11) F.SetInertia( Fo, [2, -0.1, 0;  -0.1, 3, 0;  0, 0, 4] )
   (12) %--------------------------------------------------------------------
   (13) AInertiaAboutAcm>> = A.GetInertia( Acm )
-> (14) AInertiaAboutAcm>> = IAxx*Ax>*Ax> + IAyy*Ay>*Ay> + IAzz*Az>*Az>

   (15) DInertiaAboutDcm>> = D.GetInertia( Dcm )
-> (16) DInertiaAboutDcm>> = 5*1>>

   (17) EInertiaAboutEo>> = E.GetInertia( Eo )
-> (18) EInertiaAboutEo>> = 2*Ex>*Ex> + 3*Ey>*Ey> + 4*Ez>*Ez>



</PRE><nobr><a name="SetPauseOnWarning"><font color="darkBlue"><font size=+1><b>SetPauseOnWarning</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetPauseOnWarning

 Purpose:  Sets the duration of the pause that occurs when a warning is
           issued during execution of an input file.

Syntax 1:  SetPauseOnWarning( numberOfSeconds )
Syntax 2:  SetPauseOnWarning( WAIT )

   Input:  numberOfSeconds -- an integer between 0 and 60, equal to the
           desired duration, in seconds, of the pause following a warning.
           Note: No pause occurs when numberOfSeconds is 0.

           WAIT -- WAIT

Output 1:  Suspends program execution for numberOfSeconds.
Output 2:  Suspends program execution until the user presses the ENTER key.

  Remark:  Program default is SetPauseOnWarning( WAIT ).
           This default can be set in the MGDefaultPreferences.txt
           file that resides in the program's MGToolbox folder.

  Remark:  If reading from an input file stops, you may type RUN
           to resume execution from the input file.

 Related:  <a href="#Pause"><b>Pause</b></a>  <a href="#SetPauseOnWarning"><b>SetPauseOnWarning</b></a>  <a href="#GetDefaults"><b>GetDefaults</b></a>



</PRE><nobr><a name="SetRotationMatrix"><font color="darkBlue"><font size=+1><b>SetRotationMatrix</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetRotationMatrix

 Purpose:  Sets the rotation matrix relating two sets of bases vectors
           associated with right-handed rotations of B relative to A.

Syntax 1:  B.SetRotationMatrix( A, aboutUnitVector, theta )
Syntax 2:  B.SetRotationMatrix( A, SequenceI,   q1 )
Syntax 3:  B.SetRotationMatrix( A, SequenceIJ,  q1, q2 )
Syntax 4:  B.SetRotationMatrix( A, SequenceIJK, q1, q2, q3 )
Syntax 5:  B.SetRotationMatrix( A, EulerParameters, e0, e1, e2, e3 )
           B.SetRotationMatrix( A, Quaternion,      e0, e1, e2, e3 )
Syntax 6:  B.SetRotationMatrix( A, RodriguesParameters, rho1, rho2, rho3 )
Syntax 7:  B.SetRotationMatrix( A, PoissonParameters, Rxx,Rxy, ..., Rzz )
Syntax 8:  B.SetRotationMatrix( A, matrix33 )
Syntax 9:  B.SetRotationMatrixX( A, q )  B.SetRotationMatrixNegativeX( A, q )
           B.SetRotationMatrixY( A, q )  B.SetRotationMatrixNegativeY( A, q )
           B.SetRotationMatrixZ( A, q )  B.SetRotationMatrixNegativeZ( A, q )
           Type  HELP SetRotationMatrixX  for examples.

   Input:  B, A -- name of a RigidFrame or RigidBody.

           theta, q1, q2, q3 -- angles (scalar expressions).

           aboutUnitVector -- unit vector that can be expressed in terms of
                              either  Ax>, Ay>, Az>  or  Bx>, By>, Bz>.

           SequenceI -- BodyI or SpaceI where I is X, -X, Y, -Y, Z, -Z, e.g.,
                        BodyX,  BodyY,  BodyZ,  -BodyX,  Body-Y, etc.
                       SpaceX, SpaceY, SpaceZ, -SpaceX, Space-Y, etc.

           SequenceIJ -- BodyIJ or Space IJ where I and J are appropriate
                         combinations of X, -X, Y, -Y, Z, -Z, e.g.,
                         BodyXY,  BodyXZ,  BodyYX,  BodyYZ,  BodyZX,  BodyZY
                        SpaceXY, SpaceXZ, SpaceYX, SpaceYZ, SpaceZX, SpaceZY
                        Body-XY,  BodyX-Z,  Body-Y-X, Space-XY, etc.

           SequenceIJK -- BodyIJK or SpaceIJK where I, J, K are appropriate
                          combinations of X, -X, Y, -Y, Z, -Z, e.g.,
                   BodyXYZ,  BodyYZX,  BodyZXY,  BodyXZY,  BodyYXZ,  BodyZYX
                   BodyXYX,  BodyXZX,  BodyYXY,  BodyYZY,  BodyZXZ,  BodyZYZ
                  SpaceXYZ, SpaceYZX, SpaceZXY, SpaceXZY, SpaceYXZ, SpaceZYX
                  SpaceXYX, SpaceXZX, SpaceYXY, SpaceYZY, SpaceZXZ, SpaceZYZ
                  Body-XYZ, BodyX-YZ, BodyXY-Z, Body-X-YZ,  Space-X-Y-Z, etc.

           e0, e1, e2, e3 -- expressions for Euler parameters (quaternion).

           rho1, rho2, rho3 -- expressions for Rodrigues parameters.

           Rxx,Rxy,Rxz, Ryx,Ryy,Ryz, Rzx,Rzy,Rzz - expressions for elements.

           matrix33 -- 3x3 rotation matrix (direction cosine matrix).

  Output:  Sets and returns the rotation matrix B_A that is associated with
           right-handed rotations of B relative to A.  This rotation matrix
           relates unit vectors Bx>, By>, Bz>  to  Ax>, Ay>, Az>.

  Remark:  The command SetRotationMatrixODE also forms ODEs for the
           associated variables, e.g., the angles, or quaternion or ...

  Remark:  Definitions of orientation angles, Euler parameters (quaternion),
           Rodrigues parameters, and direction cosines are in
           Kane, T. R.,  Likins, P. W.,  and Levinson D. A.,
           Spacecraft Dynamics, McGraw-Hill, 1983, Ch. 1., and
           Mitiguy, Paul, Advanced Dynamics for Professional
           Mechanical, Aerospace, and BioMechanical Engineers.

 Related:  <a href="#Rotate"><b>Rotate</b></a>  <a href="#RotateX"><b>RotateX</b></a>  <a href="#RotateY"><b>RotateY</b></a>  <a href="#RotateZ"><b>RotateZ</b></a>
           <a href="#RotateX"><b>RotateNegativeX</b></a>  <a href="#RotateY"><b>RotateNegativeY</b></a>  <a href="#RotateZ"><b>RotateNegativeZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixY</b></a>  <a href="#SetRotationMatrixZ"><b>SetRotationMatrixZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixNegativeX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixNegativeY</b></a>  ...
           <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>  <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>  <a href="#SetAngularAcceleration"><b>SetAngularAcceleration</b></a>
           <a href="#GetRotationMatrix"><b>GetRotationMatrix</b></a>  <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>  <a href="#GetAngularAcceleration"><b>GetAngularAcceleration</b></a>
           <a href="#SetRotationMatrixODE"><b>SetRotationMatrixODE</b></a>   <a href="#SetRigidTransform"><b>SetRigidTransform</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Examples 1 & 2: SetRotationMatrix (simple rotations with one angle) 
   (3) %--------------------------------------------------------------------
   (4) AutoOverwrite ON
   (5) RigidFrame A, B
   (6) Variable   q1, q2, q3
   (7) %--------------------------------------------------------------------
   (8) B.SetRotationMatrix( A, -BodyZ,  q1 )
-> (9) B_A = [cos(q1), -sin(q1), 0;  sin(q1), cos(q1), 0;  0, 0, 1]

   (10) B.SetRotationMatrix( A, UnitVector(3*By>+4*Bz>), q1 )
-> (11) B_A[1,1] = cos(q1)
-> (12) B_A[1,2] = 0.8*sin(q1)
-> (13) B_A[1,3] = -0.6*sin(q1)
-> (14) B_A[2,1] = -0.8*sin(q1)
-> (15) B_A[2,2] = 0.36 + 0.64*cos(q1)
-> (16) B_A[2,3] = 0.48 - 0.48*cos(q1)
-> (17) B_A[3,1] = 0.6*sin(q1)
-> (18) B_A[3,2] = 0.48 - 0.48*cos(q1)
-> (19) B_A[3,3] = 0.64 + 0.36*cos(q1)

   (20) %--------------------------------------------------------------------
   (21) % Example 3: SetRotationMatrix (successive rotations with two angles)
   (22) %--------------------------------------------------------------------
   (23) B.SetRotationMatrix( A,  Space-Y-X,  q1, q2 )
-> (24) B_A[1,1] = cos(q1)
-> (25) B_A[1,2] = sin(q1)*sin(q2)
-> (26) B_A[1,3] = sin(q1)*cos(q2)
-> (27) B_A[2,1] = 0
-> (28) B_A[2,2] = cos(q2)
-> (29) B_A[2,3] = -sin(q2)
-> (30) B_A[3,1] = -sin(q1)
-> (31) B_A[3,2] = sin(q2)*cos(q1)
-> (32) B_A[3,3] = cos(q1)*cos(q2)

   (33) %--------------------------------------------------------------------
   (34) % Example 4: SetRotationMatrix (successive rotations with three angles)
   (35) %--------------------------------------------------------------------
   (36) B.SetRotationMatrix( A, BodyXYZ,   q1, q2, q3 )                 
-> (37) B_A[1,1] = cos(q2)*cos(q3)
-> (38) B_A[1,2] = sin(q3)*cos(q1) + sin(q1)*sin(q2)*cos(q3)
-> (39) B_A[1,3] = sin(q1)*sin(q3) - sin(q2)*cos(q1)*cos(q3)
-> (40) B_A[2,1] = -sin(q3)*cos(q2)
-> (41) B_A[2,2] = cos(q1)*cos(q3) - sin(q1)*sin(q2)*sin(q3)
-> (42) B_A[2,3] = sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1)
-> (43) B_A[3,1] = sin(q2)
-> (44) B_A[3,2] = -sin(q1)*cos(q2)
-> (45) B_A[3,3] = cos(q1)*cos(q2)

   (46) %--------------------------------------------------------------------
   (47) % Example 5: SetRotationMatrix (Euler parameters / quaternion )
   (48) %--------------------------------------------------------------------
   (49) Variable  e0, e1, e2, e3
   (50) B.SetRotationMatrix( A,  EulerParameters, e0, e1, e2, e3 )
-> (51) B_A[1,1] = -1 + 2*e0^2 + 2*e1^2
-> (52) B_A[1,2] = 2*e0*e3 + 2*e1*e2
-> (53) B_A[1,3] = 2*e1*e3 - 2*e0*e2
-> (54) B_A[2,1] = 2*e1*e2 - 2*e0*e3
-> (55) B_A[2,2] = -1 + 2*e0^2 + 2*e2^2
-> (56) B_A[2,3] = 2*e0*e1 + 2*e2*e3
-> (57) B_A[3,1] = 2*e0*e2 + 2*e1*e3
-> (58) B_A[3,2] = 2*e2*e3 - 2*e0*e1
-> (59) B_A[3,3] = -1 + 2*e0^2 + 2*e3^2

   (60) %--------------------------------------------------------------------
   (61) % Example 6: SetRotationMatrix (Rodrigues parameters / Gibbs vector)
   (62) %--------------------------------------------------------------------
   (63) Variable  rho0, rho1, rho2
   (64) B.SetRotationMatrix( A,  RodriguesParameters, rho0, rho1, rho2 )
-> (65) B_A[1,1] = (1+rho0^2-rho1^2-rho2^2)/(1+rho0^2+rho1^2+rho2^2)
-> (66) B_A[1,2] = 2*(rho2+rho0*rho1)/(1+rho0^2+rho1^2+rho2^2)
-> (67) B_A[1,3] = -2*(rho1-rho0*rho2)/(1+rho0^2+rho1^2+rho2^2)
-> (68) B_A[2,1] = -2*(rho2-rho0*rho1)/(1+rho0^2+rho1^2+rho2^2)
-> (69) B_A[2,2] = (1+rho1^2-rho0^2-rho2^2)/(1+rho0^2+rho1^2+rho2^2)
-> (70) B_A[2,3] = 2*(rho0+rho1*rho2)/(1+rho0^2+rho1^2+rho2^2)
-> (71) B_A[3,1] = 2*(rho1+rho0*rho2)/(1+rho0^2+rho1^2+rho2^2)
-> (72) B_A[3,2] = -2*(rho0-rho1*rho2)/(1+rho0^2+rho1^2+rho2^2)
-> (73) B_A[3,3] = -(-1+rho0^2+rho1^2-rho2^2)/(1+rho0^2+rho1^2+rho2^2)

   (74) %--------------------------------------------------------------------
   (75) % Example 7: SetRotationMatrix (Poisson parameters)
   (76) %--------------------------------------------------------------------
   (77) Variable  R{1:3}{1:3}
   (78) B.SetRotationMatrix( A, PoissonParameters, R11,R12,R13, R21,R22,R23, R31,R32,R33 )
-> (79) B_A = [R11, R12, R13;  R21, R22, R23;  R31, R32, R33]

   (80) %--------------------------------------------------------------------
   (81) % Example 8: SetRotationMatrix (Directly from 3x3 matrix)
   (82) %--------------------------------------------------------------------
   (83) B.SetRotationMatrix( A, [R11,R12,R13; R21,R22,R23; R31,R32,R33] )
-> (84) B_A = [R11, R12, R13;  R21, R22, R23;  R31, R32, R33]

   (85) %--------------------------------------------------------------------
   (86) % Note: For more examples, type HELP for one of the following:
   (87) %       SetRotationMatrix
   (88) %       SetRotationMatrixX      SetRotationMatrixNegativeX
   (89) %       SetRotationMatrixY      SetRotationMatrixNegativeY
   (90) %       SetRotationMatrixZ      SetRotationMatrixNegativeZ


</PRE><nobr><a name="SetRotationMatrixAndPosition"><font color="darkBlue"><font size=+1><b>SetRotationMatrixAndPosition</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetRotationMatrixAndPosition

 Purpose:  Sets the rotation matrix and position vector associated with
           two rigid frames (or rigid bodies).

  Syntax:  B.SetRigidTransform( A, rotMatrix33, posVector )

   Input:  A, B -- names of reference frames (RigidFrame or RigidBody).

           rotMatrix33 -- expression that resolves to a 3x3 rotation matrix.
                          SetRotationMatrix shows may ways this can be done.
           posVector   -- expression that resolves to a vector
                          Example: x*Ax> + y*Ay> + z*Az>
                          or if posVector is the 3 element matrix [x, y, z],
                          posVector resolves to x*Ax> + y*Ay> + z*Az>.

  Output:  Assigns the rotation matrix B_A and position vector p_Ao_Bo> as:
           B.SetRotationMatrix( A, rotMatrix33 )
           Bo.SetPosition( Ao, posVector )

           Returns true if this method succeeds.

 Related:  <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>   <a href="#SetPosition"><b>SetPosition</b></a>
           <a href="#SetRigidTransform"><b>SetRigidTransform</b></a>   <a href="#GetRigidTransform"><b>GetRigidTransform</b></a>
           <a href="#SetVelocityAccelerationForGetGeometry"><b>SetVelocityAccelerationForGetGeometry</b></a>  <a href="#TranslateAcrossJoint"><b>TranslateAcrossJoint</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: SetRotationMatrixAndPosition
   (3) %--------------------------------------------------------------------
   (4) RigidFrame A, B, C, D, E
   (5) Variable   Rxx, Rxy, Rxz,  Ryx, Ryy, Ryz,  Rzx, Rzy, Rzz
   (6) Variable   x, y, z
   (7) rotationMatrix = [Rxx, Rxy, Rxz;  Ryx, Ryy, Ryz;  Rzx, Rzy, Rzz]
-> (8) rotationMatrix = [Rxx, Rxy, Rxz;  Ryx, Ryy, Ryz;  Rzx, Rzy, Rzz]

   (9) positionMatrix = [x;  y;  z]
-> (10) positionMatrix = [x;  y;  z]

   (11) B.SetRotationMatrixAndPosition( A,  rotationMatrix,  positionMatrix )
-> (12) B_A = [Rxx, Rxy, Rxz;  Ryx, Ryy, Ryz;  Rzx, Rzy, Rzz]
-> (13) p_Ao_Bo> = x*Ax> + y*Ay> + z*Az>

   (14) %--------------------------------------------------------------------
   (15) % Example: SetRotationMatrixAndPosition 
   (16) %--------------------------------------------------------------------
   (17) C.SetRotationMatrixAndPosition( B,  BodyZ(pi/6),  x*Bx> + y*By> + z*Bz> )
-> (18) C_B = [0.8660254, 0.5, 0;  -0.5, 0.8660254, 0;  0, 0, 1]
-> (19) p_Bo_Co> = x*Bx> + y*By> + z*Bz>

   (20) %--------------------------------------------------------------------
   (21) % Example: SetRotationMatrixAndPosition 
   (22) %--------------------------------------------------------------------
   (23) D.SetRotationMatrixAndPosition( C,  BodyXYZ(pi, pi/2, pi/3),  x*Cx> + y*Cy> + z*Cz> )
-> (24) D_C = [0, -0.8660254, 0.5;  0, -0.5, -0.8660254;  1, 0, 0]
-> (25) p_Co_Do> = x*Cx> + y*Cy> + z*Cz>

   (26) %--------------------------------------------------------------------
   (27) % Example: SetRotationMatrixAndPosition 
   (28) %--------------------------------------------------------------------
   (29) E.SetRotationMatrixAndPosition( D,  Quaternion( cos(pi/6/2), 0, 0, sin(pi/6/2) ),  x*Dx> + y*Dy> + z*Dz> )
-> (30) E_D = [0.8660254, 0.5, 0;  -0.5, 0.8660254, 0;  0, 0, 1]
-> (31) p_Do_Eo> = x*Dx> + y*Dy> + z*Dz>



</PRE><nobr><a name="SetRigidTransform"><font color="darkBlue"><font size=+1><b>SetRigidTransform</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetRigidTransform   (EXPERIMENTAL COMMAND, NOT RECOMMEND FOR USE).

 Purpose:  Sets the rotation matrix and position vector associated with
           two rigid frames (or rigid bodies).

Syntax 1:  B.SetRigidTransform( A, rotMatrix33, posVector )
Syntax 2:  B.SetRigidTransform( A, matrix34 )
Syntax 3:  B.SetRigidTransform( A, matrix44 )

   Input:  A, B -- names of reference frames (RigidFrame or RigidBody).

 Input 1:  rotMatrix33 -- expression that resolves to a 3x3 rotation matrix.
           posVector   -- expression that resolves to a vector. For example,
                          if posVector is the 3 element matrix [x, y, z],
                          posVector resolves to x*Ax> + y*Ay> + z*Az>.

 Input 2:  matrix34  -- matrix that contains a 3x3 rotation matrix and a
                        3x1 position vector matrix expressed in A, i.e.,
                        [ A_B  |  p_Ao_Bo ]

 Input 3:  matrix34  -- matrix that contains a 3x3 rotation matrix and a
                        3x1 position vector matrix expressed in A, i.e.,
                        [   A_B    |  p_Ao_Bo ]
                        [ 0, 0, 0  |    1     ]

  Output:  Assigns a rotation matrix and position vector, e.g. as follows:
           A_B = Transpose( rotMatrix33 )
           p_Ao_Bo> = posVector

           Returns true if this method succeeds.

 Related:  <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>   <a href="#SetPosition"><b>SetPosition</b></a>
           <a href="#SetRigidTransform"><b>SetRigidTransform</b></a>   <a href="#GetRigidTransform"><b>GetRigidTransform</b></a>
           <a href="#SetVelocityAccelerationForGetGeometry"><b>SetVelocityAccelerationForGetGeometry</b></a>  <a href="#TranslateAcrossJoint"><b>TranslateAcrossJoint</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: SetRigidTransform from a rotation matrix and position matrix.
   (3) %--------------------------------------------------------------------
   (4) RigidFrame A, B, C, D
   (5) Variable   Rxx, Rxy, Rxz,  Ryx, Ryy, Ryz,  Rzx, Rzy, Rzz
   (6) rotationMatrix = [Rxx, Rxy, Rxz;  Ryx, Ryy, Ryz;  Rzx, Rzy, Rzz]
-> (7) rotationMatrix = [Rxx, Rxy, Rxz;  Ryx, Ryy, Ryz;  Rzx, Rzy, Rzz]

   (8) positionMatrix = [7;  8;  9]
-> (9) positionMatrix = [7;  8;  9]

   (10) B.SetRigidTransform( A,  rotationMatrix,  positionMatrix )
-> (11) B_A = [Rxx, Rxy, Rxz;  Ryx, Ryy, Ryz;  Rzx, Rzy, Rzz]
-> (12) p_Ao_Bo> = 7*Ax> + 8*Ay> + 9*Az>

   (13) X_AB = GetRigidTransform34( A, B )
-> (14) X_AB = [Rxx, Ryx, Rzx, 7;  Rxy, Ryy, Rzy, 8;  Rxz, Ryz, Rzz, 9]

   (15) %--------------------------------------------------------------------
   (16) % Example: SetRigidTransform from a 3x4 (or 4x4) matrix
   (17) %--------------------------------------------------------------------
   (18) matrix34 = [Rxx, Rxy, Rxz, 7;  Ryx, Ryy, Ryz, 8;  Rzx, Rzy, Rzz, 9]
-> (19) matrix34 = [Rxx, Rxy, Rxz, 7;  Ryx, Ryy, Ryz, 8;  Rzx, Rzy, Rzz, 9]

   (20) C.SetRigidTransform( B,  matrix34 )
-> (21) C_B = [Rxx, Rxy, Rxz;  Ryx, Ryy, Ryz;  Rzx, Rzy, Rzz]
-> (22) p_Bo_Co> = 7*Bx> + 8*By> + 9*Bz>

   (23) X_BC = GetRigidTransform44( B, C )
-> (24) X_BC = [Rxx, Ryx, Rzx, 7;  Rxy, Ryy, Rzy, 8;  Rxz, Ryz, Rzz, 9;  0, 0, 0, 1]

   (25) %--------------------------------------------------------------------
   (26) % Example: SetRigidTransform 
   (27) %--------------------------------------------------------------------
   (28) Variable   x,  y, z
   (29) D.SetRigidTransform( C,  BodyXYZ(pi, pi/2, pi/3),  x*Cx> + y*Cy> + z*Cz> )
-> (30) D_C = [0, -0.8660254, 0.5;  0, -0.5, -0.8660254;  1, 0, 0]
-> (31) p_Co_Do> = x*Cx> + y*Cy> + z*Cz>

   (32) X_CD = GetRigidTransform34( C, D )
-> (33) X_CD = [0, 0, 1, x;  -0.8660254, -0.5, 0, y;  0.5, -0.8660254, 0, z]



</PRE><nobr><a name="GetRigidTransform"><font color="darkBlue"><font size=+1><b>GetRigidTransform</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
GetRigidTransform34  or  GetRigidTransform44   (RESERVED SYNTAX)

 Purpose:  Gets a matrix that contains the rotation matrix and position vector
           matrix associated with two rigid frames (or rigid bodies).

Syntax 1:  GetRigidTransform34( A, B )
Syntax 2:  GetRigidTransform44( A, B )

   Input:  A, B -- names of reference frames (RigidFrame or RigidBody).

Output 1:  Contains a 3x3 rotation matrix and 3x1 position vector matrix, with:
           A_B = A.GetRotationMatrix( B )
           p_Ao_Bo = Dot( p_Ao_Bo>, [Ax>; Ay>; Az>] )
           Returns 3x4 matrix:  [   A_B    |  p_Ao_Bo ]
Output 2:  Returns 4x4 matrix:  [   A_B    |  p_Ao_Bo ]
                                [ 0, 0, 0  |    1     ]

 Related:  <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>   <a href="#SetPosition"><b>SetPosition</b></a>
           <a href="#SetRigidTransform"><b>SetRigidTransform</b></a>   <a href="#GetRigidTransform"><b>GetRigidTransform</b></a>
           <a href="#SetVelocityAccelerationForGetGeometry"><b>SetVelocityAccelerationForGetGeometry</b></a>  <a href="#TranslateAcrossJoint"><b>TranslateAcrossJoint</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: GetRigidTransform34 
   (3) %--------------------------------------------------------------------
   (4) RigidFrame A, B
   (5) Variables  Rxx, Rxy, Rxz,  Ryx, Ryy, Ryz,  Rzx, Rzy, Rzz
   (6) B.SetRigidTransform( A,  [Rxx, Rxy, Rxz;  Ryx, Ryy, Ryz;  Rzx, Rzy, Rzz],  [7, 8, 9] )
-> (7) B_A = [Rxx, Rxy, Rxz;  Ryx, Ryy, Ryz;  Rzx, Rzy, Rzz]
-> (8) p_Ao_Bo> = 7*Ax> + 8*Ay> + 9*Az>

   (9) X_AB = GetRigidTransform34( A, B )
-> (10) X_AB = [Rxx, Ryx, Rzx, 7;  Rxy, Ryy, Rzy, 8;  Rxz, Ryz, Rzz, 9]

   (11) %--------------------------------------------------------------------
   (12) % Example: GetRigidTransform44 
   (13) %--------------------------------------------------------------------
   (14) X_AB := GetRigidTransform44( A, B )
-> (15) X_AB = [Rxx, Ryx, Rzx, 7;  Rxy, Ryy, Rzy, 8;  Rxz, Ryz, Rzz, 9;  0, 0, 0, 1]

   (16) %--------------------------------------------------------------------
   (17) % Example: GetRigidTransform34
   (18) %--------------------------------------------------------------------
   (19) RigidFrame C, D
   (20) Constant   q, r, s
   (21) D.SetRigidTransform( C,  BodyXYZ(pi, pi/2, pi/3),  q*Cx> + r*Cy> + s*Cz> )
-> (22) D_C = [0, -0.8660254, 0.5;  0, -0.5, -0.8660254;  1, 0, 0]
-> (23) p_Co_Do> = q*Cx> + r*Cy> + s*Cz>

   (24) X_CD = GetRigidTransform34( C, D )
-> (25) X_CD = [0, 0, 1, q;  -0.8660254, -0.5, 0, r;  0.5, -0.8660254, 0, s]



</PRE><nobr><a name="SetRotationMatrixODE"><font color="darkBlue"><font size=+1><b>SetRotationMatrixODE</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetRotationMatrixODE

 Purpose:  Sets the rotation matrix relating two sets of bases vectors.
           Forms differential equations that relate the time-derivatives
           of orientation angles, Euler parameters, Rodrigues parameters,
           or rotation matrix elements (direction cosines) to
           angular velocity measures.

Syntax 1:  B.SetRotationMatrixODE( A, SequenceIJK,      q1, q2, q3 )
Syntax 2:  B.SetRotationMatrixODE( A, EulerParameters,  e0, e1, e2, e3 )
           B.SetRotationMatrixODE( A, Quaternion,       e0, e1, e2, e3 )
Syntax 3:  B.SetRotationMatrixODE( A, RodriguesParameters, rho1, rho2, rho3 )
Syntax 4:  B.SetRotationMatrixODE( A, PoissonParameters, Rxx,Rxy, ..., Rzz )

   Input:  B, A -- name of a RigidFrame or RigidBody.

           SequenceIJK -- one of the following:
                   BodyXYZ,  BodyYZX,  BodyZXY,  BodyXZY,  BodyYXZ,  BodyZYX
                   BodyXYX,  BodyXZX,  BodyYXY,  BodyYZY,  BodyZXZ,  BodyZYZ
                  SpaceXYZ, SpaceYZX, SpaceZXY, SpaceXZY, SpaceYXZ, SpaceZYX
                  SpaceXYX, SpaceXZX, SpaceYXY, SpaceYZY, SpaceZXZ, SpaceZYZ

           q1, q2, q3 -- names of radian measures of orientation angles
           associated with right-handed rotations of B relative to A,
           that relate Bi> to Aj>  (i,j = x,y,z).

           e0, e1, e2, e3 -- names of Euler parameters (quaternion)
           that relate Bi> to Aj>  (i,j = x,y,z).

           rho1, rho2, rho3 -- names of Rodrigues parameters
           that relate Bi> to Aj>  (i,j = x,y,z).

           Rxx,Rxy,Rxz, Ryx,Ryy,Ryz, Rzx,Rzy,Rzz - names of rotation matrix
           elements that relate Bi> to Aj>  (i,j = x,y,z).

  Always:  Sets and returns the rotation matrix B_A that relates
           Bx>, By>, Bz>  to  Ax>, Ay>, Az>

Output 1:  Expresses q1', q2', and q3' in terms of q1, q2, q3,
           and B's angular velocity in A.

Output 2:  Expresses e0', e1', e2', e3' in terms of e0, e1, e2, e3,
           and B's angular velocity in A.

Output 3:  Expresses rho1', rho2', and rho3' in terms of rho1, rho2, rho3,
           and B's angular velocity in A.

Output 4:  Expresses Rxx', ... Rzz' in terms of Rxx, ... Rzz,
           and B's angular velocity in A.

  Remark:  B's angular velocity in A or its equivalent must be in the
           workspace before this command can be issued.

  Remark:  Definitions of orientation angles, Euler parameters (quaternion),
           Rodrigues parameters, and direction cosines are in
           Kane, T. R.,  Likins, P. W.,  and Levinson D. A.,
           Spacecraft Dynamics, McGraw-Hill, 1983, Ch. 1., and
           Mitiguy, Paul, Advanced Dynamics for Professional
           Mechanical, Aerospace, and BioMechanical Engineers.

 Related:  <a href="#Rotate"><b>Rotate</b></a>  <a href="#RotateX"><b>RotateX</b></a>  <a href="#RotateY"><b>RotateY</b></a>  <a href="#RotateZ"><b>RotateZ</b></a>
           <a href="#RotateX"><b>RotateNegativeX</b></a>  <a href="#RotateY"><b>RotateNegativeY</b></a>  <a href="#RotateZ"><b>RotateNegativeZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixY</b></a>  <a href="#SetRotationMatrixZ"><b>SetRotationMatrixZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixNegativeX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixNegativeY</b></a>  ...
           <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>  <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>  <a href="#SetAngularAcceleration"><b>SetAngularAcceleration</b></a>
           <a href="#GetRotationMatrix"><b>GetRotationMatrix</b></a>  <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>  <a href="#GetAngularAcceleration"><b>GetAngularAcceleration</b></a>
           <a href="#SetRotationMatrixODE"><b>SetRotationMatrixODE</b></a>  <a href="#SetEulerParameterODE"><b>SetEulerParameterODE</b></a>  <a href="#SetRodriguesParameterODE"><b>SetRodriguesParameterODE</b></a>
           <a href="#SetPoissonParameterODE"><b>SetPoissonParameterODE</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: SetRotationMatrixODE  (Orientation angles)
   (3) %--------------------------------------------------------------------
   (4) RigidFrame  A, B
   (5) Variable    q1',  q2', q3'
   (6) Variable    wx',  wy', wz'
   (7) B.SetAngularVelocity( A, wx*Bx> + wy*By> + wz*Bz> )
-> (8) w_B_A> = wx*Bx> + wy*By> + wz*Bz>

   (9) B.SetRotationMatrixODE( A, BodyXYZ, q1, q2, q3 )
-> (10) B_A[1,1] = cos(q2)*cos(q3)
-> (11) B_A[1,2] = sin(q3)*cos(q1) + sin(q1)*sin(q2)*cos(q3)
-> (12) B_A[1,3] = sin(q1)*sin(q3) - sin(q2)*cos(q1)*cos(q3)
-> (13) B_A[2,1] = -sin(q3)*cos(q2)
-> (14) B_A[2,2] = cos(q1)*cos(q3) - sin(q1)*sin(q2)*sin(q3)
-> (15) B_A[2,3] = sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1)
-> (16) B_A[3,1] = sin(q2)
-> (17) B_A[3,2] = -sin(q1)*cos(q2)
-> (18) B_A[3,3] = cos(q1)*cos(q2)
-> (19) q1' = (wx*cos(q3)-wy*sin(q3))/cos(q2)
-> (20) q2' = wx*sin(q3) + wy*cos(q3)
-> (21) q3' = wz - tan(q2)*(wx*cos(q3)-wy*sin(q3))

   (22) %--------------------------------------------------------------------
   (23) % Example 2: SetRotationMatrixODE (Euler parameters / quaternion )
   (24) %--------------------------------------------------------------------
   (25) RigidFrame  C
   (26) Variable    e0', e1', e2', e3' 
   (27) C.SetAngularVelocity( A, wx*Cx> + wy*Cy> + wz*Cz> )
-> (28) w_C_A> = wx*Cx> + wy*Cy> + wz*Cz>

   (29) C.SetRotationMatrixODE( A, Euler, e0, e1, e2, e3 )
-> (30) C_A[1,1] = -1 + 2*e0^2 + 2*e1^2
-> (31) C_A[1,2] = 2*e0*e3 + 2*e1*e2
-> (32) C_A[1,3] = 2*e1*e3 - 2*e0*e2
-> (33) C_A[2,1] = 2*e1*e2 - 2*e0*e3
-> (34) C_A[2,2] = -1 + 2*e0^2 + 2*e2^2
-> (35) C_A[2,3] = 2*e0*e1 + 2*e2*e3
-> (36) C_A[3,1] = 2*e0*e2 + 2*e1*e3
-> (37) C_A[3,2] = 2*e2*e3 - 2*e0*e1
-> (38) C_A[3,3] = -1 + 2*e0^2 + 2*e3^2
-> (39) e0' = -0.5*e1*wx - 0.5*e2*wy - 0.5*e3*wz
-> (40) e1' = 0.5*e0*wx + 0.5*e2*wz - 0.5*e3*wy
-> (41) e2' = 0.5*e0*wy + 0.5*e3*wx - 0.5*e1*wz
-> (42) e3' = 0.5*e0*wz + 0.5*e1*wy - 0.5*e2*wx

   (43) %--------------------------------------------------------------------
   (44) % Example 3: SetRotationMatrixODE  (Rodrigues parameters)
   (45) %--------------------------------------------------------------------
   (46) RigidFrame  D
   (47) Variable    r1', r2', r3' 
   (48) D.SetAngularVelocity( A, wx*Dx> + wy*Dy> + wz*Dz> )
-> (49) w_D_A> = wx*Dx> + wy*Dy> + wz*Dz>

   (50) D.SetRotationMatrixODE( A, Rodrigues, r1, r2, r3 )
-> (51) D_A[1,1] = (1+r1^2-r2^2-r3^2)/(1+r1^2+r2^2+r3^2)
-> (52) D_A[1,2] = 2*(r3+r1*r2)/(1+r1^2+r2^2+r3^2)
-> (53) D_A[1,3] = -2*(r2-r1*r3)/(1+r1^2+r2^2+r3^2)
-> (54) D_A[2,1] = -2*(r3-r1*r2)/(1+r1^2+r2^2+r3^2)
-> (55) D_A[2,2] = (1+r2^2-r1^2-r3^2)/(1+r1^2+r2^2+r3^2)
-> (56) D_A[2,3] = 2*(r1+r2*r3)/(1+r1^2+r2^2+r3^2)
-> (57) D_A[3,1] = 2*(r2+r1*r3)/(1+r1^2+r2^2+r3^2)
-> (58) D_A[3,2] = -2*(r1-r2*r3)/(1+r1^2+r2^2+r3^2)
-> (59) D_A[3,3] = -(-1+r1^2+r2^2-r3^2)/(1+r1^2+r2^2+r3^2)
-> (60) r1' = 0.5*wx*(1+r1^2) + 0.5*wz*(r2+r1*r3) - 0.5*wy*(r3-r1*r2)
-> (61) r2' = 0.5*wx*(r3+r1*r2) + 0.5*wy*(1+r2^2) - 0.5*wz*(r1-r2*r3)
-> (62) r3' = 0.5*wy*(r1+r2*r3) + 0.5*wz*(1+r3^2) - 0.5*wx*(r2-r1*r3)

   (63) %--------------------------------------------------------------------
   (64) % Example 4: SetRotationMatrixODE  (Direction cosines)
   (65) %--------------------------------------------------------------------
   (66) RigidFrame  F
   (67) Variable    C{1:3,1:3}' 
   (68) F.SetAngularVelocity( A, wx*Fx> + wy*Fy> + wz*Fz> )
-> (69) w_F_A> = wx*Fx> + wy*Fy> + wz*Fz>

   (70) F.SetRotationMatrixODE( A, Poisson, C11,C12,C13, C21,C22,C23, C31,C32,C33 )
-> (71) F_A = [C11, C12, C13;  C21, C22, C23;  C31, C32, C33]
-> (72) C11' = C21*wz - C31*wy
-> (73) C12' = C22*wz - C32*wy
-> (74) C13' = C23*wz - C33*wy
-> (75) C21' = C31*wx - C11*wz
-> (76) C22' = C32*wx - C12*wz
-> (77) C23' = C33*wx - C13*wz
-> (78) C31' = C11*wy - C21*wx
-> (79) C32' = C12*wy - C22*wx
-> (80) C33' = C13*wy - C23*wx



</PRE><nobr><a name="SetEulerParameterODE"><font color="darkBlue"><font size=+1><b>SetEulerParameterODE</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetEulerParameterODE  or  SetQuaternionODE

 Purpose:  Forms differential equations by relating the time-derivatives
           of Euler parameters (quaternion) to angular velocity measures.

  Syntax:  B.SetEulerParameterODE( A, e0, e1, e2, e3 )
           B.SetQuaternionODE(     A, e0, e1, e2, e3 )

   Input:  B, A -- name of a RigidFrame or RigidBody.

           e0, e1, e2, e3 -- names of Euler parameters (quaternion)
           that relate Bi> to Aj>  (i,j = x,y,z).

  Output:  Expresses e0', e1', e2', e3' in terms of e0, e1, e2, e3,
           and B's angular velocity in A.
           Returns the column matrix [e0; e1; e2; e3]

  Remark:  B's angular velocity in A or its equivalent must be in the
           workspace before this command can be issued.

  Remark:  Definitions of Euler parameters (quaternions) are in
           Kane, T. R.,  Likins, P. W.,  and Levinson D. A.,
           Spacecraft Dynamics, McGraw-Hill, 1983, Ch. 1., and
           Mitiguy, Paul, Advanced Dynamics for Professional
           Mechanical, Aerospace, and BioMechanical Engineers.

 Related:  <a href="#Rotate"><b>Rotate</b></a>  <a href="#RotateX"><b>RotateX</b></a>  <a href="#RotateY"><b>RotateY</b></a>  <a href="#RotateZ"><b>RotateZ</b></a>
           <a href="#RotateX"><b>RotateNegativeX</b></a>  <a href="#RotateY"><b>RotateNegativeY</b></a>  <a href="#RotateZ"><b>RotateNegativeZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixY</b></a>  <a href="#SetRotationMatrixZ"><b>SetRotationMatrixZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixNegativeX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixNegativeY</b></a>  ...
           <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>  <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>  <a href="#SetAngularAcceleration"><b>SetAngularAcceleration</b></a>
           <a href="#GetRotationMatrix"><b>GetRotationMatrix</b></a>  <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>  <a href="#GetAngularAcceleration"><b>GetAngularAcceleration</b></a>
           <a href="#SetRotationMatrixODE"><b>SetRotationMatrixODE</b></a>  <a href="#SetEulerParameterODE"><b>SetEulerParameterODE</b></a>  <a href="#SetRodriguesParameterODE"><b>SetRodriguesParameterODE</b></a>
           <a href="#SetPoissonParameterODE"><b>SetPoissonParameterODE</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: SetEulerParameterODE
   (3) %--------------------------------------------------------------------
   (4) RigidFrame  A, B
   (5) Variable    wx,  wy,  wz
   (6) Variable    e0', e1', e2', e3' 
   (7) B.SetAngularVelocity( A, wx*Bx> + wy*By> + wz*Bz> )
-> (8) w_B_A> = wx*Bx> + wy*By> + wz*Bz>

   (9) B.SetEulerParameterODE( A, e0, e1, e2, e3 )
-> (10) e0' = -0.5*e1*wx - 0.5*e2*wy - 0.5*e3*wz
-> (11) e1' = 0.5*e0*wx + 0.5*e2*wz - 0.5*e3*wy
-> (12) e2' = 0.5*e0*wy + 0.5*e3*wx - 0.5*e1*wz
-> (13) e3' = 0.5*e0*wz + 0.5*e1*wy - 0.5*e2*wx



</PRE><nobr><a name="SetRodriguesParameterODE"><font color="darkBlue"><font size=+1><b>SetRodriguesParameterODE</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetRodriguesParameterODE

 Purpose:  Forms differential equations by relating the time-derivatives
           of Rodrigues parameters to angular velocity measures.

  Syntax:  B.SetRodriguesParameterODE( A, r1, r2, r3 )

   Input:  B, A -- name of a RigidFrame or RigidBody.

           r1, r2, r3 -- names of Rodrigues parameters
           that relate Bi> to Aj>  (i,j = x,y,z).

  Output:  Expresses r1', r2', and r3' in terms of r1, r2, r3,
           and B's angular velocity in A.
           Returns the column matrix [r1; r2; r3]

  Remark:  B's angular velocity in A or its equivalent must be in the
           workspace before this command can be issued.

  Remark:  Euler-Rodrigues parameters (or Gibbs vector) were invented
           by Euler 1770 and rediscovered by Rodrigues in 1840.
           Definitions of Rodrigues parameters (Gibbs vectors) are in
           Kane, T. R.,  Likins, P. W.,  and Levinson D. A.,
           Spacecraft Dynamics, McGraw-Hill, 1983, Ch. 1., and
           Mitiguy, Paul, Advanced Dynamics for Professional
           Mechanical, Aerospace, and BioMechanical Engineers.

 Related:  <a href="#Rotate"><b>Rotate</b></a>  <a href="#RotateX"><b>RotateX</b></a>  <a href="#RotateY"><b>RotateY</b></a>  <a href="#RotateZ"><b>RotateZ</b></a>
           <a href="#RotateX"><b>RotateNegativeX</b></a>  <a href="#RotateY"><b>RotateNegativeY</b></a>  <a href="#RotateZ"><b>RotateNegativeZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixY</b></a>  <a href="#SetRotationMatrixZ"><b>SetRotationMatrixZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixNegativeX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixNegativeY</b></a>  ...
           <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>  <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>  <a href="#SetAngularAcceleration"><b>SetAngularAcceleration</b></a>
           <a href="#GetRotationMatrix"><b>GetRotationMatrix</b></a>  <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>  <a href="#GetAngularAcceleration"><b>GetAngularAcceleration</b></a>
           <a href="#SetRotationMatrixODE"><b>SetRotationMatrixODE</b></a>  <a href="#SetEulerParameterODE"><b>SetEulerParameterODE</b></a>  <a href="#SetRodriguesParameterODE"><b>SetRodriguesParameterODE</b></a>
           <a href="#SetPoissonParameterODE"><b>SetPoissonParameterODE</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: SetRodriguesParameterODE
   (3) %--------------------------------------------------------------------
   (4) RigidFrame  A, B
   (5) Variable    wx,  wy,  wz
   (6) Variable    r1', r2', r3' 
   (7) B.SetAngularVelocity( A, wx*Bx> + wy*By> + wz*Bz> )
-> (8) w_B_A> = wx*Bx> + wy*By> + wz*Bz>

   (9) B.SetRodriguesParameterODE( A, r1, r2, r3 )
-> (10) r1' = 0.5*wx*(1+r1^2) + 0.5*wz*(r2+r1*r3) - 0.5*wy*(r3-r1*r2)
-> (11) r2' = 0.5*wx*(r3+r1*r2) + 0.5*wy*(1+r2^2) - 0.5*wz*(r1-r2*r3)
-> (12) r3' = 0.5*wy*(r1+r2*r3) + 0.5*wz*(1+r3^2) - 0.5*wx*(r2-r1*r3)



</PRE><nobr><a name="SetPoissonParameterODE"><font color="darkBlue"><font size=+1><b>SetPoissonParameterODE</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetPoissonParameterODE

 Purpose:  Forms differential equations by relating the time-derivatives
           of Rodrigues parameters to angular velocity measures.

  Syntax:  B.SetPoissonParameterODE( A, Rxx,Rxy,Rxz, Ryx,Ryy,Ryz, Rzx,Rzy,Rzz )

   Input:  B, A -- name of a RigidFrame or RigidBody.

           Rxx,Rxy,Rxz, Ryx,Ryy,Ryz, Rzx,Rzy,Rzz - names of rotation matrix
           elements that relate Bi> to Aj>  (i,j = x,y,z).

  Output:  Expresses Rxx', ... Rzz', in terms of Rxx, ... Rzz,
           and B's angular velocity in A.
           Returns 3x3 matrix [Rxx,Rxy,Rxz; Ryx,Ryy,Ryz; Rzx,Rzy,Rzz]

  Remark:  B's angular velocity in A or its equivalent must be in the
           workspace before this command can be issued.

  Remark:  Definitions of Poisson parameters are in
           Kane, T. R.,  Likins, P. W.,  and Levinson D. A.,
           Spacecraft Dynamics, McGraw-Hill, 1983, Ch. 1., and
           Mitiguy, Paul, Advanced Dynamics for Professional
           Mechanical, Aerospace, and BioMechanical Engineers.

 Related:  <a href="#Rotate"><b>Rotate</b></a>  <a href="#RotateX"><b>RotateX</b></a>  <a href="#RotateY"><b>RotateY</b></a>  <a href="#RotateZ"><b>RotateZ</b></a>
           <a href="#RotateX"><b>RotateNegativeX</b></a>  <a href="#RotateY"><b>RotateNegativeY</b></a>  <a href="#RotateZ"><b>RotateNegativeZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixY</b></a>  <a href="#SetRotationMatrixZ"><b>SetRotationMatrixZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixNegativeX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixNegativeY</b></a>  ...
           <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>  <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>  <a href="#SetAngularAcceleration"><b>SetAngularAcceleration</b></a>
           <a href="#GetRotationMatrix"><b>GetRotationMatrix</b></a>  <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>  <a href="#GetAngularAcceleration"><b>GetAngularAcceleration</b></a>
           <a href="#SetRotationMatrixODE"><b>SetRotationMatrixODE</b></a>  <a href="#SetEulerParameterODE"><b>SetEulerParameterODE</b></a>  <a href="#SetRodriguesParameterODE"><b>SetRodriguesParameterODE</b></a>
           <a href="#SetPoissonParameterODE"><b>SetPoissonParameterODE</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: SetPoissonParameterODE
   (3) %--------------------------------------------------------------------
   (4) RigidFrame  A, B
   (5) Variable    wx,  wy,  wz
   (6) Variable    Rxx', Rxy', Rxz'
   (7) Variable    Ryx', Ryy', Ryz'
   (8) Variable    Rzx', Rzy', Rzz'
   (9) B.SetAngularVelocity( A, wx*Bx> + wy*By> + wz*Bz> )
-> (10) w_B_A> = wx*Bx> + wy*By> + wz*Bz>

   (11) B.SetPoissonParameterODE( A, Rxx,Rxy,Rxz, Ryx,Ryy,Ryz, Rzx,Rzy,Rzz )
-> (12) Rxx' = Ryx*wz - Rzx*wy
-> (13) Rxy' = Ryy*wz - Rzy*wy
-> (14) Rxz' = Ryz*wz - Rzz*wy
-> (15) Ryx' = Rzx*wx - Rxx*wz
-> (16) Ryy' = Rzy*wx - Rxy*wz
-> (17) Ryz' = Rzz*wx - Rxz*wz
-> (18) Rzx' = Rxx*wy - Ryx*wx
-> (19) Rzy' = Rxy*wy - Ryy*wx
-> (20) Rzz' = Rxz*wy - Ryz*wx



</PRE><nobr><a name="SetRotationMatrixX"><font color="darkBlue"><font size=+1><b>SetRotationMatrixX</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetRotationMatrixX     SetRotationMatrixNegativeX

 Purpose:  Forms the rotation matrix (direction cosine matrix) associated
           with the right-handed rotation of a rigid basis (e.g., B)
           relative to another rigid basis (e.g., A).

Syntax 1:  B.SetRotationMatrixX( A, q )
Syntax 2:  B.SetRotationMatrixNegativeX( A, q )

   Input:  B, A -- name of a RigidFrame or RigidBody.
           q -- expressions for an angle.

Output 1:  Sets and returns the B_A rotation matrix formed by a right-handed
           rotation of B relative to A about  Ax> = Bx>  by the angle q.

Output 2:  Same as Output 1, except B rotates about  -Ax> = -Bx>.

  Remark:  SetRotationMatrixPositiveX is identical to SetRotationMatrixX

 Related:  <a href="#Rotate"><b>Rotate</b></a>  <a href="#RotateX"><b>RotateX</b></a>  <a href="#RotateY"><b>RotateY</b></a>  <a href="#RotateZ"><b>RotateZ</b></a>
           <a href="#RotateX"><b>RotateNegativeX</b></a>  <a href="#RotateY"><b>RotateNegativeY</b></a>  <a href="#RotateZ"><b>RotateNegativeZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixY</b></a>  <a href="#SetRotationMatrixZ"><b>SetRotationMatrixZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixNegativeX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixNegativeY</b></a>  ...
           <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>  <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>  <a href="#SetAngularAcceleration"><b>SetAngularAcceleration</b></a>
           <a href="#GetRotationMatrix"><b>GetRotationMatrix</b></a>  <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>  <a href="#GetAngularAcceleration"><b>GetAngularAcceleration</b></a>
           <a href="#SetRotationMatrixODE"><b>SetRotationMatrixODE</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  SetRotationMatrixX
   (3) %--------------------------------------------------------------------
   (4) RigidFrame     A, B, C
   (5) Variable       q
   (6) B.SetRotationMatrixX( A, q )
-> (7) B_A = [1, 0, 0;  0, cos(q), sin(q);  0, -sin(q), cos(q)]

   (8) %--------------------------------------------------------------------
   (9) % Example 2:  SetRotationMatrixNegativeX
   (10) %--------------------------------------------------------------------
   (11) C.SetRotationMatrixNegativeX( B, t )
-> (12) C_B = [1, 0, 0;  0, cos(t), -sin(t);  0, sin(t), cos(t)]

   (13) %--------------------------------------------------------------------
   (14) % Note: For more HELP, try:  Rotate     SetRotationMatrix  
   (15) %                            RotateX    SetRotationMatrixX  
   (16) %                            RotateY    SetRotationMatrixY  
   (17) %                            RotateZ    SetRotationMatrixZ


</PRE><nobr><a name="SetRotationMatrixY"><font color="darkBlue"><font size=+1><b>SetRotationMatrixY</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetRotationMatrixY     SetRotationMatrixNegativeY

 Purpose:  Forms the rotation matrix (direction cosine matrix) associated
           with the right-handed rotation of a rigid basis (e.g., B)
           relative to another rigid basis (e.g., A).

Syntax 1:  B.SetRotationMatrixY( A, q )
Syntax 2:  B.SetRotationMatrixNegativeY( A, q )

   Input:  B, A -- name of a RigidFrame or RigidBody.
           q -- expressions for an angle

Output 1:  Sets and returns the B_A rotation matrix formed by a right-handed
           rotation of B relative to A about  Ay> = By>  by the angle q.

Output 2:  Same as Output 1, except B rotates about  -Ay> = -By>.

  Remark:  SetRotationMatrixPositiveY is identical to SetRotationMatrixY.

 Related:  <a href="#Rotate"><b>Rotate</b></a>  <a href="#RotateX"><b>RotateX</b></a>  <a href="#RotateY"><b>RotateY</b></a>  <a href="#RotateZ"><b>RotateZ</b></a>
           <a href="#RotateX"><b>RotateNegativeX</b></a>  <a href="#RotateY"><b>RotateNegativeY</b></a>  <a href="#RotateZ"><b>RotateNegativeZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixY</b></a>  <a href="#SetRotationMatrixZ"><b>SetRotationMatrixZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixNegativeX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixNegativeY</b></a>  ...
           <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>  <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>  <a href="#SetAngularAcceleration"><b>SetAngularAcceleration</b></a>
           <a href="#GetRotationMatrix"><b>GetRotationMatrix</b></a>  <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>  <a href="#GetAngularAcceleration"><b>GetAngularAcceleration</b></a>
           <a href="#SetRotationMatrixODE"><b>SetRotationMatrixODE</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  SetRotationMatrixY
   (3) %--------------------------------------------------------------------
   (4) RigidFrame     A, B, C
   (5) Variable       q
   (6) B.SetRotationMatrixY( A, q )
-> (7) B_A = [cos(q), 0, -sin(q);  0, 1, 0;  sin(q), 0, cos(q)]

   (8) %--------------------------------------------------------------------
   (9) % Example 2:  SetRotationMatrixNegativeY
   (10) %--------------------------------------------------------------------
   (11) C.SetRotationMatrixNegativeY( B, t )
-> (12) C_B = [cos(t), 0, sin(t);  0, 1, 0;  -sin(t), 0, cos(t)]

   (13) %--------------------------------------------------------------------
   (14) % Note: For more HELP, try:  Rotate     SetRotationMatrix  
   (15) %                            RotateX    SetRotationMatrixX  
   (16) %                            RotateY    SetRotationMatrixY  
   (17) %                            RotateZ    SetRotationMatrixZ


</PRE><nobr><a name="SetRotationMatrixZ"><font color="darkBlue"><font size=+1><b>SetRotationMatrixZ</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetRotationMatrixZ     SetRotationMatrixNegativeZ

 Purpose:  Forms the rotation matrix (direction cosine matrix) associated
           with the right-handed rotation of a rigid basis (e.g., B)
           relative to another rigid basis (e.g., A).

Syntax 1:  B.SetRotationMatrixZ( A, q )
Syntax 2:  B.SetRotationMatrixNegativeZ( A, q )

   Input:  B, A -- name of a RigidFrame or RigidBody.
           q -- expressions for an angle

Output 1:  Sets and returns the B_A rotation matrix formed by a right-handed
           rotation of B relative to A about  Az> = Bz>  by the angle q.

Output 2:  Same as Output 1, except B rotates about  -Az> = -Bz>.

  Remark:  SetRotationMatrixPositiveZ is identical to SetRotationMatrixY.

 Related:  <a href="#Rotate"><b>Rotate</b></a>  <a href="#RotateX"><b>RotateX</b></a>  <a href="#RotateY"><b>RotateY</b></a>  <a href="#RotateZ"><b>RotateZ</b></a>
           <a href="#RotateX"><b>RotateNegativeX</b></a>  <a href="#RotateY"><b>RotateNegativeY</b></a>  <a href="#RotateZ"><b>RotateNegativeZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixY</b></a>  <a href="#SetRotationMatrixZ"><b>SetRotationMatrixZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixNegativeX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixNegativeY</b></a>  ...
           <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>  <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>  <a href="#SetAngularAcceleration"><b>SetAngularAcceleration</b></a>
           <a href="#GetRotationMatrix"><b>GetRotationMatrix</b></a>  <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>  <a href="#GetAngularAcceleration"><b>GetAngularAcceleration</b></a>
           <a href="#SetRotationMatrixODE"><b>SetRotationMatrixODE</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example:  SetRotationMatrixZ
   (3) %--------------------------------------------------------------------
   (4) RigidFrame     A, B, C
   (5) Variable       q
   (6) B.SetRotationMatrixZ( A, q )
-> (7) B_A = [cos(q), sin(q), 0;  -sin(q), cos(q), 0;  0, 0, 1]

   (8) %--------------------------------------------------------------------
   (9) % Example:  SetRotationMatrixNegativeZ
   (10) %--------------------------------------------------------------------
   (11) C.SetRotationMatrixNegativeZ( B, t )
-> (12) C_B = [cos(t), -sin(t), 0;  sin(t), cos(t), 0;  0, 0, 1]

   (13) %--------------------------------------------------------------------
   (14) % Note: For more HELP, try:  Rotate     SetRotationMatrix  
   (15) %                            RotateX    SetRotationMatrixX  
   (16) %                            RotateY    SetRotationMatrixY  
   (17) %                            RotateZ    SetRotationMatrixZ


</PRE><nobr><a name="SetPosition"><font color="darkBlue"><font size=+1><b>SetPosition</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetPosition

 Purpose:  Sets a point's position from another point.

  Syntax:  Q.SetPosition( fromPoint, positionVector )

   Input:  Q, fromPoint -- names of points (e.g., Point or Particle).
           positionVector -- a position vector.

  Output:  Sets and returns Q's position vector from fromPoint.

 Related:  <a href="#Translate"><b>Translate</b></a>        <a href="#SetPositionVelocity"><b>SetPositionVelocity</b></a>   <a href="#SetVelocityAcceleration"><b>SetVelocityAcceleration</b></a>
           <a href="#SetPosition"><b>SetPosition</b></a>      <a href="#GetPosition"><b>GetPosition</b></a>   <a href="#GetDistance"><b>GetDistance</b></a>  <a href="#GetDistance"><b>GetDistanceSquared</b></a>
           <a href="#SetVelocity"><b>SetVelocity</b></a>      <a href="#GetVelocity"><b>GetVelocity</b></a>   <a href="#GetSpeed"><b>GetSpeed</b></a>     <a href="#GetElongation"><b>GetElongation</b></a>
           <a href="#SetAcceleration"><b>SetAcceleration</b></a>  <a href="#GetAcceleration"><b>GetAcceleration</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: SetPosition 
   (3) %--------------------------------------------------------------------
   (4) RigidFrame N             
   (5) Point      P
   (6) Particle   Q            
   (7) Variable   xP, yP, zP
   (8) Variable   xQ, yQ, zQ
   (9) P.SetPosition( No, xP*Nx> + yP*Ny> + zP*Nz> )
-> (10) p_No_P> = xP*Nx> + yP*Ny> + zP*Nz>

   (11) Q.SetPosition( P,  xQ*Nx> + yQ*Ny> + zQ*Nz> )
-> (12) p_P_Q> = xQ*Nx> + yQ*Ny> + zQ*Nz>

   (13) QPositionVectorFromNo> = Q.GetPosition( No )
-> (14) QPositionVectorFromNo> = (xP+xQ)*Nx> + (yP+yQ)*Ny> + (zP+zQ)*Nz>



</PRE><nobr><a name="SetPositionVelocity"><font color="darkBlue"><font size=+1><b>SetPositionVelocity</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetPositionVelocity

 Purpose:  Sets a point's position from another point.
           Sets a point's velocity in a reference frame.

Syntax 1:  Q.SetPositionVelocity( fromPoint, positionVector )
           (Note: positionVector may be differentiated).

Syntax 2:  Q.SetPositionVelocity( fromPoint, positionVector, BFixed )
           (Note: positionVector will NOT be differentiated).

Syntax 3:  Q.SetPositionVelocity( fromPoint, positionVector, BFrame, BQ )
           (Note: positionVector may be differentiated).

   Input:  Q -- name of a point.

           fromPoint -- Point whose velocity in the NewtonianFrame
                        (or designated frame) is known (in the workspace).

           BFixed -- Rigid frame/body on which fromPoint and Q  are fixed.
           BFrame -- Rigid frame/body on which fromPoint and BQ are fixed.
                     Q is moving on BFrame.

           BQ -- Point of BFrame that is coincident with Q.

  Output:  Sets Q's position vector from fromPoint to positionVector.
           Sets Q's velocity in the NewtonianFrame (or designated refFrame).

  Remark:  To set Q's velocity in a non-NewtonianFrame, insert refFrame (name
           of a RigidFrame or RigidBody) as the optional first argument, e.g.,
Syntax 1:  Q.SetPositionVelocity( refFrame, fromPoint, positionVector )
Syntax 2:  Q.SetPositionVelocity( refFrame, fromPoint, positionVector, BFixed )
Syntax 3:  Q.SetPositionVelocity( refFrame, fromPoint, positionVector,BFrame,BQ)

  Remark:  Use of Syntax 2 may also set the following (if not in workspace):
             fromPoint's velocity and acceleration in BFixed to 0>
             Q's         velocity and acceleration in BFixed to 0>

           Use of Syntax 3 may also set the following (if not in workspace):
             fromPoint's velocity and acceleration in BFrame to 0>
             BQ          may be defined as a physical point of BFrame
             BQ's        velocity and acceleration in BFrame to 0>
             BQ's        position from fromPoint
             Q's         velocity in BFrame (via Q' position vector fromPoint)

  Remark:  If Q is welded to rigid frame/body B, declare it:  Point Q(B).
           Alternately, if Q does not move on B (but is not welded or a
           physical point of B), use Q.SetVelocityAcceleration( B, 0> )

 Related:  <a href="#Translate"><b>Translate</b></a>        <a href="#SetPositionVelocity"><b>SetPositionVelocity</b></a>   <a href="#SetVelocityAcceleration"><b>SetVelocityAcceleration</b></a>
           <a href="#SetPosition"><b>SetPosition</b></a>      <a href="#GetPosition"><b>GetPosition</b></a>   <a href="#GetDistance"><b>GetDistance</b></a>  <a href="#GetDistance"><b>GetDistanceSquared</b></a>
           <a href="#SetVelocity"><b>SetVelocity</b></a>      <a href="#GetVelocity"><b>GetVelocity</b></a>   <a href="#GetSpeed"><b>GetSpeed</b></a>     <a href="#GetElongation"><b>GetElongation</b></a>
           <a href="#SetAcceleration"><b>SetAcceleration</b></a>  <a href="#GetAcceleration"><b>GetAcceleration</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: SetPositionVelocity 
   (3) % Set Q1's velocity in N by differentiation. 
   (4) %--------------------------------------------------------------------
   (5) NewtonianFrame N
   (6) Point     Q1            
   (7) Variable  x1', y1'           
   (8) Q1.SetPositionVelocity( No,  x1*Nx> + y1*Ny> )
-> (9) p_No_Q1> = x1*Nx> + y1*Ny>
-> (10) v_Q1_N> = x1'*Nx> + y1'*Ny>

   (11) %--------------------------------------------------------------------
   (12) % Example 2: SetPositionVelocity 
   (13) % Set Q2's velocity in N by differentiation.
   (14) %--------------------------------------------------------------------
   (15) Point     Q2            
   (16) Variable  x2', y2'  
   (17) Q2.SetPositionVelocity( Q1,  x2*Nx> + y2*Ny> )
-> (18) p_Q1_Q2> = x2*Nx> + y2*Ny>
-> (19) v_Q2_N> = (x1'+x2')*Nx> + (y1'+y2')*Ny>

   (20) %--------------------------------------------------------------------
   (21) % Example 3: SetPositionVelocity
   (22) % Set Q3's velocity in N via two points (Q3 and Bo) fixed on B.
   (23) %--------------------------------------------------------------------
   (24) RigidBody B                  % Body B translates and rotates in N.
   (25) Point     Q3( B )            % Q3 is a point fixed on B.
   (26) Constant  L                  % Distance between Bo and Q3.
   (27) Variable  wB                 % Angular rate.
   (28) B.SetAngularVelocity( N,  wB*Bz> )
-> (29) w_B_N> = wB*Bz>

   (30) Bo.SetPositionVelocity( No,  t^2/2*Nx> )
-> (31) p_No_Bo> = 0.5*t^2*Nx>
-> (32) v_Bo_N> = t*Nx>

   (33) Q3.SetPositionVelocity( Bo,  L*Bx>,  B )
-> (34) p_Bo_Q3> = L*Bx>
-> (35) v_Q3_N> = L*wB*By> + t*Nx>

   (36) %--------------------------------------------------------------------
   (37) % Example 4: SetPositionVelocity
   (38) % Set Q4's velocity in N via one point moving on B
   (39) %--------------------------------------------------------------------
   (40) Point      Q4,  BQ4( B )     % BQ4 is point of B coincident with Q4.
   (41) Variable   x4'  
   (42) Q4.SetPositionVelocity( Bo,  x4*Bx>, B, BQ4 )
-> (43) p_Bo_Q4> = x4*Bx>
-> (44) p_Bo_BQ4> = x4*Bx>
-> (45) v_BQ4_N> = wB*x4*By> + t*Nx>
-> (46) v_Q4_B> = x4'*Bx>
-> (47) v_Q4_N> = x4'*Bx> + wB*x4*By> + t*Nx>



</PRE><nobr><a name="SetScreenDisplay"><font color="darkBlue"><font size=+1><b>SetScreenDisplay</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetScreenDisplay  (Experimental - not recommended for use)

 Purpose:  Determines whether or not to print input lines or
           response lines to the screen.

  Syntax:  SetScreenDisplay( SETTING )

   Input:  SETTING -- ON, OFF, or NONE

 Outputs:  With SetScreenDisplay(ON), all input and output information
           is displayed on screen (default behavior).

           With SetScreenDisplay(OFF), only input lines and prompts are
           displayed on screen and output response are suppressed.

           With SetScreenDisplay(NONE), neither input or output is displayed.

 Related:  <a href="#GetDefaults"><b>GetDefaults</b></a>



</PRE><nobr><a name="SetSFunctionInput"><font color="darkBlue"><font size=+1><b>SetSFunctionInput</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetSFunctionInput  ResetSFunctionInput   GetSFunctionInput

 Purpose:  Identifies scalar quantities that are to be used by the ODE and
           Solve commands while generating .mSFunction and .cSFunction codes.
           These quantities are inputs to SFunction blocks.

Syntax 1:  SetSFunctionInput( x, y, z)
Syntax 2:  ResetSFunctionInput( )
Syntax 3:  ResetSFunctionInput( x, y )
Syntax 4:  GetSFunctionInput()

   Input:  x, y, z ... -- names appearing in Specified declarations.

Output 1:  Appends x, y, z  to the matrix of names for SFunction input.
           Returns the matrix of all names for SFunction input.

Output 2:  Removes all names from SFunction input.
           Returns 1x1 zero matrix.

Output 3:  Removes all names from SFunction input.
           Appends x, y to the matrix of names for SFunction input.
           Returns the matrix of all names for SFunction input.

Output 4:  Returns the matrix of all names for SFunction input.

 Related:  <a href="#ODE"><b>ODE</b></a>  <a href="#Solve"><b>Solve</b></a>  <a href="#Input"><b>Input</b></a>  <a href="#Output"><b>Output</b></a>  <a href="#Output"><b>OutputPlot</b></a>  <a href="#Plot"><b>Plot</b></a>  <a href="#Animate"><b>Animate</b></a>
           <a href="#ConvertUnits"><b>ConvertUnits</b></a>  <a href="#GetUnitSystem"><b>GetUnitSystem</b></a>  <a href="#SetUnitSystem"><b>SetUnitSystem</b></a>  <a href="#SetDigits"><b>SetDigits</b></a>
           <a href="#Solve"><b>Solve</b></a>  <a href="#SolveDt"><b>SolveDt</b></a>  <a href="#SolveSetInput"><b>SolveSetInput</b></a>  <a href="#SolveSetInputDt"><b>SolveSetInputDt</b></a>  ...
           <a href="#SetSFunctionInput"><b>SetSFunctionInput</b></a>   <a href="#SetSFunctionInput"><b>ResetSFunctionInput</b></a>  <a href="#SetSFunctionInput"><b>GetSFunctionInput</b></a>

   (1) %---------------------------------------------------------------------
   (2) % Example: SetSFunctionInput
   (3) %---------------------------------------------------------------------
   (4) Specified  Fx = 0
-> (5) Fx = 0

   (6) Constant   m = 1000 kg
   (7) Variable   x'' = Fx / m
-> (8) x'' = Fx/m

   (9) SetSFunctionInput( Fx )
   (10) Input  x=2 m, x'=0 km/sec
   (11) Output t sec,  x meter,  x' km/sec
   (12) ODE() CarCruiseControl.mSFunction



</PRE><nobr><a name="SetPlotInterface"><font color="darkBlue"><font size=+1><b>SetPlotInterface</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetPlotInterface  (experimental command -- subject to change).

 Purpose:  Designates how plots are displayed.

Syntax 1:  SetPlotInterface  OFF
           No plots are displayed (plotting is disabled).

Syntax 2:  SetPlotInterface  Gnuplot
           Plots are displayed with Gnuplot only.
           On MacOSX, requires XQuartz to be installed.

Syntax 3:  SetPlotInterface  PlotGenesis
           Plots are displayed with the easy-to-use PlotGenesis interface.
           On MacOSX, requires XQuartz and Java JDK to be installed.

Syntax 4:  SetPlotInterface  AUTO
           If possible, plots are displayed with PlotGenesis.
           Otherwise, attempts to use Gnuplot.
           On MacOSX, requires XQuartz to be installed.

  Remark:  SetPlotInterface can be set in the MGDefaultPreferences.txt file
           that resides in the program's MGToolbox folder.

 Related:  <a href="#GetDefaults"><b>GetDefaults</b></a>  <a href="#Plot"><b>Plot</b></a>  <a href="#Output"><b>OutputPlot</b></a>  <a href="#SetPlotInterface"><b>SetPlotInterface</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: SetPlotInterface OFF     (no plot appears)
   (3) %--------------------------------------------------------------------
   (4) Variable  y' = sin(t)
-> (5) y' = sin(t)

   (6) Input     y = 2 m,  tFinal = 2 sec,  tStep = 0.1 sec
   (7) OutputPlot t sec,  y m,  y' m/s
   (8) OutputPlot t sec,  cos(y) m
   (9) SetPlotInterface  OFF
   (10) ODE() PlotInterfaceTest

   (11) %--------------------------------------------------------------------
   (12) % Example: SetPlotInterface Gnuplot (minimal plotting interface) 
   (13) %--------------------------------------------------------------------
   (14) SetPlotInterface  Gnuplot
   (15) ODE() PlotInterfaceTest

   (16) %--------------------------------------------------------------------
   (17) % Example: SetPlotInterface Auto    (attempts easy-to-use interface) 
   (18) %--------------------------------------------------------------------
   (19) SetPlotInterface  Auto
   (20) ODE() PlotInterfaceTest



</PRE><nobr><a name="SetUnitSystem"><font color="darkBlue"><font size=+1><b>SetUnitSystem</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetUnitSystem

 Purpose:  Sets a unit system for unit conversions, e.g., for units set
           in Input and Output statements and Evaluate and Solve commands.

Syntax 1:  SetUnitSystem( massUnit, lengthUnit, timeUnit )
Syntax 2:  SetUnitSystem()

   Input:  massUnit   -- the name of a unit of mass,   e.g., kg
           lengthUnit -- the name of a unit of length, e.g., cm
           timeUnit   -- the name of a unit of time,   e.g., seconds

Output 1:  Conversions are employed when the program uses Input and Output
           statements and for arguments of the Evaluate and Solve commands.

Output 2:  On-screen display of massUnit, lengthUnit, and timeUnit.

  Remark:  Program default is SetUnitSystem( kilogram, meter, second ).

 Related:  <a href="#ODE"><b>ODE</b></a>  <a href="#Solve"><b>Solve</b></a>  <a href="#Input"><b>Input</b></a>  <a href="#Output"><b>Output</b></a>  <a href="#Output"><b>OutputPlot</b></a>  <a href="#Plot"><b>Plot</b></a>  <a href="#Animate"><b>Animate</b></a>
           <a href="#Evaluate"><b>Evaluate</b></a>  <a href="#Solve"><b>Solve</b></a>  <a href="#SolveDt"><b>SolveDt</b></a>  <a href="#SolveSetInput"><b>SolveSetInput</b></a>  <a href="#SolveSetInputDt"><b>SolveSetInputDt</b></a>  ...
           <a href="#ConvertUnits"><b>ConvertUnits</b></a>  <a href="#GetUnitSystem"><b>GetUnitSystem</b></a>  <a href="#SetUnitSystem"><b>SetUnitSystem</b></a>
           <a href="#GetMassUnit"><b>GetMassUnit</b></a>   <a href="#GetMassUnit"><b>GetLengthUnit</b></a>   <a href="#GetMassUnit"><b>GetTimeUnit</b></a>   <a href="#GetMassUnit"><b>GetAngleUnit</b></a>

--------------------------------------------------------------------
Example 1: SetUnitSystem
--------------------------------------------------------------------
   (1) SetUnitSystem( kilogram, meter, second )
   (2) SetUnitSystem()
       kilogram, meter, second

--------------------------------------------------------------------
Example 2: SetUnitSystem
--------------------------------------------------------------------
   (1) SetDigits( 3 )
   (2) Constant  F, m, g
   (3) Variable  v'
   (3) v' = g + F/m
-> (4) v' = g + F/m
   (5) SetUnitSystem( kg, meter, sec )
   (6) Input  F=100 milliNewtons,  m=2 grams,  g=9.8 m/sec^2
   (7) Input  tFinal = 1 min,  tStep = 0.5 sec
   (8) Output  t, v, v km/hour, 1/2*m*v^2 milliJoules
   (9) ODE() Test.c

   The ODE command creates the C program Test.c, which on input,
   converts F from milliNewtons to kg*meter/sec^2 (Newtons) and
   converts m from grams to kg, e.g., with C statements such as

      F = 0.001 * F;
      m = 0.001 * m;

   On output, t is output in seconds (because no output units were
   specified and sec was designated as the time unit in SetUnitSystem);
   v is output with the label UNITS (which means no unit conversions
   were applied);  v is output in km/hour (a conversion from meter/sec
   to km/hour is applied); and  1/2*m*v^2 is output in milliJoules
   [a conversion from kg*meter^2/sec^2 to milliJoules is applied as
   the derived energy units designated by SetUnitSystem( kg, meter, sec)
   is kg*meter^2/sec^2 (Joules).]

   Execution of Test.c produces output file Test.1, e.g., as follows:
   Note: To produce output file Test.1 without first creating C code,
   remove the .c extension by changing line (9) to   ODE() Test

 FILE: Test.1

      t          v          v      1/2*m*v^2
    (sec)     (UNITS)   (km/hour) (milliJoules)

  0.00E-001  0.00E-001  0.00E-001  0.00E-001
  5.00E-001  2.99E+001  1.08E+002  8.94E+002
  1.00E+000  5.98E+001  2.15E+002  3.58E+003

   (1) %--------------------------------------------------------------------
   (2) % Example 3: SetUnitSystem  (affects unit conversions)  
   (3) %--------------------------------------------------------------------
   (4) SetUnitSystem( gram, cm, sec )
   (5) MetersPerCm = ConvertUnits( meter, GetUnitSystem )
-> (6) MetersPerCm = 100

   (7) InchesPerCm = ConvertUnits( inch,  GetUnitSystem )
-> (8) InchesPerCm = 2.54

   (9) a1 = Evaluate( t^2, t = 2 inches )  
-> (10) a1 = 25.8064

   (11) a2 = Evaluate( t^2, t = 2 meters )
-> (12) a2 = 40000

   (13) s1 = Solve( t^5 - 1, t=1 inch )
->   %  Note: t = 1 cm  was converted from  t = 0.3937008 inch.
-> (14) s1 = [1]

   (15) s2 = Solve( t^5 - 1, t=1 meter )
->   %  Note: t = 1 cm  was converted from  t = 0.01 meter.
-> (16) s2 = [1]



</PRE><nobr><a name="SetVelocity"><font color="darkBlue"><font size=+1><b>SetVelocity</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetVelocity

 Purpose:  Sets a point's velocity in a reference frame.

Syntax 1:  Q.SetVelocity( N, fromPoint )
Syntax 2:  Q.SetVelocity( N, fromPoint, BFixed )
Syntax 3:  Q.SetVelocity( N, fromPoint, BFrame, BQ )
Syntax 4:  Q.SetVelocity( N, velocityVector )

   Input:  Q -- name of a point.
           N -- name of a RigidFrame or RigidBody.

           fromPoint -- Point whose velocity in N is already known.

           BFixed -- Rigid frame/body on which fromPoint and Q  are fixed.
           BFrame -- Rigid frame/body on which fromPoint and BQ are fixed.
                     Q is moving on BFrame.

           BQ -- Point of BFrame that is coincident with Q.

           velocityVector -- a velocity vector.

  Output:  Sets and returns Q's velocity in N.

  Remark:  Use of Syntax 2 may also set the following (if not in workspace):
             fromPoint's velocity and acceleration in BFixed to 0>
             Q's         velocity and acceleration in BFixed to 0>

           Use of Syntax 3 may also set the following (if not in workspace):
             fromPoint's velocity and acceleration in BFrame to 0>
             BQ          may be defined as a physical point of BFrame
             BQ's        velocity and acceleration in BFrame to 0>
             BQ's        position from fromPoint
             Q's         velocity in BFrame (via Q' position vector fromPoint)

  Remark:  Q's position vector fromPoint is used by this command.

  Remark:  If Q is welded to rigid frame/body B, declare it:  Point Q(B).
           Alternately, if Q does not move on B (but is not welded or a
           physical point of B), use Q.SetVelocityAcceleration( B, 0> )

 Related:  <a href="#Translate"><b>Translate</b></a>        <a href="#SetPositionVelocity"><b>SetPositionVelocity</b></a>   <a href="#SetVelocityAcceleration"><b>SetVelocityAcceleration</b></a>
           <a href="#SetPosition"><b>SetPosition</b></a>      <a href="#GetPosition"><b>GetPosition</b></a>   <a href="#GetDistance"><b>GetDistance</b></a>  <a href="#GetDistance"><b>GetDistanceSquared</b></a>
           <a href="#SetVelocity"><b>SetVelocity</b></a>      <a href="#GetVelocity"><b>GetVelocity</b></a>   <a href="#GetSpeed"><b>GetSpeed</b></a>     <a href="#GetElongation"><b>GetElongation</b></a>
           <a href="#SetAcceleration"><b>SetAcceleration</b></a>  <a href="#GetAcceleration"><b>GetAcceleration</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: SetVelocity 
   (3) % Set Q1's velocity in N by differentiation.  Uses No fixed on N.
   (4) %--------------------------------------------------------------------
   (5) RigidFrame N             
   (6) Point      Q1            
   (7) Variable   x1', y1'           
   (8) Q1.SetPosition( No,  x1*Nx> + y1*Ny> )
-> (9) p_No_Q1> = x1*Nx> + y1*Ny>

   (10) Q1.SetVelocity( N, No )   
-> (11) v_Q1_N> = x1'*Nx> + y1'*Ny>

   (12) %--------------------------------------------------------------------
   (13) % Example 2: SetVelocity 
   (14) % Set Q2's velocity in N by differentiation and Q1's velocity in N.
   (15) %--------------------------------------------------------------------
   (16) Point     Q2            
   (17) Variable  x2', y2'  
   (18) Q2.SetPosition( Q1,  x2*Nx> + y2*Ny> )
-> (19) p_Q1_Q2> = x2*Nx> + y2*Ny>

   (20) Q2.SetVelocity( N, Q1 )     
-> (21) v_Q2_N> = (x1'+x2')*Nx> + (y1'+y2')*Ny>

   (22) %--------------------------------------------------------------------
   (23) % Example 3: SetVelocity
   (24) % Set Q3's velocity in N via two points (Q3 and Bo) fixed on B.
   (25) %--------------------------------------------------------------------
   (26) RigidBody B                  % Body B translates and rotates in N.
   (27) Point     Q3( B )            % Q3 is a point fixed on B.
   (28) Constant  L                  % Distance between Bo and Q3.
   (29) Variable  wB                 % Angular rate.
   (30) B.SetAngularVelocity( N,  wB*Bz> )
-> (31) w_B_N> = wB*Bz>

   (32) Bo.SetVelocity( N,  t*Nx> )
-> (33) v_Bo_N> = t*Nx>

   (34) Q3.SetPosition( Bo,  L*Bx> )
-> (35) p_Bo_Q3> = L*Bx>

   (36) Q3.SetVelocity( N, Bo, B )  
-> (37) v_Q3_N> = L*wB*By> + t*Nx>

   (38) %--------------------------------------------------------------------
   (39) % Example 4: SetVelocity
   (40) % Set Q4's velocity in N via one point (Q4) moving on rigid-body B.
   (41) %--------------------------------------------------------------------
   (42) Point      Q4,  BQ4( B )     % BQ4 is point of B coincident with Q4.
   (43) Variable   x4'  
   (44) Q4.SetPosition( Bo,  x4*Bx> )
-> (45) p_Bo_Q4> = x4*Bx>

   (46) Q4.SetVelocity( N, Bo, B, BQ4 )    
-> (47) p_Bo_BQ4> = x4*Bx>
-> (48) v_BQ4_N> = wB*x4*By> + t*Nx>
-> (49) v_Q4_B> = x4'*Bx>
-> (50) v_Q4_N> = x4'*Bx> + wB*x4*By> + t*Nx>



</PRE><nobr><a name="SetVelocityAcceleration"><font color="darkBlue"><font size=+1><b>SetVelocityAcceleration</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetVelocityAcceleration

 Purpose:  Sets a point's velocity and acceleration in a reference frame.

Syntax 1:  Q.SetVelocityAcceleration( N, fromPoint )
Syntax 2:  Q.SetVelocityAcceleration( N, fromPoint, BFixed )
Syntax 3:  Q.SetVelocityAcceleration( N, fromPoint, BFrame, BQ )
Syntax 4:  Q.SetVelocityAcceleration( N, velocityVector )

   Input:  Q -- name of a point.
           N -- name of a RigidFrame or RigidBody.

           fromPoint -- Point whose velocity and acceleration in N is known.

           BFixed -- Rigid frame/body on which fromPoint and Q  are fixed.
           BFrame -- Rigid frame/body on which fromPoint and BQ are fixed.
                     Q is moving on BFrame.

           BQ -- Point of BFrame that is coincident with Q.

           velocityVector -- a velocity vector.

  Output:  Sets Q's velocity and acceleration in N.

  Remark:  Use of Syntax 2 may also set the following (if not in workspace):
             fromPoint's velocity and acceleration in BFixed to 0>
             Q's         velocity and acceleration in BFixed to 0>

           Use of Syntax 3 may also set the following (if not in workspace):
             fromPoint's velocity and acceleration in BFrame to 0>
             BQ          may be defined as a physical point of BFrame
             BQ's        velocity and acceleration in BFrame to 0>
             BQ's        position from fromPoint
             Q's         velocity in BFrame (via Q' position vector fromPoint)
             Q's         acceleration in BFrame (via differentiation)

  Remark:  Q's position vector fromPoint is used by this command.

  Remark:  If Q is welded to rigid frame/body B, declare it:  Point Q(B).
           Alternately, if Q does not move on B (but is not welded or a
           physical point of B), use Q.SetVelocityAcceleration( B, 0> )

 Related:  <a href="#Translate"><b>Translate</b></a>        <a href="#SetPositionVelocity"><b>SetPositionVelocity</b></a>   <a href="#SetVelocityAcceleration"><b>SetVelocityAcceleration</b></a>
           <a href="#SetPosition"><b>SetPosition</b></a>      <a href="#GetPosition"><b>GetPosition</b></a>   <a href="#GetDistance"><b>GetDistance</b></a>  <a href="#GetDistance"><b>GetDistanceSquared</b></a>
           <a href="#SetVelocity"><b>SetVelocity</b></a>      <a href="#GetVelocity"><b>GetVelocity</b></a>   <a href="#GetSpeed"><b>GetSpeed</b></a>     <a href="#GetElongation"><b>GetElongation</b></a>
           <a href="#SetAcceleration"><b>SetAcceleration</b></a>  <a href="#GetAcceleration"><b>GetAcceleration</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: SetVelocityAcceleration 
   (3) % Set Q1's velocity and acceleration in N by differentiation. 
   (4) %--------------------------------------------------------------------
   (5) RigidFrame N             
   (6) Point      Q1            
   (7) Variable   x1'', y1''           
   (8) Q1.SetPosition( No,  x1*Nx> + y1*Ny> )
-> (9) p_No_Q1> = x1*Nx> + y1*Ny>

   (10) Q1.SetVelocityAcceleration( N, No )   
-> (11) v_Q1_N> = x1'*Nx> + y1'*Ny>
-> (12) a_Q1_N> = x1''*Nx> + y1''*Ny>

   (13) %--------------------------------------------------------------------
   (14) % Example 2: SetVelocityAcceleration 
   (15) % Set Q2's velocity and acceleration in N by differentiation.
   (16) %--------------------------------------------------------------------
   (17) Point     Q2            
   (18) Variable  x2'', y2''  
   (19) Q2.SetPosition( Q1,  x2*Nx> + y2*Ny> )
-> (20) p_Q1_Q2> = x2*Nx> + y2*Ny>

   (21) Q2.SetVelocityAcceleration( N, Q1 )     
-> (22) v_Q2_N> = (x1'+x2')*Nx> + (y1'+y2')*Ny>
-> (23) a_Q2_N> = (x1''+x2'')*Nx> + (y1''+y2'')*Ny>

   (24) %--------------------------------------------------------------------
   (25) % Example 3: SetVelocityAcceleration
   (26) % Set Q3's velocity and acceleration in N via two points fixed on B.
   (27) %--------------------------------------------------------------------
   (28) RigidBody B                  % Body B translates and rotates in N.
   (29) Point     Q3( B )            % Q3 is a point fixed on B.
   (30) Constant  L                  % Distance between Bo and Q3.
   (31) Variable  wB'                % Angular rate and its time-derivative.
   (32) B.SetAngularVelocityAcceleration( N,  wB*Bz> )
-> (33) w_B_N> = wB*Bz>
-> (34) alf_B_N> = wB'*Bz>

   (35) Bo.SetVelocityAcceleration( N,  t*Nx> )
-> (36) v_Bo_N> = t*Nx>
-> (37) a_Bo_N> = Nx>

   (38) Q3.SetPosition( Bo,  L*Bx> )
-> (39) p_Bo_Q3> = L*Bx>

   (40) Q3.SetVelocityAcceleration( N, Bo, B )  
-> (41) v_Q3_N> = L*wB*By> + t*Nx>
-> (42) a_Q3_N> = -L*wB^2*Bx> + L*wB'*By> + Nx>

   (43) %--------------------------------------------------------------------
   (44) % Example 4: SetVelocityAcceleration
   (45) % Set Q4's velocity and acceleration in N via one point moving on B.
   (46) %--------------------------------------------------------------------
   (47) Point      Q4,  BQ4( B )     % BQ4 is point of B coincident with Q4.
   (48) Variable   x4''  
   (49) Q4.SetPosition( Bo,  x4*Bx> )
-> (50) p_Bo_Q4> = x4*Bx>

   (51) Q4.SetVelocityAcceleration( N, Bo, B, BQ4 )    
-> (52) p_Bo_BQ4> = x4*Bx>
-> (53) v_BQ4_N> = wB*x4*By> + t*Nx>
-> (54) v_Q4_B> = x4'*Bx>
-> (55) v_Q4_N> = x4'*Bx> + wB*x4*By> + t*Nx>
-> (56) a_BQ4_N> = -x4*wB^2*Bx> + x4*wB'*By> + Nx>
-> (57) a_Q4_B> = x4''*Bx>
-> (58) a_Q4_N> = (x4''-x4*wB^2)*Bx> + (x4*wB'+2*wB*x4')*By> + Nx>



</PRE><nobr><a name="sign"><font color="darkBlue"><font size=+1><b>sign</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
sign   sign0IsPositive1   sign0IsNegative1   signDerivative

 Purpose:  Returns the sign of a real scalar expression.

Syntax 1:  sign( x )               % 1 if x > 0,   0 if x = 0,   -1 if x < 0.
Syntax 2:  sign0IsPositive1( x )   % Returns  1  if x >= 0,  otherwise -1.
Syntax 3:  sign0IsNegative1( x )   % Returns -1  if x <= 0,  otherwise  1.
Syntax 4:  signDerivative( x )     % Undefined   if x =  0,  otherwise  0.

   Input:  x -- a real scalar expression.

  Remark:  The sign function can combine with ceil or floor for if statements:
           isPositive      = ceil(  sign(t)/2 )              % Returns 0 or  1.
           isPositiveOr0   = ceil(  sign(t)/2 + 0.1 )        % Returns 0 or  1.
           isNegative      = floor( sign(t)/2 )              % Returns 0 or -1.
           isTGreaterThan5 = ceil( sign(t-5) / 2 )           % Returns 0 or  1.
           isTLessThan9    = ceil( sign(9-t) / 2 )           % Returns 0 or  1.
           isTBetween5And9 = isTGreaterThan5 * isTLessThan9  % Returns 0 or  1.

 Related:  <a href="#ceil"><b>ceil</b></a>  <a href="#ceil"><b>floor</b></a>  <a href="#int"><b>int</b></a>  <a href="#min"><b>max</b></a>  <a href="#min"><b>min</b></a>  <a href="#round"><b>round</b></a>  <a href="#sign"><b>sign</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>
           <a href="#IsPositive"><b>IsNegative</b></a>  <a href="#IsPositive"><b>IsNegativeOr0</b></a>  <a href="#IsPositive"><b>IsPositiveOr0</b></a>  <a href="#IsPositive"><b>IsPositive</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: Sign 
   (3) %--------------------------------------------------------------------
   (4) A1 = sign( 2.3 ) 
-> (5) A1 = 1

   (6) B1 = sign( 0 ) 
-> (7) B1 = 0

   (8) C1 = sign( -2.3 ) + sign(5+t) 
-> (9) C1 = -1 + sign(5+t)

   (10) %--------------------------------------------------------------------
   (11) % Example 2: Sign0IsPositive1 
   (12) %--------------------------------------------------------------------
   (13) A2 = Sign0IsPositive1( 2.3 ) + Sign0IsPositive1( 0 ) 
-> (14) A2 = 2

   (15) B2 = Sign0IsPositive1( -2.3 ) 
-> (16) B2 = -1

   (17) %--------------------------------------------------------------------
   (18) % Example 3: Sign0IsNegative1 
   (19) %--------------------------------------------------------------------
   (20) A3 = Sign0IsNegative1( 2.3 ) 
-> (21) A3 = 1

   (22) B3 = Sign0IsNegative1( 0 ) + Sign0IsNegative1( -2.3 ) 
-> (23) B3 = -2

   (24) %--------------------------------------------------------------------
   (25) % Example 4: SignDerivative 
   (26) %--------------------------------------------------------------------
   (27) signDt = Dt( sign(t) + Sign0IsPositive1(1+t^3) )
-> (28) signDt = signDerivative(t) + 3*t^2*signDerivative(1+t^3)



</PRE><nobr><a name="sin"><font color="darkBlue"><font size=+1><b>sin</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
sin

 Purpose:  Returns the sine of a scalar expression.

Syntax 1:  sin( scalarExpressionRad )
Syntax 2:  sinDegrees( realNumberDeg )

   Input:  scalarExpressionRad -- the radian measure of a real or
                                  complex scalar expression.
           realNumberDeg -- expression that resolves to a real number.

Output 1:  Sine of scalarExpressionRad.
Output 2:  Sine of realNumberDeg.

 Related:  <a href="#ConvertUnits"><b>ConvertUnits</b></a>  <a href="#ImaginaryNumber"><b>ImaginaryNumber</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>
           <a href="#cos"><b>cos</b></a>  <a href="#sin"><b>sin</b></a>  <a href="#tan"><b>tan</b></a>  <a href="#acos"><b>acos</b></a>  <a href="#asin"><b>asin</b></a>  <a href="#atan"><b>atan</b></a>  <a href="#atan2"><b>atan2</b></a>  <a href="#cos"><b>cosDegrees</b></a>  ...

   (1) %--------------------------------------------------------------------
   (2) % Example 1: sin   (real scalar expressions)
   (3) %--------------------------------------------------------------------
   (4) A = sin( pi/6 ) 
-> (5) A = 0.5

   (6) B = sinDegrees( 30 ) 
-> (7) B = 0.5

   (8) C = sin(t) + sin( t * ConvertUnits(deg,rad) )
-> (9) C = sin(t) + sin(0.01745329*t)

   (10) D = sin(0.5+2*t)
-> (11) D = sin(0.5+2*t)

   (12) %--------------------------------------------------------------------
   (13) % Example 2: sin   (complex scalar expressions)
   (14) %--------------------------------------------------------------------
   (15) E = sin( 2 + 3*GetImaginaryNumber() )
-> (16) E = 9.154499 - 4.168907*imaginary

   (17) F = sin( 3*GetImaginaryNumber() + t )
-> (18) F = sin(3*imaginary+t)



</PRE><nobr><a name="Solve"><font color="darkBlue"><font size=+1><b>Solve</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Solve  --  also see SolveDt, SolveSetInput, SolveSetInputDt.

 Purpose:  Solves linear and nonlinear algebraic equations.

Syntax 1:  Solve(         EqnsToSolve,  x1, x2, ... )
           Solve( METHOD, EqnsToSolve,  x1, x2, ... )
Syntax 2:  Solve(         EqnsToSolve,  x1=Guess1,  x2=Guess2,  ... )
Syntax 3:  answer = Solve( METHOD, EqnsToSolve,  x1,  x2,  ... )
Syntax 4:  answer = Solve(         EqnsToSolve,  x1=Guess1,  x2=Guess2,  ... )

   Input:  EqnsToSolve -- matrix of (or single) scalar expressions that
           are functions of x1, x2, ..., and regarded as equal to zero.
           Treated as:  EqnsToSolve[1] = 0,   EqnsToSolve[2] = 0, ...
           EqnsToSolve has various forms, whose examples include:
           EqnsToSolve          2*x - 8*t
           EqnsToSolve  = 0     2*x - 8*t  = 0
           EqnsToSolve := 0     2*x - 8*t := 0  (overwrites x without query)
           EqnsToSolve  = Rhs   2*x = 8*t
           EqnsToSolve := Rhs   2*x = 8*t       (overwrites x without query)

           x1, x2 -- the names of scalars or a matrix of scalar names.

           METHOD -- Minors, MinorsImplicit, MinorsExplicit,
                     Gauss,  GaussExplicit,  GaussExplicit,  Implicit.
           When METHOD is provided, EqnsToSolve must be linear in x1, x2, ...

           Guess1, Guess2 -- expressions that resolve to real numbers.

Output 1:  Solutions (symbolic expressions) are assigned to x1, x2, ...
Output 2:  Solutions (real numbers) are assigned to x1, x2, ...
Output 3:  Solutions (symbolic expressions) are returned in a matrix.
           Solutions are NOT assigned to x1, x2, ...
Output 4:  Solutions (real numbers) are returned in a matrix.
           Solutions are NOT assigned to x1, x2, ...

  Remark:  MINORS is advantageous for a small number of equations and
           for avoiding divide-by-zero problems other than when the
           set of equations are truly singular (the determinant of
           its coefficient matrix is zero).

           GAUSS may be better than MINORS for solving larger number
           of equations when divide-by-zero problem associated with
           pivots in Gaussian elimination can be avoided.

           IMPLICIT may be more efficient when some of the unknowns x1, x2,
           ..., are allowed to be expressed in terms of other unknowns.

           If no method is specified, a method is chosen based on
           the number of equations and number of non-zero and
           non-numerical elements in the coefficient matrix.

 Remark:   A set of n linear algebraic equations in n unknowns may
           have one unique solution or is singular (no solution or
           an infinite number of solutions).

 Remark:   Nonlinear algebraic equations may have 0, 1, 2, 3, ..., solutions.
           Their solution is approximate and its accuracy tends to improve
           as the input value assigned to absError gets smaller.
           To change the default value of absError to 1.234E-5, enter
           Input  absError = 1.234E-5

 Remark:   Providing Guess1, Guess2, ..., instructs the Solve command
           to produce a NUMERICAL solution for x1, x2, ...
           A numerical solution (and hence Guess1, Guess2) is
           required when EqnsToSolve is nonlinear in x1, x2, ...
           If necessary, symbols resolve to numbers using INPUT values.
           When EqnsToSolve are nonlinear, the numerical algorithm attempts
           to converge to a solution closest to Guess1, Guess2, ...
           When arguments have the form  x1 = 30 deg,  x2 = 45 cm/hour,
           solutions for x1 and x2 are returned in units determined by
           SetUnitSystem, e.g., x1 in units of radians and x2 in m/sec.

 Remark:   A solution may be reported even though one does not exist.
           For example,  Solve( exp(-t) = 0, t=4 )  may report a solution
           for t greater than 16.2 because the absolute value of
           exp(-16.2) is less than the default value of absError.

 Related:  <a href="#ODE"><b>ODE</b></a>  <a href="#Solve"><b>Solve</b></a>  <a href="#SolveDt"><b>SolveDt</b></a>  <a href="#SolveSetInput"><b>SolveSetInput</b></a>  <a href="#SolveSetInputDt"><b>SolveSetInputDt</b></a>  ...
           <a href="#GetPolynomialRoots"><b>GetPolynomialRoots</b></a>  <a href="#GetPolynomialRoots"><b>GetQuadraticRoots</b></a>  <a href="#GetPolynomialRoots"><b>GetQuadraticPositiveRoot</b></a>  ...
           <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRoot</b></a>  <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRootDt</b></a>  ...
           <a href="#SetAutoDifferentiate"><b>SetAutoDifferentiate</b></a>  <a href="#SetAutoOverwrite"><b>SetAutoOverwrite</b></a>
           <a href="#SetDt"><b>SetDt</b></a>  <a href="#SetDt"><b>SetNoDt</b></a>   <a href="#="><b>=</b></a>   <a href="#="><b>:=</b></a>   <a href="#="><b>+=</b></a>   <a href="#="><b>*=</b></a>   <a href="#="><b>/=</b></a>   <a href="#="><b>^=</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: Solve  (1 linear equation in 1 unknown) 
   (3) %--------------------------------------------------------------------
   (4) Variable  unknown
   (5) Solve(  2*unknown = 8*t,  unknown )
-> (6) unknown = 4*t

   (7) %--------------------------------------------------------------------
   (8) % Example 2: Solve  (2 linear equations in 2 unknowns) 
   (9) %--------------------------------------------------------------------
   (10) Variable  x, y
   (11) eqn[1] = 2*x + 4*y - 8*t      
-> (12) eqn[1] = 2*x + 4*y - 8*t

   (13) eqn[2] = 2*x + 6*y - cos(t)            
-> (14) eqn[2] = 2*x + 6*y - cos(t)

   (15) Solve(  eqn = 0,   x, y )
-> (16) x = 12*t - cos(t)
-> (17) y = 0.5*cos(t) - 4*t

   (18) %--------------------------------------------------------------------
   (19) % Example 3: Solve (2 linear equations in 2 unknowns, MethodName) 
   (20) %--------------------------------------------------------------------
   (21) Constant  a, b, c, d,  m, n
   (22) eqnZero[1] = a*x + b*y - m
-> (23) eqnZero[1] = a*x + b*y - m

   (24) eqnZero[2] = c*x + d*y - n
-> (25) eqnZero[2] = c*x + d*y - n

   (26) Solve( Minors,  eqnZero := 0,   x, y )
-> (27) x = -(b*n-d*m)/(a*d-b*c)
-> (28) y = (a*n-c*m)/(a*d-b*c)

   (29) Solve( Gauss,   eqnZero := 0,   x, y )
-> (30) x = (m-b*y)/a
-> (31) y = (n-c*m/a)/(d-b*c/a)

   (32) %--------------------------------------------------------------------
   (33) % Example 4: Solve  (1 nonlinear equation in 1 unknown with units) 
   (34) %--------------------------------------------------------------------
   (35) Solve( sin(x) := 0.75,   x = 70 deg )       % 70 degrees is a guess.
-> (36) x = 0.8480621       %  or  x = 48.59038 deg.

   (37) %--------------------------------------------------------------------
   (38) % Example 5: Solve  (2 nonlinear equations in 2 unknowns) 
   (39) %--------------------------------------------------------------------
   (40) nonlinearEqn[1] = -1 + x^2 + y^2            % Equation for a circle.
-> (41) nonlinearEqn[1] = -1 + x^2 + y^2

   (42) nonlinearEqn[2] = y - sin(x)                % Sine function.
-> (43) nonlinearEqn[2] = y - sin(x)

   (44) Solve( nonlinearEqn := 0,   x=2, y=3 )      % x=2, y=3 is a guess.
-> (45) x = 0.7390851
-> (46) y = 0.673612

   (47) %--------------------------------------------------------------------
   (48) % Example 6: Solve  (2 nonlinear equations in 2 unknowns with input) 
   (49) %--------------------------------------------------------------------
   (50) Input  a = 2 meters,  b = 1 meters   
   (51) ellipseEquation = -1 + x^2/a^2 + y^2/b^2 
-> (52) ellipseEquation = -1 + x^2/a^2 + y^2/b^2

   (53) sineFunction = y - sin(x) 
-> (54) sineFunction = y - sin(x)

   (55) Solve( [ellipseEquation; sineFunction] := 0,   x = 1 meter,  y = 2 meter )
-> (56) x = 1.029867
-> (57) y = 0.8572303

   (58) %--------------------------------------------------------------------
   (59) % Example 7: Solve (return the solutions without assignment) 
   (60) %--------------------------------------------------------------------
   (61) solutionA = Solve(  2*x - 5*t = 0,    x )
-> (62) solutionA = [2.5*t]

   (63) solutionB = Solve(  x^2 + sin(x)^2.2 - 1 = 0,    x = 2 )
-> (64) solutionB = [0.7528387]



</PRE><nobr><a name="SolveDt"><font color="darkBlue"><font size=+1><b>SolveDt</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SolveDt  --  also see Solve, SolveSetInput, SolveSetInputDt.

 Purpose:  Solves _linear_ algebraic equations.
           Differentiates the equations and solves for derivatives.

  Syntax:  SolveDt(          EqnsToSolve,  x1, x2, ... )
           SolveDt( METHOD,  EqnsToSolve,  x1, x2, ... )

   Input:  EqnsToSolve -- matrix of (or single) scalar expressions that are
           LINEAR functions of x1, x2, ..., and regarded as equal to zero.
           Treated as:  EqnsToSolve[1] = 0,   EqnsToSolve[2] = 0, ...
           EqnsToSolve has various forms, whose examples include:
           EqnsToSolve          2*x - 8*t
           EqnsToSolve  = 0     2*x - 8*t  = 0
           EqnsToSolve := 0     2*x - 8*t := 0  (overwrites x without query)
           EqnsToSolve  = Rhs   2*x = 8*t
           EqnsToSolve := Rhs   2*x = 8*t       (overwrites x without query)

           x1, x2 -- the names of scalars or a matrix of scalar names.

           METHOD -- Minors, MinorsImplicit, MinorsExplicit,
                     Gauss,  GaussExplicit,  GaussExplicit,  Implicit.

  Output:  Solutions are assigned to x1, x2, ... and x1', x2', ...

  Remark:  SolveDt recursively differentiates to form the
           1st, 2nd, 3rd, ... derivatives of x1, x2, ..., and
           stops differentiating when an nth derivative of x1, x2, ...,
           has not been declared (e.g., x1'' does not exit).

  Remark:  See additional remarks and examples by typing Help Solve.

 Related:  <a href="#ODE"><b>ODE</b></a>  <a href="#Solve"><b>Solve</b></a>  <a href="#SolveDt"><b>SolveDt</b></a>  <a href="#SolveSetInput"><b>SolveSetInput</b></a>  <a href="#SolveSetInputDt"><b>SolveSetInputDt</b></a>  ...
           <a href="#GetPolynomialRoots"><b>GetPolynomialRoots</b></a>  <a href="#GetPolynomialRoots"><b>GetQuadraticRoots</b></a>  <a href="#GetPolynomialRoots"><b>GetQuadraticPositiveRoot</b></a>  ...
           <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRoot</b></a>  <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRootDt</b></a>  ...
           <a href="#SetAutoDifferentiate"><b>SetAutoDifferentiate</b></a>  <a href="#SetAutoOverwrite"><b>SetAutoOverwrite</b></a>
           <a href="#SetDt"><b>SetDt</b></a>  <a href="#SetDt"><b>SetNoDt</b></a>   <a href="#="><b>=</b></a>   <a href="#="><b>:=</b></a>   <a href="#="><b>+=</b></a>   <a href="#="><b>*=</b></a>   <a href="#="><b>/=</b></a>   <a href="#="><b>^=</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: SolveDt  (1 linear equation in 1 unknown) 
   (3) %--------------------------------------------------------------------
   (4) Variable  z'
   (5) SolveDt(  2*z = 8*t,   z )
-> (6) z = 4*t
-> (7) z' = 4

   (8) %--------------------------------------------------------------------
   (9) % Example 2: SolveDt  (2 linear equations in 2 unknowns) 
   (10) %--------------------------------------------------------------------
   (11) Variable  s1'',  s2''
   (12) eqn[1] = s1 + 2*s2 - 8*t      
-> (13) eqn[1] = s1 + 2*s2 - 8*t

   (14) eqn[2] = s1 + 4*s2 - cos(t)            
-> (15) eqn[2] = s1 + 4*s2 - cos(t)

   (16) SolveDt(  eqn = 0,   s1, s2 )
-> (17) s1 = 16*t - cos(t)
-> (18) s2 = 0.5*cos(t) - 4*t
-> (19) s1' = 16 + sin(t)
-> (20) s2' = -4 - 0.5*sin(t)
-> (21) s1'' = cos(t)
-> (22) s2'' = -0.5*cos(t)

   (23) %--------------------------------------------------------------------
   (24) % Example 3: SolveDt (2 linear equations in 2 unknowns, MethodName) 
   (25) %--------------------------------------------------------------------
   (26) Variable  x',  y'
   (27) Constant  a, b, c, d
   (28) eqnZero[1] = a*x + b*y - t
-> (29) eqnZero[1] = a*x + b*y - t

   (30) eqnZero[2] = c*x + d*y - sin(t)
-> (31) eqnZero[2] = c*x + d*y - sin(t)

   (32) SolveDt( Minors,  eqnZero  = 0,   x, y )
-> (33) x = (d*t-b*sin(t))/(a*d-b*c)
-> (34) y = -(c*t-a*sin(t))/(a*d-b*c)
-> (35) x' = (d-b*cos(t))/(a*d-b*c)
-> (36) y' = -(c-a*cos(t))/(a*d-b*c)

   (37) SolveDt( Gauss,   eqnZero := 0,   x, y )
-> (38) x = (t-b*y)/a
-> (39) y = (sin(t)-c*t/a)/(d-b*c/a)
-> (40) x' = (1-b*y')/a
-> (41) y' = -(c/a-cos(t))/(d-b*c/a)

   (42) %--------------------------------------------------------------------
   (43) % Example 5: SolveDt (solution is value for q and symbolic for q', q'') 
   (44) %--------------------------------------------------------------------
   (45) Variable  q''                % Unknown to be solved.
   (46) Specified k''                % Regarded as known.
   (47) Input  k = 72 degrees
   (48) SolveDt(  q + cos(q) = k,   q = 20 deg )
-> (49) q = 0.3018485       %  or  q = 17.29464 deg.
-> (50) q' = k'/(1-sin(q))
-> (51) q'' = (k''+cos(q)*q'^2)/(1-sin(q))



</PRE><nobr><a name="SolveSetInput"><font color="darkBlue"><font size=+1><b>SolveSetInput</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SolveSetInput  --  also see Solve, SolveDt, SolveSetInputDt.

 Purpose:  Solves NUMERICAL linear and nonlinear algebraic equations
           and sets Input values for the unknowns.

  Syntax:  SolveSetInput( EqnsToSolve,  x1=Guess1,  x2=Guess2,  ... )

   Input:  EqnsToSolve -- matrix of (or single) scalar expressions that
           are functions of x1, x2, ..., and regarded as equal to zero.
           Treated as:  EqnsToSolve[1] = 0,   EqnsToSolve[2] = 0, ...
           EqnsToSolve has various forms, whose examples include:
           EqnsToSolve          2*x - 8*t
           EqnsToSolve  = 0     2*x - 8*t  = 0
           EqnsToSolve := 0     2*x - 8*t := 0  (overwrites x without query)
           EqnsToSolve  = Rhs   2*x = 8*t
           EqnsToSolve := Rhs   2*x = 8*t       (overwrites x without query)

           x1, x2 -- the names of scalars.

           Guess1, Guess2, -- expressions that resolve to real numbers.
           Note: When arguments have the form  x1 = 30 deg, x2 = 45 cm/hr,
           solutions for x1 and x2 are returned in units determined by
           SetUnitSystem, e.g., x1 in units of radians and x2 in m/sec.

  Output:  Solutions (real numbers) and associated units (if designated in
           Guess1, Guess2, ...) are assigned to Input values for x1, x2, ...
           Solutions (real numbers) that have been converted to the units
           designated in SetUnitSystem are returned in a matrix.

  Remark:  See additional remarks by typing Help Solve.

 Related:  <a href="#ODE"><b>ODE</b></a>  <a href="#Solve"><b>Solve</b></a>  <a href="#SolveDt"><b>SolveDt</b></a>  <a href="#SolveSetInput"><b>SolveSetInput</b></a>  <a href="#SolveSetInputDt"><b>SolveSetInputDt</b></a>  ...
           <a href="#GetPolynomialRoots"><b>GetPolynomialRoots</b></a>  <a href="#GetPolynomialRoots"><b>GetQuadraticRoots</b></a>  <a href="#GetPolynomialRoots"><b>GetQuadraticPositiveRoot</b></a>  ...
           <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRoot</b></a>  <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRootDt</b></a>  ...
           <a href="#SetAutoDifferentiate"><b>SetAutoDifferentiate</b></a>  <a href="#SetAutoOverwrite"><b>SetAutoOverwrite</b></a>
           <a href="#SetDt"><b>SetDt</b></a>  <a href="#SetDt"><b>SetNoDt</b></a>   <a href="#="><b>=</b></a>   <a href="#="><b>:=</b></a>   <a href="#="><b>+=</b></a>   <a href="#="><b>*=</b></a>   <a href="#="><b>/=</b></a>   <a href="#="><b>^=</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: SolveSetInput  (1 equation in 1 unknown) 
   (3) %--------------------------------------------------------------------
   (4) Variable z
   (5) SolveSetInput(  z^2 + sin(z)^2.2 = 1,   z = 2 )

->  %  INPUT has been assigned as follows:
->  %   z                         0.7528386616717591

   (6) %--------------------------------------------------------------------
   (7) % Example 2: SolveSetInput  (2 equations in 2 unknowns) 
   (8) %--------------------------------------------------------------------
   (9) Variable  x, y
   (10) eqn[1] = -1 + x^2 + y^2                   % Equation for a circle.
-> (11) eqn[1] = -1 + x^2 + y^2

   (12) eqn[2] = y - sin(x)                       % Sine function.
-> (13) eqn[2] = y - sin(x)

   (14) SolveSetInput(  eqn = 0,   x=2, y=3 )     % x=2, y=3 is a guess.

->   %  INPUT has been assigned as follows:
->   %   x                         0.7390851332151607
->   %   y                         0.6736120291832148

   (15) %--------------------------------------------------------------------
   (16) % Example 3: SolveSetInput  (2 equations in 2 unknowns with input) 
   (17) %--------------------------------------------------------------------
   (18) Constant  a = 2 meters,  b = 1 meter
   (19) funct[1] = -1 + x^2/a^2 + y^2/b^2         % Equation for an ellipse.
-> (20) funct[1] = -1 + x^2/a^2 + y^2/b^2

   (21) funct[2] = y - sin(x)                     % Sine function.
-> (22) funct[2] = y - sin(x)

   (23) SolveSetInput( funct = 0,  x=1, y=9 )     % x=1, y=9 is a guess.

->   %  INPUT has been assigned as follows:
->   %   x                         1.029866529322259
->   %   y                         0.8572302683325125

   (24) %--------------------------------------------------------------------
   (25) % Example 4: SolveSetInput  (guess and solution have units) 
   (26) %--------------------------------------------------------------------
   (27) SolveSetInput( [sin(x); sin(y)] = [0.3; 0.3],  x=30 deg,  y=150 deg )

->   %  INPUT has been assigned as follows:
->   %   x                         17.45760312372209       deg
->   %   y                         162.5423968762779       deg

   (28) %--------------------------------------------------------------------
   (29) % Example 5: SolveSetInput (SolveSetInput for x, return solution) 
   (30) %--------------------------------------------------------------------
   (31) answer = SolveSetInput(  cos(x) = 0,   x = 1 degree )

->   %  INPUT has been assigned as follows:
->   %   x                         90                      degree

->   %  Note: x = 1.570796 radian  was converted from  x = 90 degree.
-> (32) answer = [1.570796]



</PRE><nobr><a name="SolveSetInputDt"><font color="darkBlue"><font size=+1><b>SolveSetInputDt</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SolveSetInputDt  --  also see Solve, SolveDt, SolveSetInput.

 Purpose:  Solves linear and nonlinear algebraic equations to set NUMERICAL
           Input values for the unknowns, differentiates to find  SYMBOLIC
           expressions for the derivatives of the unknowns.

  Syntax:  SolveSetInputDt( EqnsToSolve, x1=Guess1, x2=Guess2,  ... )

   Input:  EqnsToSolve -- matrix of (or single) scalar expressions that
           are functions of x1, x2, ..., and regarded as equal to zero.
           Treated as:  EqnsToSolve[1] = 0,   EqnsToSolve[2] = 0, ...
           EqnsToSolve has various forms, whose examples include:
           EqnsToSolve          2*x - 8*t
           EqnsToSolve  = 0     2*x - 8*t  = 0
           EqnsToSolve := 0     2*x - 8*t := 0  (overwrites x without query)
           EqnsToSolve  = Rhs   2*x = 8*t
           EqnsToSolve := Rhs   2*x = 8*t       (overwrites x without query)

           x1, x2 -- the names of scalars.

           Guess1, Guess2, -- expressions that resolve to real numbers.
           Note: When arguments have the form  x1 = 30 deg, x2 = 45 cm/hr,
           solutions for x1 and x2 are returned in units determined by
           SetUnitSystem, e.g., x1 in units of radians and x2 in m/sec.

  Output:  Solutions (real numbers) and associated units (if designated in
           Guess1, Guess2, ...) are assigned to Input values for x1, x2, ...
           Solutions (real numbers) that have been converted to the units
           designated in SetUnitSystem are returned in a matrix.
           Solutions (expressions)  are assigned to x1', x2', ...

  Remark:  SolveSetInputDt recursively differentiates to form the
           1st, 2nd, 3rd, ... derivatives of x1, x2, ..., and
           stops differentiating when an nth derivative of x1, x2, ...,
           has not been declared (e.g., x1''' does not exist).

  Remark:  See additional remarks by typing Help Solve.

 Related:  <a href="#ODE"><b>ODE</b></a>  <a href="#Solve"><b>Solve</b></a>  <a href="#SolveDt"><b>SolveDt</b></a>  <a href="#SolveSetInput"><b>SolveSetInput</b></a>  <a href="#SolveSetInputDt"><b>SolveSetInputDt</b></a>  ...
           <a href="#GetPolynomialRoots"><b>GetPolynomialRoots</b></a>  <a href="#GetPolynomialRoots"><b>GetQuadraticRoots</b></a>  <a href="#GetPolynomialRoots"><b>GetQuadraticPositiveRoot</b></a>  ...
           <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRoot</b></a>  <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRootDt</b></a>  ...
           <a href="#SetAutoDifferentiate"><b>SetAutoDifferentiate</b></a>  <a href="#SetAutoOverwrite"><b>SetAutoOverwrite</b></a>
           <a href="#SetDt"><b>SetDt</b></a>  <a href="#SetDt"><b>SetNoDt</b></a>   <a href="#="><b>=</b></a>   <a href="#="><b>:=</b></a>   <a href="#="><b>+=</b></a>   <a href="#="><b>*=</b></a>   <a href="#="><b>/=</b></a>   <a href="#="><b>^=</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: SolveSetInputDt  (1 equation in 1 unknown) 
   (3) %--------------------------------------------------------------------
   (4) Variable z'
   (5) Input     t = 0 sec
   (6) SolveSetInputDt(  z + sin(z)^3 = cos(t),   z = 2 )

->  %  INPUT has been assigned as follows:
->  %   z                         0.7166169624667624

-> (7) z' = -sin(t)/(1+3*cos(z)*sin(z)^2)

   (8) %--------------------------------------------------------------------
   (9) % Example 2: SolveSetInputDt  (2 equations in 2 unknowns with input) 
   (10) %--------------------------------------------------------------------
   (11) Variable  x', y'
   (12) Constant  a = 1 meter,  b = 1 meter
   (13) funct[1] = x^2 + y^2 - cos(t)              % Time-varying circle.
-> (14) funct[1] = x^2 + y^2 - cos(t)

   (15) funct[2] = a*y - b*sin(x)                  % Sine function.
-> (16) funct[2] = a*y - b*sin(x)

   (17) SolveSetInputDt(  funct = 0,  x=2, y=3 )   % x=2,  y=3 is a guess.

->   %  INPUT has been assigned as follows:
->   %   x                         0.7390851332151607
->   %   y                         0.6736120291832148

-> (18) x' = -0.5*a*sin(t)/(a*x+b*y*cos(x))
-> (19) y' = -0.5*b*sin(t)*cos(x)/(a*x+b*y*cos(x))

   (20) %--------------------------------------------------------------------
   (21) % Example 3: SolveSetInputDt (returns value of and solves for x', x'') 
   (22) %--------------------------------------------------------------------
   (23) Variable  x''
   (24) answer = SolveSetInputDt(  x^2 = cos(x) + t,   x = 12 deg )

->   %  INPUT has been assigned as follows:
->   %   x                         47.21930325529203       deg

->   %  Note: x = 0.8241323 radian  was converted from  x = 47.2193 deg.
-> (25) x' = 1/(2*x+sin(x))
-> (26) x'' = -(2+cos(x))*x'^2/(2*x+sin(x))
-> (27) answer = [0.8241323]



</PRE><nobr><a name="SolveQuadraticPositiveRoot"><font color="darkBlue"><font size=+1><b>SolveQuadraticPositiveRoot</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SolveQuadraticPositiveRoot,    SolveQuadraticNegativeRoot
SolveQuadraticPositiveRootDt,  SolveQuadraticNegativeRootDt

 Purpose:  Solve for the positive or negative roots of a polynomial
           of degree 2 (and possibly its ordinary derivatives).

Syntax 1:  SolveQuadraticPositiveRoot( expression = 0,  x )
           SolveQuadraticNegativeRoot( expression = 0,  x )
           SolveQuadraticPositiveRoot( M,  x )
           SolveQuadraticNegativeRoot( M,  x )
Syntax 2:  SolveQuadraticPositiveRootDt( expression = 0,  x )
           SolveQuadraticNegativeRootDt( expression = 0,  x )
           SolveQuadraticPositiveRootDt( M,  x )
           SolveQuadraticNegativeRootDt( M,  x )

   Input:  M -- row or column matrix with 3 elements.  For example,
           M = [3, 5, 7]  may represent  3*x^2 + 5*x + 7.

           x   -- scalar name (variable, constant, specified, ...)
           expression -- scalar expression that is a function of x.
           A 2nd-order polynomial of the form  a*x^2 + b*x + c  is created
           from a Taylor series expansion of expression about x = 0.

Output 1:  For quadratic formula:  a*x^2 + b*x + c = 0,
           SolveQuadraticPositiveRoot sets  x = (-b + sqrt(b^2 - 4*a*c)) / 2*a
           SolveQuadraticNegativeRoot sets  x = (-b - sqrt(b^2 - 4*a*c)) / 2*a

Output 2:  Differentiates and solves to form x', x'', ...  and stops
           differentiating when the nth derivative of x has not been
           declared (e.g., x''' does not exist).

  Remark:  Use  GetQuadraticRoots  to return the positive and negative roots
           in a 2 element matrix (without assigning the result to x).
           Use  GetQuadraticPositiveRoot  to return the positive root without
           assigning the result to x.  Similarly for GetQuadraticNegativeRoot.

 Related:  GetQuadraticPolynomial( expression, x )
           returns a 3x1 column matrix whose elements are the coefficients of
           the polynomial created from a Taylor series expansion about x = 0.

 Related:  <a href="#GetPolynomialRoots"><b>GetPolynomialRoots</b></a>  <a href="#GetPolynomialRoots"><b>GetQuadraticRoots</b></a>  <a href="#GetPolynomialRoots"><b>GetQuadraticPositiveRoot</b></a>  ...
           <a href="#SetDt"><b>SetDt</b></a>  <a href="#Solve"><b>Solve</b></a>  <a href="#SolveDt"><b>SolveDt</b></a>  <a href="#SolveSetInput"><b>SolveSetInput</b></a>  <a href="#SolveSetInputDt"><b>SolveSetInputDt</b></a>  ...
           <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRoot</b></a>  <a href="#SolveQuadraticPositiveRoot"><b>SolveQuadraticPositiveRootDt</b></a>  ...
           <a href="#FactorLinear"><b>FactorLinear</b></a>  <a href="#FactorLinear"><b>FactorQuadratic</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: SolveQuadraticPositiveRoot  (root of quadratic equation) 
   (3) %--------------------------------------------------------------------
   (4) Constant a, b, c
   (5) Variable x, y
   (6) SolveQuadraticPositiveRoot( a*x^2 + b*x + c = 0,  x )  
-> (7) x = -0.5*(b-sqrt(b^2-4*a*c))/a

   (8) SolveQuadraticNegativeRoot( a*y^2 + b*y + c = 0,  y )
-> (9) y = -0.5*(b+sqrt(b^2-4*a*c))/a

   (10) %--------------------------------------------------------------------
   (11) % Example 2: SolveQuadraticPositiveRootDt  (roots with differentiation)
   (12) %--------------------------------------------------------------------
   (13) Variable z''
   (14) SolveQuadraticPositiveRootDt( a*z^2 = sin(t),  z )  
-> (15) z = sqrt(sin(t)/a)
-> (16) z' = 0.5*cos(t)/(a*z)
-> (17) z'' = -0.5*(sin(t)+2*a*z'^2)/(a*z)



</PRE><nobr><a name="Specified"><font color="darkBlue"><font size=+1><b>Specified</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Specified  or  SpecifiedEncode

 Purpose:  Declares the names of specified quantities.
           Creates an array of all names declared as Specified.

Syntax 1:  Specified        a,  b,  x+,  y-,  ...
Syntax 2:  Specified        u',  q'',  ...
Syntax 3:  SpecifiedEncode  u',  q'',  ...
Syntax 4:  Specified()

   Input:  a -- name that starts with a letter, followed by a reasonable
                number of alphanumeric characters (similarly for b).
           a, b, ... are regarded as REAL until SetComplex is ON.

           x+ -- declares x as real and non-negative.
           y- -- declares y as real and non-positive.
           Helps simplification such as  abs(x) = x  or  abs(y) = -y.

           u'  -- declares u' and u as Specified.
           q'' -- declares q'', q', and q as Specified.

Output 3:  SpecifiedEncode forces MATLAB(R), C, and Fortran programs to include
           quantities that may not otherwise appear due to code-optimization.

Output 4:  Creates an array of all names declared as Specified.

  Remark:  The 1st and 2nd ordinary derivatives of s are denoted s' and s''.
           If s is Specified, Dt(s) is permitted only if s' was also declared.

  Remark:  Variable  vs.  Specified ??
           Variable:  Regarded as unknown (to be solved).
                      Partial velocities account for assignment of Variable.
           Specified: Regarded as known   (prescribed).
                      Assigned in program  OR  leave "to be specified" in
                      special functions in MATLAB(R), C, and Fortran codes.
                      Partial velocities ignore assignment of Specified.

  Remark:  The name  a{i}bb    declares a1bb ... aibb  (i is positive integer).
           The name  a{i:j}bb  declares aibb ... ajbb  (i >= 0  and  i <= j).
           The name  a{m,n}bb  declares amnbb     (m, n are integers 0 to 9).
           The name  a{m:x,n:y}  declares amn ... axy    (m <= x and n <= y).

  Remark:  The default name of the independent variable is t.

  Remark:  To both declare and assign a Specified, type e.g.,
           Specified x'' = 2*sin(t)

 Related:  <a href="#Constant"><b>Constant</b></a>  <a href="#ImaginaryNumber"><b>ImaginaryNumber</b></a>  <a href="#Specified"><b>Specified</b></a>  <a href="#Variable"><b>Variable</b></a>
           <a href="#SetGeneralizedSpeed"><b>SetGeneralizedCoordinate</b></a>  <a href="#SetGeneralizedSpeed"><b>SetGeneralizedSpeed</b></a>
           <a href="#SetDt"><b>SetDt</b></a>  <a href="#SolveDt"><b>SolveDt</b></a>  <a href="#SetAutoDifferentiate"><b>SetAutoDifferentiate</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: Specified
   (3) %--------------------------------------------------------------------
   (4) Specified  x'+,  y-,  e{0:3}'
   (5) Specified  q'',  u'
   (6) b = sin(t) + abs(x) + x' - abs(x') + y + abs(y)
-> (7) b = sin(t) + x

   (8) derivExample = dt(b) + dt(e0) + dt(q) + dt(q') + dt(u)
-> (9) derivExample = cos(t) + e0' + q' + u' + x' + q''

   (10) u = sin(t)
-> (11) u = sin(t)

   (12) SetDt( q = t^3 )
-> (13) q = t^3
-> (14) q' = 3*t^2
-> (15) q'' = 6*t

   (16) arrayOfSpecified = Specified()
-> (17) arrayOfSpecified = [e0;  e0';  e1;  e1';  e2;  e2';  e3;  e3';  q;  q';  
        q'';  u;  u';  x;  x';  y]



</PRE><nobr><a name="Spline"><font color="darkBlue"><font size=+1><b>Spline</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Spline

 Purpose:  Fits a curve through two points with various functions: transition,
           step, pulse, bell, and polynomial.  The examples below use a
           function y(t) that connects points (t0,y0) and (tF,yF).

Syntax 1:  Spline( TRANSITION, t, t0, tF, y0, yF )
Syntax 2:  Spline( STEP,       t, t0, tF, y0, yF )
Syntax 3:  Spline( PULSE,      t, t0, tF, y0, yExtremum )
Syntax 4:  Spline( BELL,       t, t0, tF, y0, yExtremum )
Syntax 5:  Spline( LINE,       t, t0, tF, y0, yF )
           Spline( 1,          t, t0, tF, y0, yF )
Syntax 6:  Spline( CUBIC,      t, t0, tF, y0, yF, dy/dt(t0), dy/dt(tF) )
           Spline( 3,          t, t0, tF, y0, yF, dy/dt(t0), dy/dt(tF) )
Syntax 7:  Spline( n,          t, t0, tF, y0, yF,
                               d1_y0, d1_yF, d2_y0, d2_yF, ... )

   Input:  t -- name of the function's independent variable

           t0 -- value of t at one   endpoint of the function
           tF -- value of t at other endpoint of the function

           y0 -- value of the function at t = t0
           yF -- value of the function at t = tF

           yExtremum -- yMax or yMin (function's maximum or minimum value)

           n -- 1,  3,  5,  7,  9

           di_y0 --  the function's ith derivative with respect to t,
                     evaluated at t = t0.

           di_yF --  the function's ith derivative with respect to t,
                     evaluated at t = tF

Output 1:  Spline(  TRANSITION,  t, t0, tF, y0, yF )
           y0 + (yF-y0)*(t-t0)/(tF-t0) - (yF-y0)/(2*pi)*sin[2*pi*(t-t0)/(tF-t0)]
       or  y0 + (yF-y0)*dT - (yF-y0)/(2*pi) * sin(2*pi*dT)  dT = (t-t0)/(tF-t0)

           The function attains its minimum and maximum values at end-points.
           The function's 1st and 2nd derivatives with respect to t are both
           zero at both the initial and terminal point of the curve.
             y(t=t0) = y0      y(t=tF) = yF
            y'(t=t0) = 0      y'(t=tF) = 0
           y''(t=t0) = 0     y''(t=tF) = 0

Output 2:  Spline(  STEP,  t, t0, tF, y0, yF )
           0.5*y0 + 0.5*yF - (1/pi)*(y0-yF)*atan(31.821*(t0+tF-2*t)/(t0-tF))

           The function approaches y0 as t approaches negative infinity.
           The function approaches yF as t approaches positive infinity.
           At t = t0, the function is y0 + 0.01*(yF - y0).
           At t = tF, the function is y0 + 0.99*(yF - y0).

Output 3:  Spline(  PULSE,  t, t0, tF, y0, yMax )
           y0 + (yMax-y0)/(1-5*pi/16)*( pi*(-dT + 2*dT^3 - dT^4) + sin(pi*dT) )
           where dT = (t-t0)/(tF-t0)

           The function's end-points have the same value.
           The function has its maximum (or minimum) value midway
           between its end points, e.g., at t = (t0 + tF)/2
           The function's 1st and 2nd derivatives with respect to t are both
           zero at both the initial and terminal point of the curve.
             y(t=t0) =   y(y=tF) = y0        y(t=tF/2) = yMax
            y'(t=t0) =  y'(y=tF) = 0        y'(t=tF/2) = 0
           y''(t=t0) = y''(y=tF) = 0

Output 4:  Spline(  BELL,  t, t0, tF, y0, yMax )
           y0 - (y0-yMax)*exp( -2 * log(10) * (t0+tF-2*t)^2/(t0-tF)^2 )

           The function approaches y0 as t approaches +- infinity.
           The function has its maximum (or minimum) value midway
           between its end points, e.g., at t = (t0 + tF)/2
           At t = t0 and t = tF, the function is  y0 + 0.01*(yF - y0).

Output 5:  Spline(  LINE,  t, t0, tF, y0, yF )
           y0 + (yF-y0) * dT    where dT = (t-t0)/(tF-t0)

           This function is linear in t (polynomial of degree 1 in t).
           At t = t0, the function is equal to y0.
           At t = tF, the function is equal to yF.
           The function has a constant slope.
             y(t=t0) = y0    y(y=tF) = yF    y'(t) = (yF-y0) / (tF-t0)

Output 6:  Spline(  CUBIC,  t, t0, tF, y0, yF, slope0, slopeF )

           This function is cubic in t (polynomial of degree 3 in t).
           At t = t0, the function is equal to y0 and its slope is slope0.
           At t = tF, the function is equal to yF and its slope is slopeF.
             y(t=t0) = y0           y(y=tF) = yF
            y'(t=t0) = slope0      y'(t=tF) = slopeF

Output 7:  Polynomial of degree n in t   (n = 1, 3, 5, 7, or 9).
           For n = 1, no derivatives are needed.
           For n = 3, d1_y0, d1_yF are needed.
           For n = 5, d1_y0, d1_yF, d2_y0, d2_yF are needed.
           For n = 7, d1_y0, d1_yF, d2_y0, d2_yF, d3_y0, d3_yF are needed.
           For n = 9, d1_y0, d1_yF, d2_y0, d2_yF, d3_y0, d3_yF, d4_y0, d4_yF.

   (1) %--------------------------------------------------------------------
   (2) % Example 1: Spline  (TRANSITION) 
   (3) %--------------------------------------------------------------------
   (4) Variable  x
   (5) Constant xF, y0, yF
   (6) x0 = 0  
-> (7) x0 = 0

   (8) TransitionSpline = Spline( TRANSITION, x, x0, xF, y0, yF )
-> (9) TransitionSpline = y0 + 0.1591549*(y0-yF)*sin(6.283185*x/xF) - (y0-yF)*x
       /xF

   (10) %--------------------------------------------------------------------
   (11) % Example 2: Spline  (STEP) 
   (12) %--------------------------------------------------------------------
   (13) Constant  t0, tF
   (14) StepSpline = Spline( STEP, t, t0, tF, y0, yF )
-> (15) StepSpline = 0.5*y0 + 0.5*yF - 0.3183099*(y0-yF)*atan(31.82052*(t0+tF-2
        *t)/(t0-tF))

   (16) %--------------------------------------------------------------------
   (17) % Example 3: Spline  (PULSE) 
   (18) %--------------------------------------------------------------------
   (19) Constant  yExtremum 
   (20) PulseSpline = Spline( PULSE, x, x0, xF, y0, yExtremum )
-> (21) PulseSpline = y0 - 54.78763*(y0-yExtremum)*(sin(pi*x/xF)-pi*x*(xF^3+x^3
        -2*xF*x^2)/xF^4)

   (22) %--------------------------------------------------------------------
   (23) % Example 4: Spline  (BELL) 
   (24) %--------------------------------------------------------------------
   (25) BellSpline = Spline( BELL, t, t0, tF, y0, yExtremum )
-> (26) BellSpline = y0 - (y0-yExtremum)*exp(-4.60517*(t0+tF-2*t)^2/(t0-tF)^2)

   (27) %--------------------------------------------------------------------
   (28) % Example 5: Spline  (LINE) 
   (29) LinearSpline = Spline( LINE, t, 0, tF, y0, yF )
-> (30) LinearSpline = y0 - (y0-yF)*t/tF

   (31) %--------------------------------------------------------------------
   (32) % Example 6: Spline  (CUBIC) 
   (33) CubicSpline = Spline( CUBIC, t, 0, tF, y0, yF, 0, 0 )
-> (34) CubicSpline = y0 + 2*(y0-yF)*t^3/tF^3 - 3*(y0-yF)*t^2/tF^2

   (35) %--------------------------------------------------------------------
   (36) % Example 7: Spline  (Polynomial of degree n = 5) 
   (37) %--------------------------------------------------------------------
   (38) PolynomialSpline = Spline( 5, x, 0, xF, y0, yF, 0,0, 0,0 )
-> (39) PolynomialSpline = y0 + 15*(y0-yF)*x^4/xF^4 - 10*(y0-yF)*x^3/xF^3
        - 6*(y0-yF)*x^5/xF^5



</PRE><nobr><a name="Squared"><font color="darkBlue"><font size=+1><b>Squared</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Squared

 Purpose:  Forms the square of a scalar, a matrix, or a vector.

Syntax 1:  Squared( scalarExpression )
Syntax 2:  Squared( matrixExpression )
Syntax 3:  Squared( vectorExpression )

   Input:  scalarExpression -- a real or complex scalar expression.
           matrixExpression -- a matrix expression.
           vectorExpression -- a vector expression.

Output 1:  Returns scalarExpression^2.
Output 2:  Returns matrixExpression * matrixExpression.
Output 3:  Returns Dot( vectorExpression, vectorExpression ).

 Related:  <a href="#ImaginaryNumber"><b>ImaginaryNumber</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>
           <a href="#GetMagnitude"><b>GetMagnitude</b></a>  <a href="#GetMagnitude"><b>GetMagnitudeSquared</b></a>  <a href="#Squared"><b>Squared</b></a>  <a href="#sqrt"><b>sqrt</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: Squared  (scalar expressions)
   (3) %--------------------------------------------------------------------
   (4) A = Squared( -3 ) 
-> (5) A = 9

   (6) B = Squared( 3.2 * GetImaginaryNumber() ) 
-> (7) B = -10.24

   (8) C = Squared( -3 + GetImaginaryNumber() ) 
-> (9) C = 8 - 6*imaginary

   (10) %--------------------------------------------------------------------
   (11) % Example 2: Squared  (matrix expressions)
   (12) %--------------------------------------------------------------------
   (13) D = Squared( [1, 2;  3, 4] )
-> (14) D = [7, 10;  15, 22]

   (15) E = Squared( [1, 2;  3, 4 + GetImaginaryNumber()] )
-> (16) E = [7, 10 + 2*imaginary;  15 + 3*imaginary, 21 + 8*imaginary]

   (17) %--------------------------------------------------------------------
   (18) % Example 3: Squared  (vector expressions)
   (19) %--------------------------------------------------------------------
   (20) RigidFrame N 
   (21) F = Squared( sin(t)*Nx> - 2*Ny> + 3*Nz> )
-> (22) F = 13 + sin(t)^2



</PRE><nobr><a name="sqrt"><font color="darkBlue"><font size=+1><b>sqrt</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
sqrt

 Purpose:  Returns the square-root of a scalar expression.

  Syntax:  sqrt( scalarExpression )

   Input:  scalarExpression -- a real or complex scalar expression.

  Output:  sqrt( scalarExpression ).

 Related:  <a href="#ImaginaryNumber"><b>ImaginaryNumber</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>
           <a href="#GetMagnitude"><b>GetMagnitude</b></a>  <a href="#GetMagnitude"><b>GetMagnitudeSquared</b></a>  <a href="#Squared"><b>Squared</b></a>  <a href="#sqrt"><b>sqrt</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: sqrt   (real scalar expressions)
   (3) %--------------------------------------------------------------------
   (4) A = sqrt( 9 ) 
-> (5) A = 3

   (6) B = sqrt( 9.5 ) 
-> (7) B = 3.082207

   (8) C = sqrt(2*t)
-> (9) C = 1.414214*sqrt(t)

   (10) %--------------------------------------------------------------------
   (11) % Example 2: sqrt   (complex scalar expressions)
   (12) %--------------------------------------------------------------------
   (13) D = sqrt( -9 )
-> (14) D = 3*imaginary

   (15) E = sqrt( 9 + 4*GetImaginaryNumber() )
-> (16) E = 3.069923 + 0.6514821*imaginary

   (17) F = sqrt( 3*GetImaginaryNumber() + t )
-> (18) F = sqrt(3*imaginary+t)



</PRE><nobr><a name="System"><font color="darkBlue"><font size=+1><b>System</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
System

 Purpose:  Defines a collection of the following physical objects:
           Point,  Particle,  RigidFrame,  RigidBody.

Syntax 1:  System
Syntax 1:  System  Fred( A, B, C )
Syntax 2:  K = System.GetKineticEnergy()
Syntax 3:  L = System(B,C).GetTranslationalMomentum()

   Input:  Fred -- name that starts with a letter, followed by a reasonable
                   number of alphanumeric characters.

   Input:  A, B, C -- names that were previously declared as a Point,
                      Particle, RigidFrame, RigidBody, or System.

Output 1:  Creates a system containing all objects named in a Point, Particle,
           RigidFrame, or RigidBody declaration -- except the NewtonianFrame.

Output 2:  Creates a system named Fred containing A, B, C.

Output 3:  By itself, the  "System"  keyword refers to the collection of all
           objects declared as  Point,  Particle,  RigidFrame, and RigidBody
           that are not part of (welded to) the NewtonianFrame.

Output 4:  Constructs an unnamed system consisting of B and C and calculates
           the sum of the translational (linear) momentum of B and C.

  Remark:  The NewtonianFrame is not part of the System.

  Remark:  Systems are used in connection with the commands:
           AddForceGravity     GetForceGravityPotentialEnergy
           GetMass             GetInertia ...            (several variants)
           GetCMPosition       GetCMVelocity             GetCMAcceleration
           GetAngularMomentum  GetTranslationalMomentum  GetGeneralizedMomentum
           GetResultantForce   GetResultantMoment        GetResultantTorque
           GetKineticEnergy    GetPower                  GetEnergyCheckKane
           GetStatics          GetDynamics
           GetStaticsKane      GetDynamicsKane

 Related:  <a href="#NewtonianFrame"><b>NewtonianFrame</b></a>  <a href="#Particle"><b>Particle</b></a>  <a href="#Point"><b>Point</b></a>  <a href="#RigidBody"><b>RigidBody</b></a>  <a href="#RigidFrame"><b>RigidFrame</b></a>  <a href="#System"><b>System</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example: System
   (3) %--------------------------------------------------------------------
   (4) RigidBody  A, B
   (5) A.SetMass( mA )            
   (6) B.SetMass( mB )            
   (7) massSystemAB = System.GetMass()
-> (8) massSystemAB = mA + mB

   (9) Particle   P, Q
   (10) P.SetMass( mP )            
   (11) Q.SetMass( mQ )            
   (12) massSystemABPQ = System.GetMass()
-> (13) massSystemABPQ = mA + mB + mP + mQ



</PRE><nobr><a name="SyntaxForms"><font color="darkBlue"><font size=+1><b>SyntaxForms</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Syntactical Forms

 #x>, #y>, #z>  right-handed set of mutually perpendicular unit
                vectors fixed in RigidFrame or RigidBody #,
                e.g., Bx>, By>, Bz> are fixed in B.

 #o             name of the point ("origin") fixed on RigidFrame
                or RigidBody #, e.g., Bo is the origin of B.

 #cm            name of the center of mass (point) fixed on RigidBody #,
                e.g., Bcm is the center of mass of B.

 #_$            rotation matrix (direction cosine matrix) relating
                unit vectors #i>  (i = x,y,z)  fixed in # to
                unit vectors $j>  (j = x,y,z)  fixed in $ where each of
                # and $ have been declared as a RigidFrame or RigidBody;
                the element in row i, column j of #_$ is equal
                to the dot-product of #i> and $j>,
                e.g., B_A is the rotation matrix relating
                Bx>, By>, Bz> to Ax>, Ay>, Az>.

 w_#_$>         angular velocity of # in $ where each of # and $
                have been declared as a RigidFrame or RigidBody,
                e.g., w_B_A> is the angular velocity of B in A.

 alf_#_$>       angular acceleration of # in $ where each of # and $
                have been declared as a RigidFrame or RigidBody,
                e.g., alf_B_A> is the angular acceleration of B in A.

 Torque_#>      torque of external couples on RigidFrame or RigidBody #.
                For example, Torque_B> is the torque on B.

 Torque_#_$>    torque of couples applied to # from $, where each of # and $
                have been declared as a RigidFrame or RigidBody.
                For example, Torque_B_A> is the torque on B from A.

 Force_#>       external contact and distance forces on Point or Particle #.
                For example, Force_Q> is the force on Q.

 Force_#_$>     action/reaction force applied to # from $, where each of
                # and $ were declared as a Point or Particle.
                For example, Force_Q_P> is the force on Q from P.

 p_#_$>         position vector from # to $, where each of # and $
                have been declared as a Point or Particle,
                e.g., p_Q_R> is the position vector from Q to R.

 v_#_$>         velocity of # in $, where # is a Point or Particle
                and # is a RigidFrame or RigidBody, e.g.,
                v_Q_N> is the velocity of Q in N.

 a_#_$>         acceleration of # in $, where # is a Point or Particle
                and # is a RigidFrame or RigidBody, e.g.,
                a_Q_N> is the acceleration of Q in N.

 Zr             rth expression name assigned by a Zee or AutoZee command

 {}             encloses indices, e.g., in declarations

 AUXILIARY[i]   ith constraint function used by the old CONSTRAIN command.
 DEPENDENT[j]   jth constraint function used by the old CONSTRAIN command.

 []             symbols surrounding elements in a matrix, e.g., [1, 2; 3, 4]

 =   or  :=     assignment                  or   overwrite assignment
 +   or  +=     addition                    or   cumulative addition
 -   or  -=     subtraction or unary minus  or   cumulative subtraction
 *   or  *=     multiplication              or   cumulative multiplication
 /   or  /=     division                    or   cumulative division
 ^   or  ^=     exponentiation              or   cumulative exponentiation

 ,              comma separates arguments of a function and
                separates elements of a row in a matrix

 ;              semicolon separates rows of a matrix; separates commands

 '              prime denotes implicit, ordinary, scalar differentiation
                with respect to the independent variable t, (e.g., y').

 !              invokes operating system e.g.,  !someOperatingSystemCommand

 &              line continuation symbol (for really long lines)

 %              beginning of a comment.
 %%             beginning of a comment for a MATLAB, C, or Fortran program.

 >              symbol used to denote a vector quantity
 >>             symbol used to denote a dyadic quantity
 >>>            symbol used to denote a triadic quantity
 0>             zero vector
 0>>            zero dyadic
 1>>            unit dyadic
 pi             3.1415926...
 imaginary      default name for the square root of -1
 t              time
 tInitial       Initial value for independent variable t (for ODE command).
 tFinal         Final   value for independent variable t (for ODE command).
 tStep          Numerical integration step for t         (for ODE command).
 absError       Numerical integration absolute error tolerance (for numerics).


</PRE><nobr><a name="t"><font color="darkBlue"><font size=+1><b>t</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
t

 Purpose:  Default name assigned to the independent variable.
           The program initiates with a declaration of the form:
           IndependentVariable  t

  Syntax:  t

  Remark:  The default name of the independent variable is t.
           t is usually regarded as time.

  Remark:  The prime symbol ' denotes implicit ordinary differentiation
           with respect to the independent variable.  For example, when
           the independent variable t denotes time, x' denotes dx/dt,
           the ordinary time-derivative of x.

 Related:  <a href="#Constant"><b>Constant</b></a>  <a href="#ImaginaryNumber"><b>ImaginaryNumber</b></a>  <a href="#IndependentVariable"><b>IndependentVariable</b></a>
           <a href="#pi"><b>pi</b></a>  <a href="#Specified"><b>Specified</b></a>  <a href="#Variable"><b>Variable</b></a>  <a href="#t"><b>t</b></a>  <a href="#absError"><b>tInitial</b></a>  <a href="#absError"><b>tFinal</b></a>  <a href="#absError"><b>tStep</b></a>  <a href="#absError"><b>absError</b></a>


</PRE><nobr><a name="tan"><font color="darkBlue"><font size=+1><b>tan</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
tan

 Purpose:  Returns the tangent of a scalar expression.

Syntax 1:  tan( scalarExpressionRad )
Syntax 2:  tanDegrees( realNumberDeg )

   Input:  scalarExpressionRad -- the radian measure of a real or
                                  complex scalar expression.
           realNumberDeg -- expression that resolves to a real number.

Output 1:  Tangent of scalarExpressionRad.
Output 2:  Tangent of realNumberDeg.

 Related:  <a href="#ConvertUnits"><b>ConvertUnits</b></a>  <a href="#ImaginaryNumber"><b>ImaginaryNumber</b></a>  <a href="#MathFunctions"><b>MathFunctions</b></a>
           <a href="#cos"><b>cos</b></a>  <a href="#sin"><b>sin</b></a>  <a href="#tan"><b>tan</b></a>  <a href="#acos"><b>acos</b></a>  <a href="#asin"><b>asin</b></a>  <a href="#atan"><b>atan</b></a>  <a href="#atan2"><b>atan2</b></a>  <a href="#cos"><b>cosDegrees</b></a>  ...

   (1) %--------------------------------------------------------------------
   (2) % Example 1: tan   (real scalar expressions)
   (3) %--------------------------------------------------------------------
   (4) A = tan( pi/4 ) 
-> (5) A = 1

   (6) B = tanDegrees( 45 ) 
-> (7) B = 1

   (8) C = tan(t) + tan( t * ConvertUnits(deg,rad) )
-> (9) C = tan(t) + tan(0.01745329*t)

   (10) D = tan(0.5+2*t)
-> (11) D = tan(0.5+2*t)

   (12) %--------------------------------------------------------------------
   (13) % Example 2: tan   (complex scalar expressions)
   (14) %--------------------------------------------------------------------
   (15) E = tan( 2 + 3*GetImaginaryNumber() )
-> (16) E = -0.003764026 + 1.003239*imaginary

   (17) F = tan( 3*GetImaginaryNumber() + t )
-> (18) F = tan(3*imaginary+t)



</PRE><nobr><a name="Translate"><font color="darkBlue"><font size=+1><b>Translate</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Translate

 Purpose:  Sets a point's position from another point.
           Sets a point's velocity in a reference frame.
           Sets a point's acceleration in a reference frame.

Syntax 1:  Q.Translate( fromPoint, positionVector )
           (Note: positionVector may be differentiated).

Syntax 2:  Q.Translate( fromPoint, positionVector, BFixed )
           (Note: positionVector will NOT be differentiated).

Syntax 3:  Q.Translate( fromPoint, positionVector, BFrame, BQ )
           (Note: positionVector may be differentiated).

   Input:  Q -- name of a point.

           fromPoint -- Point whose velocity and acceleration in the
                        NewtonianFrame (or designated frame) is known.

           BFixed -- Rigid frame/body on which fromPoint and Q  are fixed.
           BFrame -- Rigid frame/body on which fromPoint and BQ are fixed.
                     Q is moving on BFrame.

           BQ -- Point of BFrame that is coincident with Q.

  Output:  Sets Q's position vector from fromPoint to positionVector.
           Sets Q's velocity in the NewtonianFrame (or designated frame).
           Sets Q's acceleration in the NewtonianFrame (or designated frame).

Output 2:  Syntax 2 may also set the following (if not in workspace):
           fromPoint's velocity and acceleration in BFixed to 0>
           Q's         velocity and acceleration in BFixed to 0>

Output 3:  Syntax 3 may also set the following (if not in workspace):
           fromPoint's velocity and acceleration in BFrame to 0>.
           BQ          may be defined as a physical point of BFrame, with
                       its velocity and acceleration in BFrame set to 0>.
           BQ's        position from fromPoint.
           Q's         velocity in BFrame (derivative of p_fromPoint_Q>).
           Q's         acceleration in BFrame (via differentiation).

  Remark:  To set Q's velocity in a non-NewtonianFrame, insert refFrame (name
           of a RigidFrame or RigidBody) as the optional first argument, e.g.,
Syntax 1:  Q.Translate( refFrame, fromPoint, positionVector )
Syntax 2:  Q.Translate( refFrame, fromPoint, positionVector, BFixed )
Syntax 3:  Q.Translate( refFrame, fromPoint, positionVector, BFrame, BQ )

  Remark:  If Q is welded to rigid frame/body B, declare it:  Point Q(B).
           Alternately, if Q does not move on B (but is not welded or a
           physical point of B), use Q.SetVelocityAcceleration( B, 0> )

 Related:  <a href="#Translate"><b>Translate</b></a>        <a href="#SetPositionVelocity"><b>SetPositionVelocity</b></a>   <a href="#SetVelocityAcceleration"><b>SetVelocityAcceleration</b></a>
           <a href="#SetPosition"><b>SetPosition</b></a>      <a href="#GetPosition"><b>GetPosition</b></a>   <a href="#GetDistance"><b>GetDistance</b></a>  <a href="#GetDistance"><b>GetDistanceSquared</b></a>
           <a href="#SetVelocity"><b>SetVelocity</b></a>      <a href="#GetVelocity"><b>GetVelocity</b></a>   <a href="#GetSpeed"><b>GetSpeed</b></a>     <a href="#GetElongation"><b>GetElongation</b></a>
           <a href="#SetAcceleration"><b>SetAcceleration</b></a>  <a href="#GetAcceleration"><b>GetAcceleration</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: Translate 
   (3) % Set Q1's velocity and acceleration in N by differentiation. 
   (4) %--------------------------------------------------------------------
   (5) NewtonianFrame N             
   (6) Point     Q1            
   (7) Variable  x1'', y1''           
   (8) Q1.Translate( No,  x1*Nx> + y1*Ny> )
-> (9) p_No_Q1> = x1*Nx> + y1*Ny>
-> (10) v_Q1_N> = x1'*Nx> + y1'*Ny>
-> (11) a_Q1_N> = x1''*Nx> + y1''*Ny>

   (12) %--------------------------------------------------------------------
   (13) % Example 2: Translate 
   (14) % Set Q2's velocity and acceleration in N by differentiation.
   (15) %--------------------------------------------------------------------
   (16) Point     Q2            
   (17) Variable  x2'', y2''  
   (18) Q2.Translate( Q1,  x2*Nx> + y2*Ny> )
-> (19) p_Q1_Q2> = x2*Nx> + y2*Ny>
-> (20) v_Q2_N> = (x1'+x2')*Nx> + (y1'+y2')*Ny>
-> (21) a_Q2_N> = (x1''+x2'')*Nx> + (y1''+y2'')*Ny>

   (22) %--------------------------------------------------------------------
   (23) % Example 3: Translate
   (24) % Set Q3's velocity and acceleration in N via two points fixed on B.
   (25) %--------------------------------------------------------------------
   (26) RigidBody B                  % Body B translates and rotates in N.
   (27) Point     Q3( B )            % Q3 is a point fixed on B.
   (28) Constant  L                  % Distance between Bo and Q3.
   (29) Variable  wB'                % Angular speed and time-derivative.
   (30) B.SetAngularVelocityAcceleration( N,  wB*Bz> )
-> (31) w_B_N> = wB*Bz>
-> (32) alf_B_N> = wB'*Bz>

   (33) Bo.Translate( No,  0.5*t^2*Nx> )
-> (34) p_No_Bo> = 0.5*t^2*Nx>
-> (35) v_Bo_N> = t*Nx>
-> (36) a_Bo_N> = Nx>

   (37) Q3.Translate( Bo,  L*Bx>,  B )
-> (38) p_Bo_Q3> = L*Bx>
-> (39) v_Q3_N> = L*wB*By> + t*Nx>
-> (40) a_Q3_N> = -L*wB^2*Bx> + L*wB'*By> + Nx>

   (41) %--------------------------------------------------------------------
   (42) % Example 4: Translate
   (43) % Set Q4's velocity and acceleration in N via one point moving on B.
   (44) %--------------------------------------------------------------------
   (45) Point      Q4,  BQ4( B )     % BQ4 is point of B coincident with Q4.
   (46) Variable   x4''  
   (47) Q4.Translate( Bo,  x4*Bx>,  B,  BQ4 )
-> (48) p_Bo_Q4> = x4*Bx>
-> (49) p_Bo_BQ4> = x4*Bx>
-> (50) v_BQ4_N> = wB*x4*By> + t*Nx>
-> (51) v_Q4_B> = x4'*Bx>
-> (52) v_Q4_N> = x4'*Bx> + wB*x4*By> + t*Nx>
-> (53) a_BQ4_N> = -x4*wB^2*Bx> + x4*wB'*By> + Nx>
-> (54) a_Q4_B> = x4''*Bx>
-> (55) a_Q4_N> = (x4''-x4*wB^2)*Bx> + (x4*wB'+2*wB*x4')*By> + Nx>



</PRE><nobr><a name="TranslateAcrossJoint"><font color="darkBlue"><font size=+1><b>TranslateAcrossJoint</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
TranslateAcrossJoint

  Syntax:  QB.TranslateAcrossJoint( fromPoint, positionVector )

   Input:  QB -- name of a point welded to a RigidBody or RigidFrame B.

           fromPoint -- Point whose velocity and acceleration in
                        the NewtonianFrame is known.

           positionVector -- QB's position vector fromPoint.

  Output:  Calls   QB.Translate( fromPoint, positionVector )
           Sets the velocity and acceleration of Bo and Bcm
           in the Newtonian reference frame.
           If B is a RigidFrame, skips Bcm calculations.

  Remark:  The position vector to Bo  from fromPoint and
           the position vector to Bcm from Bo are used.

 Related:  <a href="#Translate"><b>Translate</b></a>         <a href="#SetPositionVelocity"><b>SetPositionVelocity</b></a>   <a href="#SetVelocityAcceleration"><b>SetVelocityAcceleration</b></a>
           <a href="#SetPosition"><b>SetPosition</b></a>       <a href="#GetPosition"><b>GetPosition</b></a>   <a href="#GetDistance"><b>GetDistance</b></a>  <a href="#GetDistance"><b>GetDistanceSquared</b></a>
           <a href="#SetVelocity"><b>SetVelocity</b></a>       <a href="#GetVelocity"><b>GetVelocity</b></a>   <a href="#GetSpeed"><b>GetSpeed</b></a>     <a href="#GetElongation"><b>GetElongation</b></a>
           <a href="#SetAcceleration"><b>SetAcceleration</b></a>   <a href="#GetAcceleration"><b>GetAcceleration</b></a>
           <a href="#SetRigidTransform"><b>SetRigidTransform</b></a> <a href="#TranslateAcrossJoint"><b>TranslateAcrossJoint</b></a>
           <a href="#SetVelocityAccelerationForGetGeometry"><b>SetVelocityAccelerationForGetGeometry</b></a>


</PRE><nobr><a name="TrueFalse"><font color="darkBlue"><font size=+1><b>TrueFalse</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
true  false

 Purpose:  Special names that are helpful for true/false logic.

 Syntax 1: true        % true  simplifies to 1 in math expressions.
 Syntax 2: false       % false simplifies to 0 in math expressions.

  Remark:  The multiplication operator * can mimic a logical AND whereas
           the IsPositive command can be used to mimic a logical OR.

 Related:  <a href="#IsSimplifyEqual"><b>IsSimplifyEqual</b></a>  <a href="#IsSimplifyZero"><b>IsSimplifyZero</b></a>  <a href="#IsSimplifyTrue"><b>IsSimplifyTrue</b></a>
           <a href="#IsPositive"><b>IsNegative</b></a>  <a href="#IsPositive"><b>IsNegativeOr0</b></a>  <a href="#IsPositive"><b>IsPositiveOr0</b></a>  <a href="#IsPositive"><b>IsPositive</b></a>

 Builtin:  pi   imaginary   true false   0>   0>>   1>>
           t  tInitial  tFinal  tStep  absError

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  true or false  (operator * can mimic a logical AND)
   (3) %--------------------------------------------------------------------
   (4) isTrue[1] = false * false
-> (5) isTrue[1] = false

   (6) isTrue[2] = false * true 
-> (7) isTrue[2] = false

   (8) isTrue[3] = true  * false
-> (9) isTrue[3] = false

   (10) isTrue[4] = true  * true 
-> (11) isTrue[4] = true

   (12) %--------------------------------------------------------------------
   (13) % Example 2:  true or false  (IsPositive can mimic a logical OR)
   (14) %--------------------------------------------------------------------
   (15) isTrue[5] =  IsPositive( false + false )
-> (16) isTrue[5] = false

   (17) isTrue[6] =  IsPositive( false + true  )
-> (18) isTrue[6] = true

   (19) isTrue[7] =  IsPositive( true  + false )
-> (20) isTrue[7] = true

   (21) isTrue[8] =  IsPositive( true  + true  )
-> (22) isTrue[8] = true

   (23) %--------------------------------------------------------------------
   (24) % Example 3:  true or false
   (25) %--------------------------------------------------------------------
   (26) isSimplifyA = IsSimplifyEqual( 2*t, 9*t )
-> (27) isSimplifyA = false

   (28) isSimplifyB = IsSimplifyEqual( 2*t, 2*t )
-> (29) isSimplifyB = true



</PRE><nobr><a name="SetVelocityAccelerationForGetGeometry"><font color="darkBlue"><font size=+1><b>SetVelocityAccelerationForGetGeometry</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
SetVelocityAccelerationForGetGeometry

 Purpose:  Sets the velocity and acceleration in the NewtonianFrame
           of the origin and center of mass of a rigid body.

  Syntax:  B.SetVelocityAccelerationForGetGeometry( refFrame, fromPoint )

   Input:  B -- name of a RigidBody or RigidFrame.
           refFrame  -- name of a RigidFrame or RigidBody.
           fromPoint -- Point whose velocity and acceleration
                        in the refFrame is already known.

  Output:  Sets the velocity and acceleration of Bo and Bcm.
           If B is a RigidFrame, skips Bcm calculations.

  Remark:  The position vector to Bo from fromPoint and
           the position vector to Bcm from Bo are used.

 Related:  <a href="#SetRigidTransform"><b>SetRigidTransform</b></a>   <a href="#TranslateAcrossJoint"><b>TranslateAcrossJoint</b></a>
           <a href="#SetVelocityAccelerationForGetGeometry"><b>SetVelocityAccelerationForGetGeometry</b></a>


</PRE><nobr><a name="Units"><font color="darkBlue"><font size=+1><b>Units</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Units      ConvertUnits,  Input,  Output,  Constant,  SetMass,  SetInertia
           GetUnitSystem, SetUnitSystem
           GetMassUnit,  GetLengthUnit, GetTimeUnit, GetAngleUnit

   (1) %--------------------------------------------------------------------
   (2) %Example: Units 
   (3) %--------------------------------------------------------------------
   (4) inchToCentimeter = ConvertUnits( inch, cm )
-> (5) inchToCentimeter = 2.54

   (6) SetUnitSystem( kg, meter,  second)   % Default.
   (7) Constant   a = 20 cm,  b = 0.02 km,  c = 30 inches
   (8) distance = EvaluateToNumber( a + b + c )
-> (9) distance = 20.962

   (10) Variable   x'' = sin(t),  y'' = t^2
-> (11) x'' = sin(t)
-> (12) y'' = t^2

   (13) Input      x  = 2 cm,    y  = 3 noUnits
   (14) Input      x' = 6 cm/s,  y' = 7 noUnits/s
   (15) speed = EvaluateToNumber( x' + y'  +  (x + y)/t )
-> (16) speed = 7.06 + 3.02/t

   (17) Input   tFinal = 3 seconds, tStep = 0.5 seconds
   (18) Output  t seconds,  x km,  y miles
   (19) ODE() unitTest  



</PRE><nobr><a name="Variable"><font color="darkBlue"><font size=+1><b>Variable</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Variable

 Purpose:  Declares the names of variables.

Syntax 1:  Variable  a,  b,  x+,  y-,  ...
Syntax 2:  Variable  u', q'',  ...
Syntax 3:  Variable  (displays all names declared as Variable)
Syntax 4:  Variable()

   Input:  a -- name that starts with a letter, followed by a reasonable
                number of alphanumeric characters (similarly for b).
           a, b, ... are regarded as REAL until SetComplex is ON.

           x+ -- declares x as real and non-negative.
           y- -- declares y as real and non-positive.
           Helps simplification such as  abs(x) = x  or  abs(y) = -y.

           u'  -- declares u' and u as Variables.
           q'' -- declares q'', q', and q as Variables.

Output 4:  Creates an array of all names declared as Variable.

  Remark:  The 1st and 2nd ordinary derivatives of y are denoted y' and y''.
           Dt(y) is permitted if y' was also declared - or y was assigned.

  Remark:  Variable  vs.  Specified ??
           Variable:  Regarded as unknown (to be solved).
                      Partial velocities account for assignment of Variable.
           Specified: Regarded as known   (prescribed).
                      Assigned in program  OR  leave "to be specified" in
                      special functions in MATLAB(R), C, and Fortran codes.
                      Partial velocities ignore assignment of Specified.

  Remark:  The name  a{i}bb    declares a1bb ... aibb  (i is positive integer).
           The name  a{i:j}bb  declares aibb ... ajbb  (i >= 0  and  i <= j).
           The name  a{m,n}bb  declares amnbb     (m, n are integers 0 to 9).
           The name  a{m:x,n:y}  declares amn ... axy    (m <= x and n <= y).

  Remark:  The default name of the independent variable is t.

  Remark:  To both declare and assign a Variable, type e.g.,
           Variable x'' = 2*sin(t)

 Related:  <a href="#Constant"><b>Constant</b></a>  <a href="#ImaginaryNumber"><b>ImaginaryNumber</b></a>  <a href="#Specified"><b>Specified</b></a>  <a href="#Variable"><b>Variable</b></a>
           <a href="#SetGeneralizedSpeed"><b>SetGeneralizedCoordinate</b></a>  <a href="#SetGeneralizedSpeed"><b>SetGeneralizedSpeed</b></a>
           <a href="#SetDt"><b>SetDt</b></a>  <a href="#SolveDt"><b>SolveDt</b></a>  <a href="#SetAutoDifferentiate"><b>SetAutoDifferentiate</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: Variable  (variables declarations)
   (3) %--------------------------------------------------------------------
   (4) Variable  w,  x+,  y-,  z'+,   e{0:3}'
   (5) b = sin(t)  +  x  -  abs(x)  +  y  +  abs(y)  +  abs(z)
-> (6) b = sin(t) + z

   (7) dtExample1 = Dt(b) + Dt(e0)
-> (8) dtExample1 = cos(t) + e0' + z'

   (9) %--------------------------------------------------------------------
   (10) % Example 2: Variable  (variable declarations and differentiation)
   (11) %--------------------------------------------------------------------
   (12) Variable  q',  u''
   (13) dtExample2 = Dt(q)  +  Dt(u)  + DtDt(u)  +  Dt(u')
-> (14) dtExample2 = q' + u' + 2*u''

   (15) SetDt( q = sin(t) )
-> (16) q = sin(t)
-> (17) q' = cos(t)

   (18) SetDt( u' = t^3 )
-> (19) u' = t^3
-> (20) u'' = 3*t^2

   (21) arrayOfVariables = Variable()
-> (22) arrayOfVariables = [e0;  e0';  e1;  e1';  e2;  e2';  e3;  e3';  q;  q';  
        u;  u';  u'';  w;  x;  y;  z;  z']



</PRE><nobr><a name="Vector"><font color="darkBlue"><font size=+1><b>Vector</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Vector

 Purpose:  Constructs a vector or three-element column matrix.

Syntax 1:  Vector( A,  x, y, z  )
Syntax 2:  Vector( A,  threeElementMatrix )
Syntax 3:  Vector( A,  vector>  )

   Input:  A -- the name of a RigidFrame or RigidBody.
           x, y, z -- scalar expressions.
           threeElementMatrix -- 3x1 or 1x3 matrix with scalar elements.
           vector> -- a vector  expression

Output 1:  Returns the vector x*Ax> + y*Ay> + z*Az>
Output 2:  Similar to Output 1 (see example)
Output 3:  3x1 matrix whose elements are the Ax>, Ay>, Az> measures of vector>

 Related:  <a href="#Cross"><b>Cross</b></a>  <a href="#Cross"><b>Dot</b></a>  <a href="#Express"><b>Express</b></a>  <a href="#Vector"><b>Vector</b></a>  <a href="#Dyadic"><b>Dyadic</b></a>  <a href="#Matrix"><b>Matrix</b></a> <a href="#>"><b>></b></a>  <a href="#>"><b>>></b></a>  <a href="#>"><b>>>></b></a>  <a href="#0>"><b>0></b></a> <a href="#0>"><b>0>></b></a> <a href="#1>>"><b>1>></b></a>
           <a href="#GetAngleBetweenVectors"><b>GetAngleBetweenVectors</b></a>  <a href="#GetAngleBetweenVectors"><b>GetAngleBetweenUnitVectors</b></a>
           <a href="#GetDistance"><b>GetDistance</b></a>  <a href="#GetMagnitude"><b>GetMagnitude</b></a>  <a href="#GetMagnitude"><b>GetMagnitudeSquared</b></a>    <a href="#GetUnitVector"><b>GetUnitVector</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1:  Vector( A,  x, y, z )
   (3) %--------------------------------------------------------------------
   (4) RigidFrame A, B
   (5) Constant   x, y, z
   (6) vector1> = Vector( A,  x, y, z )
-> (7) vector1> = x*Ax> + y*Ay> + z*Az>

   (8) %--------------------------------------------------------------------
   (9) % Example 2:  Vector( A,  threeElementMatrix )
   (10) %--------------------------------------------------------------------
   (11) vector2> = Vector( A,  [x; y; z] )
-> (12) vector2> = x*Ax> + y*Ay> + z*Az>

   (13) %--------------------------------------------------------------------
   (14) % Example 3:  Vector( A,  vector> )
   (15) %--------------------------------------------------------------------
   (16) B.SetRotationMatrixZ( A, t ) 
-> (17) B_A = [cos(t), sin(t), 0;  -sin(t), cos(t), 0;  0, 0, 1]

   (18) matrix1 = Vector( A,  x*Ax> + y*Ay> + z*Az> )
-> (19) matrix1 = [x;  y;  z]

   (20) matrix2 = Vector( B,  x*Ax> + y*Ay> + z*Az> )
-> (21) matrix2 = [x*cos(t) + y*sin(t);  y*cos(t) - x*sin(t);  z]



</PRE><nobr><a name="Zee"><font color="darkBlue"><font size=+1><b>Zee</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Zee   ZeeV    ZeeA   ZeeConstants

 Purpose:  Introduces  Z1, Z2, ...  as  names for expressions and
           makes corresponding replacements.

Syntax 1:  Zee( ExpressionY )
Syntax 2:  Zee( ExpressionY, X )
Syntax 3:  ZeeV( ExpressionY )
Syntax 4:  ZeeA( ExpressionY )
Syntax 5:  ZeeConstants( expressionY )

   Input:  ExpressionY -- a scalar, vector, or dyadic expression or
           a matrix of scalars, vectors, and/or dyadics.

           X -- The name of a scalar symbol (e.g., a constant or variable)
                or a comma-separated list of names of scalar symbols,
                or a matrix of names of scalar symbols,
                that appear linearly in ExpressionY.

Output 1:  ExpressionY expressed in a form involving Z1, Z2, ...

Output 2:  ExpressionY expressed in a form involving Z1, Z2, ... ,
           where Zi do not contain any of the scalar names in X.

Output 3:  ExpressionY expressed in a form involving Z1, Z2, ... ,
           where Zi do not contain independent generalized speeds
           (generalized speeds are named in the SetGeneralizedSpeed command).

Output 4:  ExpressionY expressed in a form involving Z1, Z2, ... ,
           where Zi do not contain any 1st-time-derivatives of independent
           generalized speeds.

Output 5:  ExpressionY expressed in a form involving Z1, Z2, ... ,
           where Zi contain only constants.

  Remark:  Designated names can be excluded from all Zs, provided
           they occur only linearly.  To do this, enter the line
           SetNoZeeSymbol( M ), where M is either a scalar name
           to be excluded or a matrix of scalar names to be excluded.

           ZEE is a dual function; e.g., the command ZEE( F ) can be
           on the right-hand side of an equation or a single expression
           without an equals sign.  In the latter event, an equation
           is created whose left-hand is F.

  Remark:  To be Autolev compatible, use:
           ZeeV( ExpressionY )  instead of  Zee( ExpressionY, U  ),
           ZeeA( ExpressionY )  instead of  Zee( ExpressionY, U' ).

 Related:  <a href="#Express"><b>Express</b></a>  <a href="#SetAutoExpress"><b>SetAutoExpress</b></a>  <a href="#SetAutoZee"><b>SetAutoZee</b></a>  <a href="#Zee"><b>Zee</b></a>
           <a href="#SetNoZeeSymbol"><b>SetNoZeeSymbol</b></a>  <a href="#SetNoZeeSymbol"><b>ResetNoZeeSymbol</b></a>  <a href="#SetNoZeeSymbol"><b>GetNoZeeSymbol</b></a>
           <a href="#FactorLinear"><b>FactorLinear</b></a>  <a href="#FactorLinear"><b>FactorQuadratic</b></a>

   (1) %--------------------------------------------------------------------
   (2) % Example 1: Zee   (scalar expression)
   (3) %--------------------------------------------------------------------
   (4) Constant   A, B, C
   (5) ScalarExpression = (A-B)*cos(t) + (B-C)*sin(t)
-> (6) ScalarExpression = (A-B)*cos(t) + (B-C)*sin(t)

   (7) Zee( ScalarExpression )
-> (8) z1 = cos(t)
-> (9) z2 = sin(t)
-> (10) z3 = A - B
-> (11) z4 = B - C
-> (12) z5 = z3*z1 + z4*z2
-> (13) ScalarExpression = z5

   (14) %--------------------------------------------------------------------
   (15) % Example 2: ZeeConstants   (vector expression)
   (16) %--------------------------------------------------------------------
   (17) RigidBody  N
   (18) vector> = (A-B)*cos(t)*Nx> + (B-C)*sin(t)*Ny> + cos(A-B)*sin(B-C)*exp(t)*Nz>
-> (19) vector> = (A-B)*cos(t)*Nx> + (B-C)*sin(t)*Ny> + sin(B-C)*cos(A-B)*exp(t)*Nz>

   (20) ZeeConstants( vector> )
-> (21) z6 = sin(B-C)*cos(A-B)
-> (22) vector> = z3*cos(t)*Nx> + z4*sin(t)*Ny> + z6*exp(t)*Nz>

   (23) %--------------------------------------------------------------------
   (24) % Example 3: Zee   (matrix expression)
   (25) %--------------------------------------------------------------------
   (26) Variable x, y
   (27) matrix[1] = 10 + A + B + C + abs(t)*x + sin(t)*exp(t)*cos(t^2)*y
-> (28) matrix[1] = 10 + A + B + C + abs(t)*x + sin(t)*exp(t)*cos(t^2)*y

   (29) matrix[2] = 10 + A^2 + cos(B+C)*tan(t)*x
-> (30) matrix[2] = 10 + A^2 + cos(B+C)*tan(t)*x

   (31) Zee( matrix, x, y )
-> (32) z7 = abs(t)
-> (33) z8 = exp(t)
-> (34) z9 = cos(t^2)
-> (35) z10 = z2*z8*z9
-> (36) z11 = 10 + A + B + C
-> (37) z12 = cos(B+C)
-> (38) z13 = tan(t)
-> (39) z14 = z12*z13
-> (40) z15 = 10 + A^2
-> (41) matrix = [z11 + z7*x + z10*y;  z15 + z14*x]



</PRE><nobr><a name="----------------------------------------------------------------------------"><font color="darkBlue"><font size=+1><b>----------------------------------------------------------------------------</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
 The remaining functions below are or will be superseded by other methods.
----------------------------------------------------------------------------


</PRE><nobr><a name="Algebraic"><font color="darkBlue"><font size=+1><b>Algebraic</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Algebraic  (Also see Solve)

 Purpose:  Writes a MATLAB, C, or Fortran program to solve for Output
           and perhaps to solve coupled LINEAR algebraic equations.

Syntax 1:  Algebraic()                             Filename.Ext
Syntax 2:  Algebraic( EqnsToSolve, x1, x2, ... )   Filename.Ext
Syntax 3:  Algebraic()                             Filename.Ext( Tx, Ty, Tz )
Syntax 4:  Algebraic() [A = Astart, Astop, Astep]  Filename.Ext
Note:      The various options in Syntax 1-4 can be used together.

   Input:  Filename -- a valid file name (letters, numbers, or underscores)
           Ext -- .m    (produces MATLAB  code)
               -- .c    (produces C       code and input file Filename.in)
               -- .f    (produces FORTRAN code and input file Filename.in)
               -- .for  (same as .f except 72 character line length)

   Input:  EqnsToSolve -- matrix of (or single) scalar expressions that are
           LINEAR functions of x1, x2, ..., and regarded as equal to zero.
           Treated as:  EqnsToSolve[1] = 0,   EqnsToSolve[2] = 0, ...

           x1, x2 -- the names of scalars or a matrix of scalar names.

           Tx, Ty, Tz -- scalar names (maybe with units) that allow for
           passing command-line arguments to MATLAB or C programs.
           Example:  Filename.m( Tx N*m,  Ty N*cm,  Tz lbf*ft )

           A = Astart, Astop, Astep -- A is the name (maybe with units) of a
           scalar quantity used as a loop index.  Astart, Astop, Astep are
           numerical values.  Example:  [A cm = 0, 100, 2]

Output 1:  Produces a program that performs all calculations necessary to
           determine values of quantities named in OUTPUT statements.

Output 2:  Same as Output 1.  Also solves EqnsToSolve for x1, x2, ...

Output 3:  To run Filename.m, type  Filename( 12, 56, 87 )  at MATLAB prompt.
           To run Filename.c, type  Filename 12 56 87       from OS shell.

Output 4:  Incorporates Fortran DO-loops or C/MATLAB FOR-loops.
           To have multiple loops inside the program, use, e.g.,
           [ A = Astart, Astop, Astep;   B = Bstart, Bstop, Bstep; ... ]

  Remark:  Input values and units are named in INPUT statements.
           Output quantities and units are named in OUTPUT statements.

  Remark:  SetDigits sets the format of numbers output by programs created by
           the ALGEBRAIC command.  It does not affect calculation accuracy.

  Remark:  Use the  .for  extension for FORTRAN whose line lengths cannot
           exceed 72 characters and which supports all line breaks.
           Use the  .f   extension for FORTRAN with lines less than 120
           characters and which cannot break lines in the middle of names.

 Related:  <a href="#ODE"><b>ODE</b></a>  <a href="#Algebraic"><b>Algebraic</b></a>  <a href="#Solve"><b>Solve</b></a>  <a href="#Input"><b>Input</b></a>  <a href="#Output"><b>Output</b></a>  <a href="#Output"><b>OutputPlot</b></a>  <a href="#Plot"><b>Plot</b></a>  <a href="#Animate"><b>Animate</b></a>
           <a href="#ConvertUnits"><b>ConvertUnits</b></a>  <a href="#GetUnitSystem"><b>GetUnitSystem</b></a>  <a href="#SetUnitSystem"><b>SetUnitSystem</b></a>  <a href="#SetDigits"><b>SetDigits</b></a>  <a href="#SetLineWidth"><b>SetLineWidth</b></a>
           <a href="#Solve"><b>Solve</b></a>  <a href="#SolveDt"><b>SolveDt</b></a>  <a href="#SolveSetInput"><b>SolveSetInput</b></a>  <a href="#SolveSetInputDt"><b>SolveSetInputDt</b></a>  ...

   (1) %--------------------------------------------------------------------
   (2) % Example 1: CODE Algebraic()  (Fortran for volume of a tetrahedron)
   (3) %--------------------------------------------------------------------
   (4) RigidFrame  N
   (5) Point       A, B, C, D
   (6) Constant    a1 = 0 m,  a2 = 0 m,  a3 = 0 m
   (7) Constant    b1 = 5 m,  b2 = 0 m,  b3 = 0 m
   (8) Constant    c1 = 0 m,  c2 = 5 m,  c3 = 0 m
   (9) Constant    d1 = 2 m,  d2 = 2 m,  d3 = 5 m
   (10) A.SetPosition( No, a1*Nx> + a2*Ny> + a3*Nz> )
-> (11) p_No_A> = a1*Nx> + a2*Ny> + a3*Nz>

   (12) B.SetPosition( No, b1*Nx> + b2*Ny> + b3*Nz> )
-> (13) p_No_B> = b1*Nx> + b2*Ny> + b3*Nz>

   (14) C.SetPosition( No, c1*Nx> + c2*Ny> + c3*Nz> )
-> (15) p_No_C> = c1*Nx> + c2*Ny> + c3*Nz>

   (16) D.SetPosition( No, d1*Nx> + d2*Ny> + d3*Nz> )
-> (17) p_No_D> = d1*Nx> + d2*Ny> + d3*Nz>

   (18) Side1> = B.GetPosition(A)
-> (19) Side1> = (b1-a1)*Nx> + (b2-a2)*Ny> + (b3-a3)*Nz>

   (20) Side2> = C.GetPosition(A)
-> (21) Side2> = (c1-a1)*Nx> + (c2-a2)*Ny> + (c3-a3)*Nz>

   (22) Side3> = D.GetPosition(A)
-> (23) Side3> = (d1-a1)*Nx> + (d2-a2)*Ny> + (d3-a3)*Nz>

   (24) Volume = abs( Dot( Cross( Side1>, Side2> ), Side3> ) / 6 )
-> (25) Volume = abs(0.1666667*(a2-d2)*((a1-b1)*(a3-c3)-(a1-c1)*(a3-b3))-0.1666667
        *(a1-d1)*((a2-b2)*(a3-c3)-(a2-c2)*(a3-b3))-0.1666667*(a3-d3)*((a1-b1)*(
        a2-c2)-(a1-c1)*(a2-b2)))

   (26) Output  Volume
   (27) Code Algebraic() Tetra.for

   (28) %--------------------------------------------------------------------
   (29) % Example 2: CODE Algebraic(...)   (.m code for linear equations) 
   (30) %--------------------------------------------------------------------
   (31) Variable  x, y
   (32) ZeroMatrix[1] = x + y - sin(t)
-> (33) ZeroMatrix[1] = x + y - sin(t)

   (34) ZeroMatrix[2] = x - y + t^2
-> (35) ZeroMatrix[2] = t^2 + x - y

   (36) Output  t, x, y
   (37) Code Algebraic( ZeroMatrix, x, y )  [t=0, 10, 1]  TwoEquations.c



</PRE><nobr><a name="Angvel"><font color="darkBlue"><font size=+1><b>Angvel</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Angvel  and  AngvelAccel

 Purpose:  Calculates and sets angular velocity in terms of orientation angles,
           Euler parameters, Rodrigues parameters, or elements of rotation
           matrices (direction cosines) and their time-derivatives.

Syntax 1:  Angvel(      A, B, TYPE,  q1, q2, q3 )
           AngvelAccel( A, B, TYPE,  q1, q2, q3 )
Syntax 2:  Angvel(      A, B, Euler, e1, e2, e3, e4 )
           AngvelAccel( A, B, Euler, e1, e2, e3, e4 )
Syntax 3:  Angvel(      A, B, Rodrigues, rho1, rho2, rho3 )
           AngvelAccel( A, B, Rodrigues, rho1, rho2, rho3 )
Syntax 4:  Angvel(      A, B )
           AngvelAccel( A, B )

   Input:  A, B -- names of reference frames (RigidFrame or RigidBody).

           TYPE -- BODYx  or  SPACEx, where x is one of 123, 132,
           231, 213, 312, 321, 121, 131, 232, 212, 313, 323

           q1, q2, q3 -- orientation angles characterizing
           the relative orientation of frames A and B.

           e1, e2, e3, e4 -- Euler parameters characterizing
           the relative orientation of frames A and B.

           rho1, rho2, rho3 -- Rodrigues parameters characterizing
           the relative orientation of frames A and B.

Output 1:  Sets frame B's angular velocity in frame A, expressed in terms of
           q1, q2, q3, q1', q2', q3', and unit vectors fixed in B.
           AngvelAccel also sets B's angular acceleration in A.

Output 2:  Sets frame B's angular velocity in frame A, expressed in terms of
           e1 ... e4,  e1' ... e4', and unit vectors fixed in B.
           AngvelAccel also sets B's angular acceleration in A.

Output 3:  Sets frame B's angular velocity in frame A, expressed in terms of
           rho1 ... rho3,  rho1' ... rho3', and unit vectors fixed in B.
           AngvelAccel also sets B's angular acceleration in A.

Output 4:  Frame B's angular velocity in A, expressed in terms of direction
           cosines, their time-derivatives, and unit vectors fixed in B.
           AngvelAccel also sets B's angular acceleration in A.

  Remark:  Definitions of orientation angles, Euler parameters,
           Rodrigues parameters, and direction cosines are in
           Kane, T. R.,  Likins, P. W.,  and Levinson D. A.,
           Spacecraft Dynamics, McGraw-Hill, 1983, Ch. 1., and
           Mitiguy, Paul, Advanced Dynamics for Professional
           Mechanical, Aerospace, and BioMechanical Engineers.

 Related:  <a href="#Rotate"><b>Rotate</b></a>  <a href="#RotateX"><b>RotateX</b></a>  <a href="#RotateY"><b>RotateY</b></a>  <a href="#RotateZ"><b>RotateZ</b></a>
           <a href="#RotateX"><b>RotateNegativeX</b></a>  <a href="#RotateY"><b>RotateNegativeY</b></a>  <a href="#RotateZ"><b>RotateNegativeZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixY</b></a>  <a href="#SetRotationMatrixZ"><b>SetRotationMatrixZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixNegativeX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixNegativeY</b></a>  ...
           <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>  <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>  <a href="#SetAngularAcceleration"><b>SetAngularAcceleration</b></a>
           <a href="#GetRotationMatrix"><b>GetRotationMatrix</b></a>  <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>  <a href="#GetAngularAcceleration"><b>GetAngularAcceleration</b></a>
           <a href="#SetRotationMatrixODE"><b>SetRotationMatrixODE</b></a>  <a href="#SetEulerParameterODE"><b>SetEulerParameterODE</b></a>  <a href="#SetRodriguesParameterODE"><b>SetRodriguesParameterODE</b></a>
           <a href="#Angvel"><b>ANGVEL</b></a>  <a href="#KinDiffs"><b>KINDIFFS</b></a>  SetDefaults( <a href="#AUTOLEV"><b>AUTOLEV</b></a> )

   (1) %--------------------------------------------------------------------
   (2) % Example 1: Angvel  (Orientation angles)
   (3) %--------------------------------------------------------------------
   (4) RigidFrame  A, B
   (5) Variable    q1', q2', q3'
   (6) Angvel( A, B, Body123, q1, q2, q3 )
-> (7) w_B_A> = (sin(q3)*q2'+cos(q2)*cos(q3)*q1')*Bx> + (cos(q3)*q2'-sin(q3)*
       cos(q2)*q1')*By> + (q3'+sin(q2)*q1')*Bz>

   (8) %--------------------------------------------------------------------
   (9) % Example 2: Angvel  (Euler parameters)
   (10) %--------------------------------------------------------------------
   (11) RigidFrame  C
   (12) Variable    e1', e2', e3', e4' 
   (13) Angvel( A, C, Euler, e1, e2, e3, e4 )
-> (14) w_C_A> = (2*e3*e2'+2*e4*e1'-2*e1*e4'-2*e2*e3')*Cx> + (2*e1*e3'+2*e4*e2'
        -2*e2*e4'-2*e3*e1')*Cy> + (2*e2*e1'+2*e4*e3'-2*e1*e2'-2*e3*e4')*Cz>

   (15) %--------------------------------------------------------------------
   (16) % Example 3: Angvel  (Rodrigues parameters)
   (17) %--------------------------------------------------------------------
   (18) RigidFrame  D
   (19) Variable    rho1', rho2', rho3' 
   (20) Angvel( A, D, Rodrigues, rho1, rho2, rho3 )
-> (21) w_D_A> = -2*(rho2*rho3'-rho1'-rho3*rho2')/(1+rho1^2+rho2^2+rho3^2)*Dx>
        + 2*(rho2'+rho1*rho3'-rho3*rho1')/(1+rho1^2+rho2^2+rho3^2)*Dy> - 2*(rh
        o1*rho2'-rho3'-rho2*rho1')/(1+rho1^2+rho2^2+rho3^2)*Dz>

   (22) %--------------------------------------------------------------------
   (23) % Example 4: Angvel  (Direction cosines)
   (24) %--------------------------------------------------------------------
   (25) RigidFrame  F
   (26) Variable    C{1:3,1:3}' 
   (27) A_F = [C11, C12, C13; C21, C22, C23; C31, C32, C33]
-> (28) A_F = [C11, C12, C13;  C21, C22, C23;  C31, C32, C33]

   (29) Angvel( A, F )
-> (30) w_F_A> = (C13*C12'+C23*C22'+C33*C32')*Fx> + (C11*C13'+C21*C23'+C31*C33')*Fy>
        + (C12*C11'+C22*C21'+C32*C31')*Fz>

   (31) %--------------------------------------------------------------------
   (32) % Example 5: AngvelAccel  (Orientation angles)
   (33) %--------------------------------------------------------------------
   (34) Variable    q1'', q2'', q3''
   (35) AngvelAccel( A, B, Body123, q1, q2, q3 )
-> (36) w_B_A> = (sin(q3)*q2'+cos(q2)*cos(q3)*q1')*Bx> + (cos(q3)*q2'-sin(q3)*
        cos(q2)*q1')*By> + (q3'+sin(q2)*q1')*Bz>

-> (37) alf_B_A> = (cos(q3)*q2'*q3'+sin(q3)*q2''+cos(q2)*cos(q3)*q1''-sin(q2)*
        cos(q3)*q1'*q2'-sin(q3)*cos(q2)*q1'*q3')*Bx> + (sin(q2)*sin(q3)*q1'*q2'
        +cos(q3)*q2''-sin(q3)*q2'*q3'-cos(q2)*cos(q3)*q1'*q3'-sin(q3)*cos(q2)*
        q1'')*By> + (cos(q2)*q1'*q2'+q3''+sin(q2)*q1'')*Bz>

   (38) %--------------------------------------------------------------------
   (39) % Example 6: AngvelAccel  (Euler parameters)
   (40) %--------------------------------------------------------------------
   (41) Variable    e1'', e2'', e3'', e4'' 
   (42) AngvelAccel( A, C, Euler, e1, e2, e3, e4 )
-> (43) w_C_A> = (2*e3*e2'+2*e4*e1'-2*e1*e4'-2*e2*e3')*Cx> + (2*e1*e3'+2*e4*e2'
        -2*e2*e4'-2*e3*e1')*Cy> + (2*e2*e1'+2*e4*e3'-2*e1*e2'-2*e3*e4')*Cz>

-> (44) alf_C_A> = (2*e3*e2''+2*e4*e1''-2*e1*e4''-2*e2*e3'')*Cx> + (2*e1*e3''+2
        *e4*e2''-2*e2*e4''-2*e3*e1'')*Cy> + (2*e2*e1''+2*e4*e3''-2*e1*e2''-2*
        e3*e4'')*Cz>

   (45) %--------------------------------------------------------------------
   (46) % Example 7: AngvelAccel  (Rodrigues parameters)
   (47) %--------------------------------------------------------------------
   (48) Variable    rho1'', rho2'', rho3'' 
   (49) AngvelAccel( A, D, Rodrigues, rho1, rho2, rho3 )
-> (50) w_D_A> = -2*(rho2*rho3'-rho1'-rho3*rho2')/(1+rho1^2+rho2^2+rho3^2)*Dx>
        + 2*(rho2'+rho1*rho3'-rho3*rho1')/(1+rho1^2+rho2^2+rho3^2)*Dy> - 2*(rh
        o1*rho2'-rho3'-rho2*rho1')/(1+rho1^2+rho2^2+rho3^2)*Dz>

-> (51) alf_D_A> = 2*(2*(rho1*rho1'+rho2*rho2'+rho3*rho3')*(rho2*rho3'-rho1'-
        rho3*rho2')-(1+rho1^2+rho2^2+rho3^2)*(rho2*rho3''-rho1''-rho3*rho2''))/
        (1+rho1^2+rho2^2+rho3^2)^2*Dx> - 2*(2*(rho1*rho1'+rho2*rho2'+rho3*rho3')
        *(rho2'+rho1*rho3'-rho3*rho1')-(1+rho1^2+rho2^2+rho3^2)*(rho2''+rho1*
        rho3''-rho3*rho1''))/(1+rho1^2+rho2^2+rho3^2)^2*Dy> + 2*(2*(rho1*rho1'+
        rho2*rho2'+rho3*rho3')*(rho1*rho2'-rho3'-rho2*rho1')-(1+rho1^2+rho2^2+rho3^2)
        *(rho1*rho2''-rho3''-rho2*rho1''))/(1+rho1^2+rho2^2+rho3^2)^2*Dz>

   (52) %--------------------------------------------------------------------
   (53) % Example 8: AngvelAccel  (Direction cosines)
   (54) %--------------------------------------------------------------------
   (55) Variable    C{1:3,1:3}'' 
   (56) AngvelAccel( A, F )
-> (57) w_F_A> = (C13*C12'+C23*C22'+C33*C32')*Fx> + (C11*C13'+C21*C23'+C31*C33')*Fy>
        + (C12*C11'+C22*C21'+C32*C31')*Fz>

-> (58) alf_F_A> = (C12'*C13'+C22'*C23'+C32'*C33'+C13*C12''+C23*C22''+C33*C32'')*Fx>
        + (C11'*C13'+C21'*C23'+C31'*C33'+C11*C13''+C21*C23''+C31*C33'')*Fy>
        + (C11'*C12'+C21'*C22'+C31'*C32'+C12*C11''+C22*C21''+C32*C31'')*Fz>



</PRE><nobr><a name="Code"><font color="darkBlue"><font size=+1><b>Code</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
CODE       (Mostly superseded by ODE and Solve)

 Purpose:  Writes a Fortran, C, or MATLAB program or immediately
           executes a program for a variety of purposes.

Syntax 1:  Code ODE()                               Filename.Ext
           Code ODE( MatrixOfEqns, UNKNOWNS )       Filename.Ext

Syntax 2:  Code Algebraic()                         Filename.Ext
           Code Algebraic( MatrixOfEqns, UNKNOWNS ) Filename.Ext

Syntax 3:  Code Nonlinear( MatrixOfEqns, UNKNOWNS ) Filename.Ext

   Input:  Filename -- a valid file name, e.g., one that starts with a
           letter and is followed by letters, numbers, or underscores.

           Ext -- nothing (produces immediate solution)
               -- .c    (produces C code)
               -- .f    (produces FORTRAN code)
               -- .for  (produces FORTRAN code with 72 character line length)
               -- .m    (produces MATLAB code)

           MatrixOfEqns -- a matrix of scalar expressions (e.g., f1, ..., fn)
           that are functions of the UNKNOWNS and which are regarded to be
           equal to zero, i.e., fi = 0  (i = 1, ..., n).

           UNKNOWNS -- the names of scalars separated by commas or a
           matrix of names of scalars.

Output 1:  Solves or creates code to solve a set of simultaneous ordinary
           differential equations or coupled differential/algebraic equations
               *** Type HELP ODE for details. ***

Output 2:  Creates code to solve a set of coupled or uncoupled
           nonlinear, algebraic (nondifferential) equations
               *** Type HELP NONLINEAR for details. ***

Output 3:  Creates code to carry out successive substitutions or to
           solve a set of simultaneous, linear equations
               *** Type HELP ALGEBRAIC for details. ***

  Remark:  The program's license may limit the type of CODE
           that can be generated (e.g., to a specific Ext).

  Remark:  Use the  .for  extension for FORTRAN whose line lengths cannot
           exceed 72 characters and which supports all line breaks.
           Use the  .f   extension for FORTRAN with lines less than 120
           characters and which cannot break lines in the middle of names.

 Related:  <a href="#Code"><b>CODE</b></a>  <a href="#Algebraic"><b>ALGEBRAIC</b></a>  <a href="#Nonlinear"><b>NONLINEAR</b></a>  <a href="#ODE"><b>ODE</b></a>  <a href="#Input"><b>Input</b></a>  <a href="#Output"><b>Output</b></a>  <a href="#Animate"><b>Animate</b></a>
           <a href="#ConvertUnits"><b>ConvertUnits</b></a>  <a href="#GetUnitSystem"><b>GetUnitSystem</b></a>  <a href="#SetUnitSystem"><b>SetUnitSystem</b></a>  <a href="#SetDigits"><b>SetDigits</b></a>  <a href="#SetLineWidth"><b>SetLineWidth</b></a>
           <a href="#absError"><b>absError</b></a>  <a href="#absError"><b>relError</b></a>  <a href="#absError"><b>tInitial</b></a>  <a href="#absError"><b>tFinal</b></a>  <a href="#absError"><b>tStep</b></a>  <a href="#absError"><b>printInt</b></a>
           <a href="#Solve"><b>Solve</b></a>  <a href="#SolveDt"><b>SolveDt</b></a>  <a href="#SolveSetInput"><b>SolveSetInput</b></a>  <a href="#SolveSetInputDt"><b>SolveSetInputDt</b></a>  ...

   (1) %--------------------------------------------------------------------
   (2) % Example: CODE Nonlinear( ... )      2 equations, 2 unknowns.
   (3) %--------------------------------------------------------------------
   (4) Variable  x, y                
   (5) Constant  R = 3 meters       % Radius of circle.
   (6) eqn[1] = x^2 + y^2 - 3^2     % Equation for circle of radius R.
-> (7) eqn[1] = -9 + x^2 + y^2

   (8) eqn[2] = y - 2*sin(x)        % Equation for sine wave of amplitude 2 m.
-> (9) eqn[2] = y - 2*sin(x)

   (10) Input  x = 4 m,  y = 2 m     % Guess for solution (in meters).
   (11) Code Nonlinear( eqn = 0,  x, y )  CircleSineWaveIntersection.m

   (12) %--------------------------------------------------------------------
   (13) % Example: CODE Nonlinear( ... )      1 equation, 2 unknowns.
   (14) %--------------------------------------------------------------------
   (15) Code Nonlinear( eqn[1] = 0,  x, y )  CodePointNearCircle.m

   (16) %--------------------------------------------------------------------
   (17) % Example: CODE Algebraic( ... )      2 equations, 2 unknowns.
   (18) %--------------------------------------------------------------------
   (19) linearEqn[1] = x + y - R
-> (20) linearEqn[1] = x + y - R

   (21) linearEqn[2] = 2*x + 3*y - 4*sin(t)
-> (22) linearEqn[2] = 2*x + 3*y - 4*sin(t)

   (23) Output t degrees,  x meters,  y meters
   (24) Code Algebraic( linearEqn = 0,  x, y ) [t degrees = 0, 360, 30] CodeTest.m

   (25) %--------------------------------------------------------------------
   (26) % For more examples, type:
   (27) % Help ALGEBRAIC
   (28) % Help NONLINEAR
   (29) % Help ODE
   (30) %--------------------------------------------------------------------


</PRE><nobr><a name="Nonlinear"><font color="darkBlue"><font size=+1><b>Nonlinear</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Nonlinear  (Also see Solve)

 Purpose:  Writes a MATLAB, C, or Fortran program to solve coupled nonlinear
           algebraic equations and calculate Output.

Syntax 1:  Nonlinear( EqnsToSolve, x1, x2, ... )  Filename.Ext
Syntax 2:  Nonlinear( EqnsToSolve, x1, x2, ... )  Filename.Ext( Tx, Ty, Tz )
Syntax 3:  Nonlinear( EqnsToSolve, x1, x2, ... )  [A = Astart, Astop, Astep]

   Input:  Filename -- a valid file name (letters, numbers, or underscores)
           Ext -- .m    (produces MATLAB  code)
               -- .c    (produces C       code and input file Filename.in)
               -- .f    (produces FORTRAN code and input file Filename.in)
               -- .for  (same as .f except 72 character line length)

   Input:  EqnsToSolve -- matrix of (or single) scalar expressions that
           are functions of x1, x2, ..., and regarded as equal to zero.
           Treated as:  EqnsToSolve[1] = 0,   EqnsToSolve[2] = 0, ...

           x1, x2 -- the names of scalars or a matrix of scalar names.

           Tx, Ty, Tz -- scalar names (maybe with units) that allow for
           passing command-line arguments to MATLAB or C programs.
           Example:  Filename.m( Tx N*m,  Ty N*cm,  Tz lbf*ft )

           A = Astart, Astop, Astep -- A is the name (maybe with units) of a
           scalar quantity used as a loop index.  Astart, Astop, Astep are
           numerical values.  Example:  [A cm = 0, 100, 2]

  Output:  Produces a program that solves the nonlinear algebraic equations,
           outputs numerical results for x1, x2, ..., and outputs numerical
           values of quantities named in OUTPUT statements.

Output 2:  To run Filename.m, type  Filename( 12, 56, 87 )  at MATLAB prompt.
           To run Filename.c, type  Filename 12 56 87       from OS shell.

Output 3:  Incorporates Fortran DO-loops or C/MATLAB FOR-loops.
           To have multiple loops inside the program, use, e.g.,
           [ A = Astart, Astop, Astep;   B = Bstart, Bstop, Bstep; ... ]

  Remark:  Input values and units are named in INPUT statements.
           Output quantities and units are named in OUTPUT statements.

  Remark:  SetDigits sets the format of numbers output by programs created by
           the ODE command.  It does not affect calculation accuracy.

  Remark:  The solution is approximate and a solution may be reported even
           though one does not exists.  The accuracy of the solution tends
           to improve as the input value assigned to absError gets smaller.
           The default value of absError can be changed via the Input command:
           Input  absError = 1.0E-7 cm

  Remark:  Nonlinear algebraic equations may have 0, 1, 2, 3, ..., solutions.

 Related:  <a href="#Code"><b>CODE</b></a>  <a href="#Algebraic"><b>ALGEBRAIC</b></a>  <a href="#Nonlinear"><b>NONLINEAR</b></a>  <a href="#ODE"><b>ODE</b></a>  <a href="#Input"><b>Input</b></a>  <a href="#Output"><b>Output</b></a>  <a href="#Animate"><b>Animate</b></a>
           <a href="#ConvertUnits"><b>ConvertUnits</b></a>  <a href="#GetUnitSystem"><b>GetUnitSystem</b></a>  <a href="#SetUnitSystem"><b>SetUnitSystem</b></a>  <a href="#SetDigits"><b>SetDigits</b></a>  <a href="#SetLineWidth"><b>SetLineWidth</b></a>
           <a href="#Solve"><b>Solve</b></a>  <a href="#SolveDt"><b>SolveDt</b></a>  <a href="#SolveSetInput"><b>SolveSetInput</b></a>  <a href="#SolveSetInputDt"><b>SolveSetInputDt</b></a>  ...

   (1) %--------------------------------------------------------------------
   (2) % Example:  CODE Nonlinear( ... ) 
   (3) % Creates C code to find the intersection of a circle and line.
   (4) %--------------------------------------------------------------------
   (5) Variable  x, y
   (6) Constant  R,  m = 1 noUnits,  b = 0 noUnits
   (7) Zero[1] = x^2 + y^2 - R^2     
-> (8) Zero[1] = x^2 + y^2 - R^2

   (9) Zero[2] = y - (m*x + b)  
-> (10) Zero[2] = y - b - m*x

   (11) Input  x = 13,  y = 10      % Guesses for solution
   (12) Code Nonlinear( Zero, x, y ) [R=1,8,1] CircleLineIntersection.c



</PRE><nobr><a name="Dircos"><font color="darkBlue"><font size=+1><b>Dircos</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Dircos     (Superseded by SetRotationMatrix)

 Purpose:  Calculates and sets the direction cosine matrix (rotation matrix)
           relating two sets of dextral, orthogonal unit vectors in terms of
           orientation angles, Euler parameters, or Rodrigues parameters.

Syntax 1:  Dircos( A, B, TYPE,  q1, q2, q3 )
Syntax 2:  Dircos( A, B, EULER, e1, e2, e3, e4)
Syntax 3:  Dircos( A, B, RODRIGUES, rho1, rho2, rho3 )

   Input:  A, B -- names of reference frames (RigidFrame or RigidBody).

           TYPE -- BODYx  or  SPACEx, where x is one of 123, 132,
           231, 213, 312, 321, 121, 131, 232, 212, 313, 323

           q1, q2, q3 -- orientation angles characterizing
           the relative orientation of frames A and B.

           e1, e2, e3, e4 -- Euler parameters characterizing
           the relative orientation of frames A and B.

           rho1, rho2, rho3 -- Rodrigues parameters characterizing
           the relative orientation of frames A and B.

Output 1:  Calculates and sets the direction cosine matrix A_B,
           expressed in terms of q1, q2, q3

Output 2:  Calculates and sets the direction cosine matrix A_B,
           expressed in terms of e1, e2, e3, e4

Output 3:  Calculates and sets the direction cosine matrix A_B,
           expressed in terms of rho1, rho2, rho3

  Remark:  Definitions of orientation angles, Euler parameters,
           Rodrigues parameters, and direction cosines are in
           Kane, T. R.,  Likins, P. W.,  and Levinson D. A.,
           Spacecraft Dynamics, McGraw-Hill, 1983, Ch. 1., and
           Mitiguy, Paul, Advanced Dynamics for Professional
           Mechanical, Aerospace, and BioMechanical Engineers.

 Related:  <a href="#Rotate"><b>Rotate</b></a>   <a href="#RotateX"><b>RotateX</b></a>   <a href="#RotateY"><b>RotateY</b></a>   <a href="#RotateZ"><b>RotateZ</b></a>
           <a href="#RotateX"><b>RotateNegativeX</b></a>  <a href="#RotateY"><b>RotateNegativeY</b></a>  <a href="#RotateZ"><b>RotateNegativeZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixY</b></a>  <a href="#SetRotationMatrixZ"><b>SetRotationMatrixZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixNegativeX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixNegativeY</b></a>  ...
           <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>  <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>  <a href="#SetAngularAcceleration"><b>SetAngularAcceleration</b></a>
           <a href="#GetRotationMatrix"><b>GetRotationMatrix</b></a>  <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>  <a href="#GetAngularAcceleration"><b>GetAngularAcceleration</b></a>
           <a href="#SetRotationMatrixODE"><b>SetRotationMatrixODE</b></a>  <a href="#SetEulerParameterODE"><b>SetEulerParameterODE</b></a>  <a href="#SetRodriguesParameterODE"><b>SetRodriguesParameterODE</b></a>
           <a href="#Angvel"><b>ANGVEL</b></a>  <a href="#Dircos"><b>DIRCOS</b></a>  <a href="#KinDiffs"><b>KINDIFFS</b></a>  <a href="#Simprot"><b>SIMPROT</b></a>  SetDefaults( <a href="#AUTOLEV"><b>AUTOLEV</b></a> )

   (1) %--------------------------------------------------------------------
   (2) % Example 1: DIRCOS  (Orientation angles)
   (3) %--------------------------------------------------------------------
   (4) SetDefaults( AUTOLEV )
   (5) RigidFrame  A, B
   (6) Variable    q1, q2, q3
   (7) DIRCOS( A, B, Body123, q1, q2, q3 )
-> (8) A_B[1,1] = cos(q2)*cos(q3)
-> (9) A_B[1,2] = -sin(q3)*cos(q2)
-> (10) A_B[1,3] = sin(q2)
-> (11) A_B[2,1] = sin(q3)*cos(q1) + sin(q1)*sin(q2)*cos(q3)
-> (12) A_B[2,2] = cos(q1)*cos(q3) - sin(q1)*sin(q2)*sin(q3)
-> (13) A_B[2,3] = -sin(q1)*cos(q2)
-> (14) A_B[3,1] = sin(q1)*sin(q3) - sin(q2)*cos(q1)*cos(q3)
-> (15) A_B[3,2] = sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1)
-> (16) A_B[3,3] = cos(q1)*cos(q2)

   (17) %--------------------------------------------------------------------
   (18) % Example 2: DIRCOS  (Euler parameters)
   (19) %--------------------------------------------------------------------
   (20) RigidFrame  C
   (21) Variable    e1, e2, e3, e4 
   (22) DIRCOS( A, C, Euler, e1, e2, e3, e4 )
-> (23) A_C[1,1] = 1 - 2*e2^2 - 2*e3^2
-> (24) A_C[1,2] = 2*e1*e2 - 2*e3*e4
-> (25) A_C[1,3] = 2*e1*e3 + 2*e2*e4
-> (26) A_C[2,1] = 2*e1*e2 + 2*e3*e4
-> (27) A_C[2,2] = 1 - 2*e1^2 - 2*e3^2
-> (28) A_C[2,3] = 2*e2*e3 - 2*e1*e4
-> (29) A_C[3,1] = 2*e1*e3 - 2*e2*e4
-> (30) A_C[3,2] = 2*e1*e4 + 2*e2*e3
-> (31) A_C[3,3] = 1 - 2*e1^2 - 2*e2^2

   (32) %--------------------------------------------------------------------
   (33) % Example 3: DIRCOS  (Rodrigues parameters)
   (34) %--------------------------------------------------------------------
   (35) RigidFrame  D
   (36) Variable    rho1, rho2, rho3 
   (37) DIRCOS( A, D, Rodrigues, rho1, rho2, rho3 )
-> (38) A_D[1,1] = (1+rho1^2-rho2^2-rho3^2)/(1+rho1^2+rho2^2+rho3^2)
-> (39) A_D[1,2] = -2*(rho3-rho1*rho2)/(1+rho1^2+rho2^2+rho3^2)
-> (40) A_D[1,3] = 2*(rho2+rho1*rho3)/(1+rho1^2+rho2^2+rho3^2)
-> (41) A_D[2,1] = 2*(rho3+rho1*rho2)/(1+rho1^2+rho2^2+rho3^2)
-> (42) A_D[2,2] = (1+rho2^2-rho1^2-rho3^2)/(1+rho1^2+rho2^2+rho3^2)
-> (43) A_D[2,3] = -2*(rho1-rho2*rho3)/(1+rho1^2+rho2^2+rho3^2)
-> (44) A_D[3,1] = -2*(rho2-rho1*rho3)/(1+rho1^2+rho2^2+rho3^2)
-> (45) A_D[3,2] = 2*(rho1+rho2*rho3)/(1+rho1^2+rho2^2+rho3^2)
-> (46) A_D[3,3] = -(-1+rho1^2+rho2^2-rho3^2)/(1+rho1^2+rho2^2+rho3^2)



</PRE><nobr><a name="FrStar"><font color="darkBlue"><font size=+1><b>FrStar</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
FrStar     (superseded by -GetGeneralizedEffectiveForce)

 Purpose:  Forms  expressions  for  generalized inertia forces or
           contributions to generalized inertia forces.

Syntax 1:  FrStar()
Syntax 2:  FrStar( A1, A2, ... )

   Input:  A1, A2, ... -- a massive object, e.g., a Particle or RigidBody.

Output 1:  a column matrix, each element of which is the sum of the contri-
           butions of all massive objects to one generalized inertia force.

Output 2:  a column matrix, each element of which is the sum of the contri-
           butions of A1, A2, ... to one generalized inertia force.

  Remark:  The results produced by this command depend on whether
           the command precedes or follows a CONSTRAIN command.

 Related:  <a href="#GetGeneralizedEffectiveForce"><b>GetGeneralizedEffectiveForce</b></a>  <a href="#GetGeneralizedForce"><b>GetGeneralizedForce</b></a>
           <a href="#GetGeneralizedMomentum"><b>GetGeneralizedMomentum</b></a>  <a href="#GetTranslationalMomentum"><b>GetTranslationalMomentum</b></a>  <a href="#GetAngularMomentum"><b>GetAngularMomentum</b></a>
           <a href="#Constrain"><b>Constrain</b></a>  <a href="#MotionVariable"><b>MotionVariable</b></a>  MotionVariable'  <a href="#SetGeneralizedSpeed"><b>SetGeneralizedSpeed</b></a>
           <a href="#Gyrostat"><b>Gyrostat</b></a>  <a href="#SetMass"><b>SetMass</b></a>  <a href="#SetInertia"><b>SetInertia</b></a>  <a href="#Rotate"><b>Rotate</b></a>  <a href="#Translate"><b>Translate</b></a>
           <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#GetStatics"><b>GetStatics</b></a>  <a href="#Kane"><b>GetStaticsKane</b></a>
           <a href="#GetGeneralizedForce"><b>FR</b></a>  <a href="#FrStar"><b>FRSTAR</b></a>  SetDefaults( <a href="#AUTOLEV"><b>AUTOLEV</b></a> )

   (1) %--------------------------------------------------------------------
   (2) % Example 1: FRSTAR
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N
   (5) Particle  A
   (6) RigidBody B
   (7) A.SetMass( mA )
   (8) B.SetMass( mB )
   (9) B.SetInertia( Bcm, Ixx, Iyy, Izz )
   (10) Variable   wx',  wy',  wz',  vA'
   (11) SetGeneralizedSpeed(  wx,  wy,  wz,  vA  )
   (12) A.SetVelocity( N, vA*Nx> )
-> (13) v_A_N> = vA*Nx>

   (14) B.SetAngularVelocity( N, wx*Bx> + wy*By> + wz*Bz> )
-> (15) w_B_N> = wx*Bx> + wy*By> + wz*Bz>

   (16) Bcm.SetVelocity( N, 0> )
-> (17) v_Bcm_N> = 0>

   (18) FrStarA = FRSTAR( A )
-> (19) FrStarA = [0;  0;  0;  -mA*vA']

   (20) FrStarB = FRSTAR( B )
-> (21) FrStarB[1] = (Iyy-Izz)*wy*wz - Ixx*wx'
-> (22) FrStarB[2] = -(Ixx-Izz)*wx*wz - Iyy*wy'
-> (23) FrStarB[3] = (Ixx-Iyy)*wx*wy - Izz*wz'
-> (24) FrStarB[4] = 0

   (25) FrStarS = FRSTAR()
-> (26) FrStarS[1] = (Iyy-Izz)*wy*wz - Ixx*wx'
-> (27) FrStarS[2] = -(Ixx-Izz)*wx*wz - Iyy*wy'
-> (28) FrStarS[3] = (Ixx-Iyy)*wx*wy - Izz*wz'
-> (29) FrStarS[4] = -mA*vA'



</PRE><nobr><a name="Gyrostat"><font color="darkBlue"><font size=+1><b>Gyrostat</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Gyrostat   (may be superseded in future versions)

 Purpose:  Calculates expressions related to angular momentum, kinetic energy,
           and generalized inertia forces for systems containing gyrostats.

Syntax 1:  Gyrostat( Quantity, CYLINDER, Carrier, Rotor, J )
Syntax 2:  Gyrostat( Quantity, SPHERE,   Carrier, Rotor, K )

   Input:  Quantity -- FrStar, KE, or ANGMOM

           Carrier -- the  name of the carrier portion of a gyro-
           stat, named in a RigidBody declaration

           Rotor -- the  name of a rotor portion of the gyrostat,
           named in a RigidFrame declaration

           J -- the cylindrical Rotor's axial moment of inertia.

           K -- the spherical Rotor's diametral moment of inertia.

  Output:  The Quantity associated with Rotor's motion in Carrier, e.g.,
           when Quantity is KE, the portion of the gyrostat's kinetic energy
           (in NewtonianFrame) attributable to the Rotor's motion in Carrier.

  Remark:  The mass, center of mass, and inertia properties attributed
           to Carrier must be those of the gyrostat.
           The Rotor's angular in Carrier is used by the Gyrostat command.

 Related:  <a href="#GetAngularMomentum"><b>GetAngularMomentum</b></a>  <a href="#GetDynamics"><b>GetDynamics</b></a>  <a href="#Kane"><b>GetDynamicsKane</b></a>  <a href="#GetKineticEnergy"><b>GetKineticEnergy</b></a>
           <a href="#GetTranslationalMomentum"><b>GetTranslationalMomentum</b></a>  <a href="#GetGeneralizedMomentum"><b>GetGeneralizedMomentum</b></a>
           <a href="#GetGeneralizedEffectiveForce"><b>GetGeneralizedEffectiveForce</b></a>  <a href="#SetGeneralizedSpeed"><b>SetGeneralizedSpeed</b></a>
           <a href="#FrStar"><b>FRSTAR</b></a>  <a href="#MotionVariable"><b>MotionVariable</b></a>  MotionVariable'  SetDefaults( <a href="#AUTOLEV"><b>AUTOLEV</b></a> )

   (1) %--------------------------------------------------------------------
   (2) % Example: Gyrostat
   (3) %--------------------------------------------------------------------
   (4) NewtonianFrame N
   (5) RigidBody      A     % Carrier
   (6) RigidFrame     B     % Spherical   rotor
   (7) RigidFrame     C     % Cylindrical rotor
   (8) Constant       IB    % B's diametral moment of inertia 
   (9) Constant       IC    % C's moment of inertia along cylindrical axis
   (10) A.SetMass( mG )      % Attribute the gyrostat's mass and inertia to A.
   (11) A.SetInertia( Acm, IGx, IGy, IGz ) 
   (12) Variable       wx', wy', wz', w{1:3}', vx', vy', vz'
   (13) Specified      s' 
   (14) SetGeneralizedSpeed( wx, wy, wz, w{1:3}, vx, vy, vz )
   (15) A.SetAngularVelocity( N, wx*Ax> + wy*Ay> + wz*Az> )
-> (16) w_A_N> = wx*Ax> + wy*Ay> + wz*Az>

   (17) B.SetAngularVelocity( A, w1*Ax> + w2*Ay> + w3*Az> )
-> (18) w_B_A> = w1*Ax> + w2*Ay> + w3*Az>

   (19) C.SetAngularVelocity( A, s*Ax> )
-> (20) w_C_A> = s*Ax>

   (21) Acm.SetVelocity( N, vx*Ax> + vy*Ay> + vz*Az> )
-> (22) v_Acm_N> = vx*Ax> + vy*Ay> + vz*Az>

   (23) GyroH> = A.GetAngularMomentum(Acm) + Gyrostat(ANGMOM,CYLINDER,A,C,IC) + Gyrostat(ANGMOM,SPHERE,A,B,IB)
-> (24) GyroH> = (IC*s+IGx*wx+IB*w1)*Ax> + (IGy*wy+IB*w2)*Ay> + (IGz*wz+IB*w3)*Az>

   (25) GyroKE = A.GetKineticEnergy() + Gyrostat(KE,CYLINDER,A,C,IC) + Gyrostat(KE,SPHERE,A,B,IB)
-> (26) GyroKE = 0.5*IGx*wx^2 + 0.5*IGy*wy^2 + 0.5*IGz*wz^2 + 0.5*IC*s*(s+2*wx)
        + 0.5*mG*(vx^2+vy^2+vz^2) - 0.5*IB*(wx^2+wy^2+wz^2-(w1+wx)^2-(w2+wy)^2-
        (w3+wz)^2)

   (27) GyroFrStar = FRSTAR(A) + Gyrostat(FRSTAR,CYLINDER,A,C,IC) + Gyrostat(FRSTAR,SPHERE,A,B,IB)
-> (28) GyroFrStar[1] = (IGy-IGz)*wy*wz + IB*(w2*wz-w3*wy-w1') - IC*s' - IGx*wx'
-> (29) GyroFrStar[2] = IB*(w3*wx-w1*wz-w2') - IC*s*wz - (IGx-IGz)*wx*wz - IGy*wy'
-> (30) GyroFrStar[3] = IC*s*wy + (IGx-IGy)*wx*wy + IB*(w1*wy-w2*wx-w3') - IGz*wz'
-> (31) GyroFrStar[4] = IB*(w2*wz-w3*wy-w1'-wx')
-> (32) GyroFrStar[5] = IB*(w3*wx-w1*wz-w2'-wy')
-> (33) GyroFrStar[6] = IB*(w1*wy-w2*wx-w3'-wz')
-> (34) GyroFrStar[7] = mG*(vy*wz-vz*wy-vx')
-> (35) GyroFrStar[8] = mG*(vz*wx-vx*wz-vy')
-> (36) GyroFrStar[9] = mG*(vx*wy-vy*wx-vz')



</PRE><nobr><a name="KinDiffs"><font color="darkBlue"><font size=+1><b>KinDiffs</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
KinDiffs  (superseded by  SetRotationMatrixODE,  SetEulerParameterODE,
           SetRodriguesParameterODE  SetPoissonParameterODE)

 Purpose:  Sets the first time-derivatives of orientation angles,
           Euler parameters, Rodrigues parameters, or direction
           cosines in terms of angular velocity measure numbers.

Syntax 1:  KinDiffs( A, B, SequenceIJK,  q1, q2, q3 )
Syntax 2:  KinDiffs( A, B, Euler, e1, e2, e3, e4 )
Syntax 3:  KinDiffs( A, B, Rodrigues, rho1, rho2, rho3 )
Syntax 4:  KinDiffs( A, B  Poisson, C11,C12,C13,
                           C21,C22,C23, C31,C32,C33 )

   Input:  A, B -- names of reference frames (RigidFrame or RigidBody).

           SequenceIJK -- BodyIJK or SpaceIJK, where IJK is one of:
           123, 132, 231, 213, 312, 321, 121, 131, 232, 212, 313, 323

           q1, q2, q3 -- names of radian measures of orientation angles
           characterizing the relative orientation of frames A and B.

           e1, e2, e3, e4 -- names of Euler parameters
           characterizing the relative orientation of frames A and B.

           rho1, rho2, rho3 -- names of Rodrigues parameters
           characterizing the relative orientation of frames A and B.

           C11, C12, ..., C33 -- names of direction cosines
           characterizing the relative orientation of frames A and B.

Output 1:  Expresses q1', q2', and q3' in terms of q1, q2, q3,
           and frame B's angular velocity in frame A.

Output 2:  Expresses e1', e2', e3', and e4' in terms of e1, e2, e3, e4,
           and frame B's angular velocity in frame A.

Output 3:  Expresses rho1', rho2', and rho3' in terms of rho1, rho2, rho3,
           and frame B's angular velocity in frame A.

Output 4:  Expresses C11', ... C33' in terms of C11, ... C33,
           and frame B's angular velocity in frame A.

  Remark:  Frame B's angular velocity in frame A or its equivalent must be
           in the workspace before the KinDiffs command is issued.

  Remark:  Definitions of orientation angles, Euler parameters,
           Rodrigues parameters, and direction cosines are in
           Kane, T. R.,  Likins, P. W.,  and Levinson D. A.,
           Spacecraft Dynamics, McGraw-Hill, 1983, Ch. 1., and
           Mitiguy, Paul, Advanced Dynamics for Professional
           Mechanical, Aerospace, and BioMechanical Engineers.

 Related:  <a href="#Rotate"><b>Rotate</b></a>  <a href="#RotateX"><b>RotateX</b></a>  <a href="#RotateY"><b>RotateY</b></a>  <a href="#RotateZ"><b>RotateZ</b></a>
           <a href="#RotateX"><b>RotateNegativeX</b></a>  <a href="#RotateY"><b>RotateNegativeY</b></a>  <a href="#RotateZ"><b>RotateNegativeZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixY</b></a>  <a href="#SetRotationMatrixZ"><b>SetRotationMatrixZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixNegativeX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixNegativeY</b></a>  ...
           <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>  <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>  <a href="#SetAngularAcceleration"><b>SetAngularAcceleration</b></a>
           <a href="#GetRotationMatrix"><b>GetRotationMatrix</b></a>  <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>  <a href="#GetAngularAcceleration"><b>GetAngularAcceleration</b></a>
           <a href="#SetRotationMatrixODE"><b>SetRotationMatrixODE</b></a>  <a href="#SetEulerParameterODE"><b>SetEulerParameterODE</b></a>  <a href="#SetRodriguesParameterODE"><b>SetRodriguesParameterODE</b></a>
           <a href="#Angvel"><b>ANGVEL</b></a>  <a href="#KinDiffs"><b>KINDIFFS</b></a>  SetDefaults( <a href="#AUTOLEV"><b>AUTOLEV</b></a> )

   (1) %--------------------------------------------------------------------
   (2) % Example 1: KinDiffs  (Orientation angles)
   (3) %--------------------------------------------------------------------
   (4) RigidFrame  A, B
   (5) Variable    q1', q2', q3'
   (6) Variable    wx,  wy,  wz
   (7) B.SetAngularVelocity( A, wx*Bx> + wy*By> + wz*Bz> )
-> (8) w_B_A> = wx*Bx> + wy*By> + wz*Bz>

   (9) KinDiffs( A, B, Body123, q1, q2, q3 )
-> (10) q1' = (wx*cos(q3)-wy*sin(q3))/cos(q2)
-> (11) q2' = wx*sin(q3) + wy*cos(q3)
-> (12) q3' = wz - tan(q2)*(wx*cos(q3)-wy*sin(q3))

   (13) %--------------------------------------------------------------------
   (14) % Example 2: KinDiffs  (Euler parameters)
   (15) %--------------------------------------------------------------------
   (16) Variable    e1', e2', e3', e4' 
   (17) KinDiffs( A, B, Euler, e1, e2, e3, e4 )
-> (18) e1' = 0.5*e2*wz + 0.5*e4*wx - 0.5*e3*wy
-> (19) e2' = 0.5*e3*wx + 0.5*e4*wy - 0.5*e1*wz
-> (20) e3' = 0.5*e1*wy + 0.5*e4*wz - 0.5*e2*wx
-> (21) e4' = -0.5*e1*wx - 0.5*e2*wy - 0.5*e3*wz

   (22) %--------------------------------------------------------------------
   (23) % Example 3: KinDiffs  (Rodrigues parameters)
   (24) %--------------------------------------------------------------------
   (25) Variable    r1', r2', r3' 
   (26) KinDiffs( A, B, Rodrigues, r1, r2, r3 )
-> (27) r1' = 0.5*wx*(1+r1^2) + 0.5*wz*(r2+r1*r3) - 0.5*wy*(r3-r1*r2)
-> (28) r2' = 0.5*wx*(r3+r1*r2) + 0.5*wy*(1+r2^2) - 0.5*wz*(r1-r2*r3)
-> (29) r3' = 0.5*wy*(r1+r2*r3) + 0.5*wz*(1+r3^2) - 0.5*wx*(r2-r1*r3)

   (30) %--------------------------------------------------------------------
   (31) % Example 4: KinDiffs  (Direction cosines)
   (32) %--------------------------------------------------------------------
   (33) Variable    C{1:3,1:3}' 
   (34) KinDiffs( A, B, Poisson, C11,C12,C13, C21,C22,C23, C31,C32,C33 )
-> (35) C11' = C12*wz - C13*wy
-> (36) C12' = C13*wx - C11*wz
-> (37) C13' = C11*wy - C12*wx
-> (38) C21' = C22*wz - C23*wy
-> (39) C22' = C23*wx - C21*wz
-> (40) C23' = C21*wy - C22*wx
-> (41) C31' = C32*wz - C33*wy
-> (42) C32' = C33*wx - C31*wz
-> (43) C33' = C31*wy - C32*wx



</PRE><nobr><a name="Simprot"><font color="darkBlue"><font size=+1><b>Simprot</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
Simprot    (superseded by SetRotationMatrixX, RotateX, etc)

 Purpose:  Forms rotation matrices associated with a simple rotation
           of one reference frame in another reference frame.

Syntax 1:  Simprot( A, B, Integer, Angle )
Syntax 2:  Simprot( A, B, Vec,     Angle )

   Input:  A, B -- names of reference frames (RigidFrame or RigidBody).

           Integer -- 1, 2, 3, -1, -2, or -3.

           Angle -- scalar expression.

           Vec -- vector whose orientation in A and B remains unaltered
           during the simple rotation of B in A.

  Output:  Sets the rotation matrix (direction cosine matrix)
           A_B expressed in terms of sines and cosines of Angle.

  Remark:  Simprot is superseded by SetRotationMatrixX, RotateX, etc.

 Related:  <a href="#Rotate"><b>Rotate</b></a>  <a href="#RotateX"><b>RotateX</b></a>  <a href="#RotateY"><b>RotateY</b></a>  <a href="#RotateZ"><b>RotateZ</b></a>
           <a href="#RotateX"><b>RotateNegativeX</b></a>  <a href="#RotateY"><b>RotateNegativeY</b></a>  <a href="#RotateZ"><b>RotateNegativeZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixY</b></a>  <a href="#SetRotationMatrixZ"><b>SetRotationMatrixZ</b></a>
           <a href="#SetRotationMatrixX"><b>SetRotationMatrixNegativeX</b></a>  <a href="#SetRotationMatrixY"><b>SetRotationMatrixNegativeY</b></a>  ...
           <a href="#SetRotationMatrix"><b>SetRotationMatrix</b></a>  <a href="#SetAngularVelocity"><b>SetAngularVelocity</b></a>  <a href="#SetAngularAcceleration"><b>SetAngularAcceleration</b></a>
           <a href="#GetRotationMatrix"><b>GetRotationMatrix</b></a>  <a href="#GetAngularVelocity"><b>GetAngularVelocity</b></a>  <a href="#GetAngularAcceleration"><b>GetAngularAcceleration</b></a>
           <a href="#SetRotationMatrixODE"><b>SetRotationMatrixODE</b></a>  <a href="#SetEulerParameterODE"><b>SetEulerParameterODE</b></a>  <a href="#SetRodriguesParameterODE"><b>SetRodriguesParameterODE</b></a>
           <a href="#Angvel"><b>ANGVEL</b></a>  <a href="#Dircos"><b>DIRCOS</b></a>  <a href="#KinDiffs"><b>KINDIFFS</b></a>  <a href="#Simprot"><b>SIMPROT</b></a>  SetDefaults( <a href="#AUTOLEV"><b>AUTOLEV</b></a> )

   (1) %--------------------------------------------------------------------
   (2) % Example: SIMPROT 
   (3) %--------------------------------------------------------------------
   (4) SetDefaults( AUTOLEV )
   (5) RigidFrame  A, B, C
   (6) SIMPROT( A, B, 2, t )
-> (7) A_B = [cos(t), 0, sin(t); 0, 1, 0; -sin(t), 0, cos(t)]

   (8) SIMPROT( B, C, A1> - B2>, t )
-> (9) B_C[1,1] = 0.5*cos(t)*(2+cos(t)*(1-cos(t)))
-> (10) B_C[1,2] = -0.7071068*sin(t)^2 - 0.5*cos(t)*(1-cos(t))
-> (11) B_C[1,3] = 0.5*sin(t)*(-1.414214+cos(t)*(1-cos(t)))
-> (12) B_C[2,1] = 0.7071068*sin(t)^2 - 0.5*cos(t)*(1-cos(t))
-> (13) B_C[2,2] = 0.5 + 0.5*cos(t)
-> (14) B_C[2,3] = -0.2071068*sin(t)*(2.414214+cos(t))
-> (15) B_C[3,1] = 0.5*sin(t)*(1.414214+cos(t)*(1-cos(t)))
-> (16) B_C[3,2] = -0.5*sin(t)*(1-2.414214*cos(t))
-> (17) B_C[3,3] = cos(t) + 0.5*sin(t)^2*(1-cos(t))



</PRE><nobr><a name="V1PT"><font color="darkBlue"><font size=+1><b>V1PT</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
V1PT       (Superseded by SetVelocity)
A1PT       (Superseded by SetAcceleration)

 Purpose:  Calculates and sets the velocity (or acceleration) of a point
           moving on a reference frame.

Syntax 1:  V1PT( N, B, BQ, Q )
Syntax 2:  A1PT( N, B, BQ, Q )

   Input:  N -- a reference frame (e.g., a RigidFrame or RigidBody).
           B -- a reference frame (e.g., a RigidFrame or RigidBody).
           BQ -- the point fixed on B that is coincident with Q.
           Q -- a point moving on B that is coincident with BQ.

Output 1:  Calculate and sets V_Q_N>, Q's velocity in N.
Output 2:  Calculate and sets A_Q_N>, Q's acceleration in N.

  Remark:  The V1PT calculation uses the following quantities:
           --  B's  angular velocity in N
           --  BQ's velocity in N
           --  Q's  velocity in B
  Remark:  The A1PT calculation uses the following quantities:
           --  B's  angular velocity and angular acceleration in N
           --  BQ's acceleration in N
           --  Q's  velocity and acceleration in B

  Remark:  V1PT(N, B, BQ, Q) is superseded by Q.SetVelocity(N, fromPoint, B, BQ)
           A1PT(N, B, BQ, Q) is now Q.SetAcceleration(N, fromPoint, B, BQ)
           where fromPoint is a point fixed on BFrame.

 Related:  <a href="#Translate"><b>Translate</b></a>        <a href="#SetPositionVelocity"><b>SetPositionVelocity</b></a>   <a href="#SetVelocityAcceleration"><b>SetVelocityAcceleration</b></a>
           <a href="#SetPosition"><b>SetPosition</b></a>      <a href="#GetPosition"><b>GetPosition</b></a>   <a href="#GetDistance"><b>GetDistance</b></a>
           <a href="#SetVelocity"><b>SetVelocity</b></a>      <a href="#GetVelocity"><b>GetVelocity</b></a>   <a href="#GetSpeed"><b>GetSpeed</b></a>   <a href="#GetElongation"><b>GetElongation</b></a>
           <a href="#SetAcceleration"><b>SetAcceleration</b></a>  <a href="#GetAcceleration"><b>GetAcceleration</b></a>
           <a href="#V1PT"><b>A1PT</b></a>  <a href="#V2PTS"><b>A2PTS</b></a>  <a href="#V1PT"><b>V1PT</b></a>  <a href="#V2PTS"><b>V2PTS</b></a>  SetDefaults( <a href="#AUTOLEV"><b>AUTOLEV</b></a> )

   (1) %--------------------------------------------------------------------
   (2) % Example: V1PT  (velocity of a point Q moving on rigid body B)
   (3) %--------------------------------------------------------------------
   (4) RigidFrame N             
   (5) RigidBody  B
   (6) Point      BQ(B)   % BQ is the point of B coincident with Q.
   (7) Point      Q       % Q is moving on B.
   (8) Variable   r''     % Relates to Q's position on B.
   (9) Variable   wz'  
   (10) B.SetAngularVelocityAcceleration( N,  wz*Bz>  )
-> (11) w_B_N> = wz*Bz>
-> (12) alf_B_N> = wz'*Bz>

   (13) Q.SetVelocityAcceleration( B,  r'*Bx>  )
-> (14) v_Q_B> = r'*Bx>
-> (15) a_Q_B> = r''*Bx>

   (16) %--------------------------------
   (17) BQ.SetVelocity( N,  r*wz*By>  )
-> (18) v_BQ_N> = r*wz*By>

   (19) V1PT( N, B, BQ, Q )
-> (20) V_Q_N> = r'*Bx> + r*wz*By>

   (21) %--------------------------------------------------------------------
   (22) % Example: A1PT  (acceleration of a point Q moving on rigid body B)
   (23) %--------------------------------------------------------------------
   (24) BQ.SetAcceleration( N, r*wz'*By> - r*wz^2*Bx> )
-> (25) a_BQ_N> = -r*wz^2*Bx> + r*wz'*By>

   (26) A1PT( N, B, BQ, Q )
-> (27) A_Q_N> = (r''-r*wz^2)*Bx> + (r*wz'+2*wz*r')*By>



</PRE><nobr><a name="V2PTS"><font color="darkBlue"><font size=+1><b>V2PTS</b></font></font></a></nobr>
<hr align="left" color="darkBlue" noshade size="5px" STYLE="width:78ch; height:0.30ch"><PRE>
V2PTS      (Superseded by SetVelocity)
A2PTS      (Superseded by SetAcceleration)
VA2PTS     (Superseded by SetVelocityAcceleration)

 Purpose:  For two points fixed on a reference frame (RigidBody or RigidFrame)
           calculates and sets the velocity (or acceleration) of one point
           from the velocity (or acceleration) of the other.

Syntax 1:  V2PTS(  N, B, P, Q )
Syntax 2:  A2PTS(  N, B, P, Q )
Syntax 3:  VA2PTS( N, B, P, Q )

   Input:  N -- a reference frame (e.g., a RigidFrame or RigidBody).
           B -- a reference frame (e.g., a RigidFrame or RigidBody).
           P -- a point fixed on B, whose velocity (or acceleration)
               in N is known.
           Q -- a point fixed on B, whose velocity (or acceleration)
               in N is to be determined.

Output 1:  Calculate and sets v_Q_N>, Q's velocity in N.
Output 2:  Calculate and sets a_Q_N>, Q's acceleration in N.
Output 3:  Calculate and sets v_Q_N> and a_Q_N>.

  Remark:  The V2PTS and VA2PTS calculation uses the following quantities:
           --  B's angular velocity in N
           --  P's velocity in N
           --  Q's position vector from P
           The A2PTS and VA2PTS calculation uses the following quantities:
           --  B's angular velocity and angular acceleration in N
           --  P's acceleration in N
           --  Q's position vector from P

  Remark:  V2PTS( N, B, P, Q ) is superseded by Q.SetVelocity( N, P, B )
           A2PTS( N, B, P, Q ) is superseded by Q.SetAcceleration( N, P, B )
           VA2PTS(N, B, P, Q ) is now Q.SetVelocityAcceleration( N, P, B )

 Related:  <a href="#Translate"><b>Translate</b></a>        <a href="#SetPositionVelocity"><b>SetPositionVelocity</b></a>   <a href="#SetVelocityAcceleration"><b>SetVelocityAcceleration</b></a>
           <a href="#SetPosition"><b>SetPosition</b></a>      <a href="#GetPosition"><b>GetPosition</b></a>   <a href="#GetDistance"><b>GetDistance</b></a>
           <a href="#SetVelocity"><b>SetVelocity</b></a>      <a href="#GetVelocity"><b>GetVelocity</b></a>   <a href="#GetSpeed"><b>GetSpeed</b></a>   <a href="#GetElongation"><b>GetElongation</b></a>
           <a href="#SetAcceleration"><b>SetAcceleration</b></a>  <a href="#GetAcceleration"><b>GetAcceleration</b></a>
           <a href="#V1PT"><b>A1PT</b></a>  <a href="#V2PTS"><b>A2PTS</b></a>  <a href="#V1PT"><b>V1PT</b></a>  <a href="#V2PTS"><b>V2PTS</b></a>  SetDefaults( <a href="#AUTOLEV"><b>AUTOLEV</b></a> )

   (1) %--------------------------------------------------------------------
   (2) % Example: V2PTS  (velocity of a point Q fixed on rigid body B)
   (3) %--------------------------------------------------------------------
   (4) RigidFrame N             
   (5) RigidBody  B      % Points P and Q are both fixed on B.
   (6) Point      P(B)   % P is a point fixed on B.
   (7) Point      Q(B)   % Q is a point fixed on B.
   (8) Constant   r      % Bx> measure of Q's position from P.
   (9) Variable   wz' 
   (10) B.SetAngularVelocityAcceleration( N,  wz*Bz> )
-> (11) w_B_N> = wz*Bz>
-> (12) alf_B_N> = wz'*Bz>

   (13) Q.SetPosition( P,  r*Bx> )
-> (14) p_P_Q> = r*Bx>

   (15) P.SetVelocityAcceleration( N,  2*Nx> + 3*t*Ny> )
-> (16) v_P_N> = 2*Nx> + 3*t*Ny>
-> (17) a_P_N> = 3*Ny>

   (18) %----------------------------------
   (19) V2PTS( N, B, P, Q )
-> (20) v_Q_N> = r*wz*By> + 2*Nx> + 3*t*Ny>

   (21) %--------------------------------------------------------------------
   (22) % Example: A2PTS  (acceleration of a point Q fixed on rigid body B)
   (23) %--------------------------------------------------------------------
   (24) A2PTS( N, B, P, Q )
-> (25) a_Q_N> = -r*wz^2*Bx> + r*wz'*By> + 3*Ny>

   (26) %--------------------------------------------------------------------
   (27) % Example: VA2PTS  (velocity and acceleration of point Q fixed on B)
   (28) %--------------------------------------------------------------------
   (29) VA2PTS( N, B, P, Q )
-> (30) v_Q_N> = r*wz*By> + 2*Nx> + 3*t*Ny>
-> (31) a_Q_N> = -r*wz^2*Bx> + r*wz'*By> + 3*Ny>


</PRE><nobr><font color="darkBlue"><b>Copyright (c) 2009-2021 Motion Genesis LLC.  All rights reserved.</b></font></nobr>
</DIV></BODY></HTML>
